<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RISC-V 简介 | fzdwx</title><meta name=keywords content="risc-v"><meta name=description content="Resource &nbsp;RISC-V Green Card &nbsp;RISC-V Call convertion &nbsp;P&H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。
TIP 寄存器（Register）是&nbsp;中央处理器 内用来暂存指令、&nbsp;数据 和&nbsp;地址 的&nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 => x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。
ld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。"><meta name=author content="fzdwx"><link rel=canonical href=https://fzdwx.github.io/posts/2022-12-10-risc-v/><link crossorigin=anonymous href=/assets/css/stylesheet.min.eb182c2fc225cb57e6032b17e1506450a0999d8d31dcfab8f6662ebce29da943.css integrity="sha256-6xgsL8Ily1fmAysX4VBkUKCZnY0x3Pq49mYuvOKdqUM=" rel="preload stylesheet" as=style><link rel=icon href=https://fzdwx.github.io/favicon.ico><link rel=apple-touch-icon href=https://fzdwx.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:title content="RISC-V 简介 | fzdwx"><meta name=twitter:description content="Resource &nbsp;RISC-V Green Card &nbsp;RISC-V Call convertion &nbsp;P&H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。
TIP 寄存器（Register）是&nbsp;中央处理器 内用来暂存指令、&nbsp;数据 和&nbsp;地址 的&nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 => x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。
ld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。"><meta property="og:title" content="RISC-V 简介 | fzdwx"><meta property="og:description" content="Resource &nbsp;RISC-V Green Card &nbsp;RISC-V Call convertion &nbsp;P&H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。
TIP 寄存器（Register）是&nbsp;中央处理器 内用来暂存指令、&nbsp;数据 和&nbsp;地址 的&nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 => x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。
ld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。"><meta property="og:type" content="article"><meta property="og:url" content="https://fzdwx.github.io/posts/2022-12-10-risc-v/"><meta property="og:image" content="https://avatars.githubusercontent.com/u/65269574?v=4"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-10T20:41:41+08:00"><meta property="article:modified_time" content="2022-12-10T20:41:41+08:00"><meta property="og:site_name" content="fzdwx"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fzdwx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"RISC-V 简介","item":"https://fzdwx.github.io/posts/2022-12-10-risc-v/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RISC-V 简介 | fzdwx","name":"RISC-V 简介","description":"Resource \u0026nbsp;RISC-V Green Card \u0026nbsp;RISC-V Call convertion \u0026nbsp;P\u0026amp;H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。\nTIP 寄存器（Register）是\u0026nbsp;中央处理器 内用来暂存指令、\u0026nbsp;数据 和\u0026nbsp;地址 的\u0026nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在\u0026nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速\u0026nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 =\u0026gt; x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。\nld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。","keywords":["risc-v"],"wordCount":"912","inLanguage":"en","datePublished":"2022-12-10T20:41:41+08:00","dateModified":"2022-12-10T20:41:41+08:00","author":{"@type":"Person","name":"fzdwx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fzdwx.github.io/posts/2022-12-10-risc-v/"},"publisher":{"@type":"Organization","name":"fzdwx","logo":{"@type":"ImageObject","url":"https://fzdwx.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark"),document.body.classList.add("light");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches?document.body.classList.add("dark"):document.body.classList.add("light")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/400.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/400-italic.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/500.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/500-italic.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/700.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/800.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/700-italic.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.11/800-italic.css><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[","]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><div class=sticky-top><div class=header-bar></div><header class=header><nav class=nav><div class=logo><a href=https://fzdwx.github.io/ accesskey=h title="fzdwx (Alt + H)">fzdwx</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><img class=logo-img src=/images/party_parrot.gif alt=logo aria-label=logo height=30 width=30></li><li><a href=https://fzdwx.github.io/notes/ title=Notes>Notes</a></li><li><a href=https://fzdwx.github.io/archives/ title=Archives>Archives</a></li><li><a href=https://fzdwx.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://fzdwx.github.io/links/ title=Links>Links</a></li></ul></nav></header></div><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fzdwx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fzdwx.github.io/posts/>Posts</a></div><h1 class=post-title>RISC-V 简介</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>&nbsp;2022-12-10</span></span><span class=meta-item>
<span class=post-tags><span class=post-tag><a href=https://fzdwx.github.io/tags/risc-v/>#risc-v</a></span></span></span></div></header><div class=post-content><h2 id=resource>Resource<a hidden class=anchor aria-hidden=true href=#resource>¶</a></h2><ol><li>&nbsp;<a href=https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf target=_blank rel=noopener>RISC-V Green Card</a></li><li>&nbsp;<a href=https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/RISCV_Calling_Convention.pdf target=_blank rel=noopener>RISC-V Call convertion</a></li><li>&nbsp;<a href=https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf target=_blank rel=noopener>P&H(RISC-V)</a></li></ol><p>在汇编语言中没有变量这个概念，汇编语言通常操作的是<strong>寄存器</strong>。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。</p><div class="tip custom-block"><p class=custom-block-title>TIP</p><p><strong>寄存器</strong>（Register）是&nbsp;<a href=https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8 title=中央处理器 target=_blank rel=noopener>中央处理器</a>
内用来暂存指令、&nbsp;<a href=https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A title=数据 target=_blank rel=noopener>数据</a>
和&nbsp;<a href=https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80 title=内存地址 target=_blank rel=noopener>地址</a>
的&nbsp;<a href=https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94 title=电脑存储器 target=_blank rel=noopener>电脑存储器</a>
。寄存器的存贮容量有限，读写速度非常快。在&nbsp;<a href=https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%9E%B6%E6%A7%8B title=计算机体系结构 target=_blank rel=noopener>计算机体系结构</a>
里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;<a href=https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F title=计算机程序 target=_blank rel=noopener>计算机程序</a>
的执行。</p></div><h2 id=risc-v-card>RISC-V Card<a hidden class=anchor aria-hidden=true href=#risc-v-card>¶</a></h2><h3 id=risc-v-操作数>RISC-V 操作数<a hidden class=anchor aria-hidden=true href=#risc-v-操作数>¶</a></h3><p><figure id=a-/images/Pasted%20image%2020221210211515.png class=align-center><img src=/images/Pasted%20image%2020221210211515.png alt></figure></p><ul><li>如果寄存器的大小是 64位 则称为<strong>双字</strong>，32位 则是<strong>单字</strong>。</li><li>x<sub>0</sub> 被硬连接到 0<ul><li><code>add x3, x4, x0</code> => <code>x3 = x4</code> (x0 is hard-wired to value 0)</li></ul></li></ul><h2 id=汇编指令>汇编指令<a hidden class=anchor aria-hidden=true href=#汇编指令>¶</a></h2><p><figure id=a-/images/Pasted%20image%2020221210211545.png class=align-center><img src=/images/Pasted%20image%2020221210211545.png alt></figure><figure id=a-/images/Pasted%20image%2020221210211603.png class=align-center><img src=/images/Pasted%20image%2020221210211603.png alt></figure></p><h2 id=存储操作数>存储操作数<a hidden class=anchor aria-hidden=true href=#存储操作数>¶</a></h2><div class="tip custom-block"><p class=custom-block-title>TIP</p><p>将数据从内存复制到寄存器的数据传输指令称为 <em>载入指令(<code>load</code>)</em>。在 RISC-V 中指令是 <strong>ld</strong>,表示取双字。</p></div><h3 id=一个从数组中取值的c程序写出汇编代码>一个从数组中取值的C程序，写出汇编代码<a hidden class=anchor aria-hidden=true href=#一个从数组中取值的c程序写出汇编代码>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=n>h</span> <span class=o>+</span> <span class=n>A</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span></code></pre></div><p>A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或<em>基址</em>位于 x22 中。</p><pre tabindex=0><code class=language-risc-v data-lang=risc-v>ld x9, 8(x22) // x9 = A[8]
add x21, x20, x9; // x21 = x20 + x9
</code></pre><p>存放基址的寄存器(x22)被称为<em>基址寄存器</em>, 数据传输指令中的 8 称为<em>偏移量</em>。</p><p><figure id=a-/images/Pasted%20image%2020221212130603.png class=align-center><img src=/images/Pasted%20image%2020221212130603.png alt="实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数"><figcaption>实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数</figcaption></figure></p><div class="tip custom-block"><p class=custom-block-title>大端与小端编址</p><p><p>计算机分为两种，一种使用最左边或“大端”字节的地址作为双字地址，另一种使用最右端或“小端”字节的地址作为双字地址。</p><p>RISC-V 使用小端 。由于仅在以双字形式和 8 个单独字节访问相同数据时，字节顺序才有影响，因此大多情况不需要关系“大小端”。</p></p></div><p>所以为了上面的代码获得正确的字节地址加到 x22 这个寄存器的偏移量为 64（8x8）。</p><p>与载入指令相反的指令通常被成为<em>存储指令(store)</em>,从寄存器复制数据到内存。指令是<code>sd</code>,表示存储双字。</p><div class="tip custom-block"><p class=custom-block-title>TIP</p><p>在一些体系结构中，字的起始地址必须是 4 的倍数，双字的起始地址必须是 8 的倍数。该要求成为<em>对齐限制</em></p></div><p>RISC-V 和 Intel x86 没有对齐限制，但 MIPS 有这个限制。</p><p><figure id=a-/images/Pasted%20image%2020221212152022.png class=align-center><img src=/images/Pasted%20image%2020221212152022.png alt></figure></p><h3 id=使用-load-和-store-编译生成指令>使用 load 和 store 编译生成指令<a hidden class=anchor aria-hidden=true href=#使用-load-和-store-编译生成指令>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>A</span><span class=p>[</span><span class=mi>12</span><span class=p>]</span> <span class=o>=</span> <span class=n>h</span> <span class=o>+</span> <span class=n>A</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span></code></pre></div><p>h 存放在 x21 中，A 的基址存放在 x22 中。</p><pre tabindex=0><code class=language-risc-v data-lang=risc-v>ld x9, 64(x22)  // x9 = A[8]
add x9, x21, x9 // x9 = h + A[8]
sd x9, 96(x22)  // A[12] = x9
</code></pre><h3 id=将字符串复制程序编译为汇编>将字符串复制程序编译为汇编<a hidden class=anchor aria-hidden=true href=#将字符串复制程序编译为汇编>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>strcpy</span><span class=p>(</span><span class=kt>char</span> <span class=n>x</span><span class=p>[],</span><span class=kt>char</span> <span class=n>y</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>	<span class=kt>size_t</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>((</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>x, y 的基址存放在 x10 和 x11 中， i 存放在 x19 中。</p><pre tabindex=0><code class=language-risc-v data-lang=risc-v>strcpy:
	addi sp, sp, -8  // 调整栈指针，以存放一个item(x19)
	sd x19, 0(sp)    // x19 入栈
	add x19, x0, x0  // x19 = 0 + 0
L1: add x5, x19, x11 // x5 = x19 + x11 =&gt; address of y[i] in x5
	lbu x6, 0(x5)    // temp: x6 = y[i]
	add x7, x19, x10 // x5 = x19 + x11 =&gt; address of x[i] in x7
	sd  x6, 0(x7)    // x[i] = y[i]
	beq x6, x0, L2   // if x6 ==0 then go to L2
	addi x19, x19, 1 // i = i  + 1
	jal x0, L1       // go to L1
L2: ld x19, 0(sp)    // 恢复 x19 以及栈指针
	addi sp, sp, 8 
	jalr x0, 0(x1)
</code></pre><h3 id=一段循环代码编译为汇编>一段循环代码编译为汇编<a hidden class=anchor aria-hidden=true href=#一段循环代码编译为汇编>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span>  <span class=mi>3</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>sum</span> <span class=o>+=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>RISC-V 汇编（32 bit)</p><pre tabindex=0><code class=language-risc-v data-lang=risc-v>	add x9, x8, x0     # x9 = &amp;A[0]
	add x10, x0, x0    # sum
	add x11, x0, x0    # i
	addi x13,x0, 20    # 20
Loop:
	bge x11, x13, Done # if x11 &gt; x13 go to Down(end loop)
	lw x12, 0(x9)      # x12 = A[i]
	add x10, x10, x12  # sum
	addi x9, x9, 4     # x9 = &amp;A[i+1]
	addi x11, x11, 1   # i++
	j loop
Done:
</code></pre><h2 id=逻辑操作>逻辑操作<a hidden class=anchor aria-hidden=true href=#逻辑操作>¶</a></h2><ul><li><code>and</code> <code>andi</code><ul><li><code>and x5, x6, x9</code> => x5 = x6 & x9</li><li><code>addi x5, x6, 3</code> => x5 = x6 & 3</li></ul></li><li><code>sll</code> <code>ssli</code> , 左移(扩大)<ul><li><code>slli x11, x23, 2</code> => x11 = x23 &#171; 2</li><li>0000 0010 => 2</li><li>0000 1000 => 8</li></ul></li><li><code>srl</code> <code>srli</code> , 右移（缩小)<ul><li><code>srli x23, x11, 2</code> = > x23 = x11 &#187; 2</li><li>0000 1000 => 8</li><li>0000 0010 => 2</li></ul></li><li><code>sra</code> <code>srai</code>, 算数右移<ul><li>1111 1111 1111 1111 1111 1111 1110 0111 = -25</li><li><code>srai x10, x10, 4</code></li><li>1111 1111 1111 1111 1111 1111 1111 1110 = -2</li></ul></li></ul><h2 id=helpful-risc-v-assmebler-features>Helpful RISC-V Assmebler Features<a hidden class=anchor aria-hidden=true href=#helpful-risc-v-assmebler-features>¶</a></h2><ol><li>a0 - a7 是参数寄存器(x10 - x17，用于函数调用。</li><li>zero 代表 x0</li><li><code>mv rd, rs = addi rd, rs, 0</code></li><li><code>li rd, 13 = addi rd, x0, 13</code></li><li><code>nop = addi x0, x0</code></li><li>a0 - a7(x10 - x17): 8 个寄存器用于参数传递以及两个返回值(a0 - a1)</li><li>ra（x1）: 一个返回 address 的寄存器，用于返回原点（调用的位置）</li><li>s0 - s1(x8 - x9) and s2 - s11 (s18 - x27): 保存的寄存器</li></ol><h2 id=risc-v-函数调用的转换>RISC-V 函数调用的转换<a hidden class=anchor aria-hidden=true href=#risc-v-函数调用的转换>¶</a></h2><ol><li>寄存器比内存快，所以使用它们</li><li><code>jal rd, Label</code> 跳转和链接<ol><li><code>jal x1, 100</code></li></ol></li><li><code>jalr rd, rs, imm</code> 跳转和链接寄存器<ol><li><code>jalr x1, 100(x5)</code></li></ol></li><li><code>jal Lable</code> => <code>jal ra, Lable</code> 调用函数</li></ol><h3 id=一段函数调用转换为汇编>一段函数调用转换为汇编<a hidden class=anchor aria-hidden=true href=#一段函数调用转换为汇编>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>sum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>retrun</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code class=language-risc-v data-lang=risc-v>1000 mv a0, s0              # x = a
1004 mv a1, s1              # y= b
1008 addi ra, zero, 1016    # 1016 is sum function
1012 j                      # jump to sum
1016 ... 
...
2000 sum: add a0, a0, a1
2004 jr ra
</code></pre><p>1008 ~ 1012 可以使用 <code>jal sum</code> 来替代、</p><h3 id=调用函数的基本步骤>调用函数的基本步骤<a hidden class=anchor aria-hidden=true href=#调用函数的基本步骤>¶</a></h3><ol><li>把需要的参数放到方法可以访问的地方（寄存器）</li><li>转移控制权给函数,使用(<code>jal</code>)<ol><li>保持地址，并跳转到函数的地址</li></ol></li><li>获取函数执行所需的(local)存储资源</li><li>执行预期的函数</li><li>将返回值放在调用代码可以访问的地方，并恢复我们使用到的寄存器，释放本地存储</li><li>将控制器返回给主处理器（<code>ret</code>), 使用存储在寄存器中的地址，返回到调用它的地方</li></ol><h3 id=方法调用示例>方法调用示例<a hidden class=anchor aria-hidden=true href=#方法调用示例>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>leaf</span><span class=p>(</span><span class=kt>int</span> <span class=n>g</span><span class=p>,</span> <span class=kt>int</span> <span class=n>h</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>f</span> <span class=o>=</span> <span class=p>(</span><span class=n>g</span> <span class=o>+</span> <span class=n>h</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>retrun</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>g,h,i,j in a0,a1,a2,a3</li><li>f in s0</li><li>temp is s1</li></ol><pre tabindex=0><code class=language-risc-v data-lang=risc-v>leaf:
	# prologue start
	addi sp, sp, -8   # 腾出 8byte 来存放的2个整数
	sw s1, 4(sp)      # 保存 s1, s0 到 sp 中
	sw s0, 0(sp)
	# prologue end
	add s0, a0, a1    # f = g + h
	add s1, a2, a3    # temp = i + j
	sub a0, s0, s1    # a0 = （g + h) - (i + j) 

	# epilogue
	lw s0, 0(sp)      # 恢复 s1, s0
	lw s1, 4(sp)    
	addi sp, sp 8 

	jr ra
</code></pre><h2 id=sp>sp<a hidden class=anchor aria-hidden=true href=#sp>¶</a></h2><div class="tip custom-block"><p class=custom-block-title>TIP</p><p><p>sp 是栈指针，从内存空间 的最顶部开始向下增长，在 RISC-V 中使用 x2 这个寄存器。</p><ol><li>push 是减少 sp 的指针地址</li><li>pop 是增加</li></ol></p></div><p>每个函数都有一组存放在栈上的数据，它们是<strong>栈帧</strong>（stack frame ），栈帧通常包含：</p><ol><li>返回地址</li><li>参数</li><li>使用的局部变量的空间</li></ol><h2 id=嵌套函数调用>嵌套函数调用<a hidden class=anchor aria-hidden=true href=#嵌套函数调用>¶</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sumSquare</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span><span class=kt>int</span> <span class=n>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>mult</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 ra 中有一个 sumSquare 想要跳回的值，但是这个值会被调用 mult 覆盖。</p><ol><li>caller: 调用函数的人</li><li>calle： 被调用的函数</li><li>当被调用者从执行中返回时，调用者需要知道哪些寄存器可能发生了变化，哪些寄存器被保证是不变的。</li><li>寄存器规定： 即哪些寄存器在程序调用(<code>jal</code>) 后将被取消缓存 ，哪些可以被改变。<ol><li>即有一些寄存器是易失的(temp),一些是要保存的（<strong>调用者需要恢复它们原来的值</strong>）。</li><li>这优化了每次进入栈帧的寄存器的数量</li></ol></li><li>分类:<ol><li>跨函数调用保留:<ol><li>sp, gp, tp</li><li>s0 - s11 (s0 is also fp)</li></ol></li><li>不保留:<ol><li>参数寄存器以及返回寄存器： a0 - a7, ra</li><li>temp 寄存器: t0 - t6</li></ol></li></ol></li></ol><p>上面代码的 RISC-V</p><p>x in a1, y in a1</p><pre tabindex=0><code class=language-risc-v data-lang=risc-v>sumSquare:
	addi sp, sp -8
	sw ra, 4(sp)             // save retrun address to sp
	sw a1, 0(sp)             // save s1 to y
	mv a1, a0                // y = x =&gt; mult(x,x)
	jal mult                 // call mult
	lw a1, 0(sp)             // get y from sp
	add a0, a0, a1           // mult() + y
	lw ra, 4(sp)             // get retrun address from sp
	addi sp, sp, 8
	jr ra
	
</code></pre><h2 id=risc-v-寄存器名称>RISC-V 寄存器名称<a hidden class=anchor aria-hidden=true href=#risc-v-寄存器名称>¶</a></h2><p><figure id=a-/images/Pasted%20image%2020221213192858.png class=align-center><img src=/images/Pasted%20image%2020221213192858.png alt></figure></p></div></article></main><footer class=footer><span>Copyright &nbsp;<a href=https://github.com/fzdwx target=_blank rel=noopener>fzdwx</a>
since 2022</span></span>
<span><a target=_blank href=https://github.com/fzdwx/fzdwx.github.io/issues>欢迎交流</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script>
<script data-no-instant>InstantClick.init()</script><script src=https://unpkg.com/lucide@latest></script>
<script>lucide.createIcons()</script></body></html>