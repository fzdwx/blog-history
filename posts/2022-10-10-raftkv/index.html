<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Raft Kv | fzdwx</title><meta name=keywords content="mit6.824"><meta name=description content="Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。在本实验中我们将实现Raft(一 种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。然后，您将在多个复制的状态机上进行shard来提高性能。
复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。挑战在于failures 可能导致副本存在不同的数据。
Raft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信，那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。
在本 lab 中，你将把Raft实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command，也可以叫log entries。这些entries 通过索引来进行编号。具有给定索引的log entry将被提交，此时，您的Raft应该将这个条log发送到更大的服务上执行。
你应该遵循 extended Raft paper 中设计，特别是图 2.你将实现论文宏的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。你将不会实现集群成员的变化(Section 6)。
你可能会发现这个 指南 很有用，还有这个关于 concurrency 的 锁 和 结构 的建议，如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication 和 Bolosky et al 。
请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。你可以参考 指导页 和这篇关于有效打印声明的 博文 。
我们还提供了 Raft 交互图 ，可以帮助阐明 Raft 代码如何与上层(使用者?)交互。
The code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在raft.go的注释中找到更多细节。
TIP raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf."><meta name=author content="fzdwx"><link rel=canonical href=https://fzdwx.github.io/posts/2022-10-10-raftkv/><link crossorigin=anonymous href=/assets/css/stylesheet.min.dc12cedb477e2452c9ee4c85b139048e3e42c4e6d5e17d2cf973e2d4dc9af362.css integrity="sha256-3BLO20d+JFLJ7kyFsTkEjj5CxObV4X0s+XPi1Nya82I=" rel="preload stylesheet" as=style><link rel=icon href=https://fzdwx.github.io/favicon.ico><link rel=apple-touch-icon href=https://fzdwx.github.io/apple-touch-icon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-DGKZ9K6GHW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DGKZ9K6GHW",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Raft Kv | fzdwx"><meta name=twitter:description content="Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。在本实验中我们将实现Raft(一 种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。然后，您将在多个复制的状态机上进行shard来提高性能。
复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。挑战在于failures 可能导致副本存在不同的数据。
Raft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信，那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。
在本 lab 中，你将把Raft实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command，也可以叫log entries。这些entries 通过索引来进行编号。具有给定索引的log entry将被提交，此时，您的Raft应该将这个条log发送到更大的服务上执行。
你应该遵循 extended Raft paper 中设计，特别是图 2.你将实现论文宏的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。你将不会实现集群成员的变化(Section 6)。
你可能会发现这个 指南 很有用，还有这个关于 concurrency 的 锁 和 结构 的建议，如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication 和 Bolosky et al 。
请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。你可以参考 指导页 和这篇关于有效打印声明的 博文 。
我们还提供了 Raft 交互图 ，可以帮助阐明 Raft 代码如何与上层(使用者?)交互。
The code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在raft.go的注释中找到更多细节。
TIP raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf."><meta property="og:title" content="Raft Kv | fzdwx"><meta property="og:description" content="Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。在本实验中我们将实现Raft(一 种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。然后，您将在多个复制的状态机上进行shard来提高性能。
复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。挑战在于failures 可能导致副本存在不同的数据。
Raft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信，那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。
在本 lab 中，你将把Raft实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command，也可以叫log entries。这些entries 通过索引来进行编号。具有给定索引的log entry将被提交，此时，您的Raft应该将这个条log发送到更大的服务上执行。
你应该遵循 extended Raft paper 中设计，特别是图 2.你将实现论文宏的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。你将不会实现集群成员的变化(Section 6)。
你可能会发现这个 指南 很有用，还有这个关于 concurrency 的 锁 和 结构 的建议，如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication 和 Bolosky et al 。
请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。你可以参考 指导页 和这篇关于有效打印声明的 博文 。
我们还提供了 Raft 交互图 ，可以帮助阐明 Raft 代码如何与上层(使用者?)交互。
The code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在raft.go的注释中找到更多细节。
TIP raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf."><meta property="og:type" content="article"><meta property="og:url" content="https://fzdwx.github.io/posts/2022-10-10-raftkv/"><meta property="og:image" content="https://avatars.githubusercontent.com/u/65269574?v=4"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-10T22:26:55+08:00"><meta property="article:modified_time" content="2022-10-10T22:26:55+08:00"><meta property="og:site_name" content="fzdwx"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fzdwx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Raft Kv","item":"https://fzdwx.github.io/posts/2022-10-10-raftkv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Raft Kv | fzdwx","name":"Raft Kv","description":"Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。在本实验中我们将实现Raft(一 种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。然后，您将在多个复制的状态机上进行shard来提高性能。\n复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。挑战在于failures 可能导致副本存在不同的数据。\nRaft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信，那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。\n在本 lab 中，你将把Raft实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command，也可以叫log entries。这些entries 通过索引来进行编号。具有给定索引的log entry将被提交，此时，您的Raft应该将这个条log发送到更大的服务上执行。\n你应该遵循 extended Raft paper 中设计，特别是图 2.你将实现论文宏的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。你将不会实现集群成员的变化(Section 6)。\n你可能会发现这个 指南 很有用，还有这个关于 concurrency 的 锁 和 结构 的建议，如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication 和 Bolosky et al 。\n请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。你可以参考 指导页 和这篇关于有效打印声明的 博文 。\n我们还提供了 Raft 交互图 ，可以帮助阐明 Raft 代码如何与上层(使用者?)交互。\nThe code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在raft.go的注释中找到更多细节。\nTIP raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf.","keywords":["mit6.824"],"wordCount":"340","inLanguage":"en","datePublished":"2022-10-10T22:26:55+08:00","dateModified":"2022-10-10T22:26:55+08:00","author":{"@type":"Person","name":"fzdwx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fzdwx.github.io/posts/2022-10-10-raftkv/"},"publisher":{"@type":"Organization","name":"fzdwx","logo":{"@type":"ImageObject","url":"https://fzdwx.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark"),document.body.classList.add("light");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches?document.body.classList.add("dark"):document.body.classList.add("light")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><script src=https://cdn.jsdelivr.net/npm/lucide@0.91.0/dist/cjs/lucide.min.js></script><header class=header><nav class=nav><div class=logo><a href=https://fzdwx.github.io/ accesskey=h title="fzdwx (Alt + H)">fzdwx</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://fzdwx.github.io/archives/ title=Archives>Archives</a></li><li><a href=https://fzdwx.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://fzdwx.github.io/links/ title=Links>Links</a></li><li><a href=https://fzdwx.github.io/search/ title=🔍>🔍</a></li><li><a href=https://fzdwx.github.io/startpage/ title=🧬>🧬</a></li></ul></nav></header><div class=padding-header></div><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fzdwx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fzdwx.github.io/posts/>Posts</a></div><h1 class=post-title>Raft Kv</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>&nbsp;2022-10-10</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://fzdwx.github.io/tags/mit6.824/>mit6.824</a></span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>340 words</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>2 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#the-code aria-label="The code">The code</a><ul><li><a href=#makepeers-labrpcclientend-me-intpersister-persister-applych-chan-applymsg aria-label="Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg)">Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg)</a></li><li><a href=#startcommand-interface-int-int-bool aria-label="Start(command interface{}) (int, int, bool)">Start(command interface{}) (int, int, bool)</a></li></ul></li><li><a href=#2a aria-label=2A>2A</a></li><li><a href=#links aria-label=Links>Links</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>¶</a></h2><p>这是一系列实验中的第一个，我们将构建一个<code>fault-tolerant key/value storage system</code>。在本实验中我们将实现<code>Raft</code>(一
种复制的状态机协议)。在下一个实验中，我们将在<code>Raft</code>上构建一个<code>key/value service</code>。然后，您将在多个复制的状态机上进行<code>shard</code>来提高性能。</p><p>复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现<code>fault tolerance</code>。即使有一些服务器出现故障(崩溃或网络断开和抖动)<code>replication</code>也允许它们继续运行。挑战在于<strong>failures 可能导致副本存在不同的数据</strong>。</p><p><code>Raft</code>将客户端的请求组织成一个序列，被成为<code>log</code>，并且确保所有<code>replica servers</code>看到相同的<code>log</code>。每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。由于<strong>所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态</strong>。如果一个服务器失败了但是后来又恢复来，<code>Raft</code>会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信，那么<code>Raft</code>将继续运行。如果没有到达这个数量，那么<code>Raft</code>将会停止运行，直到到达这个数量才会重新开始。</p><p>在本 lab 中，你将把<code>Raft</code>实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。一组<code>Raft</code>实例通过<code>RPC</code>来维护<code>replicated logs</code>。你的<code>Raft</code>实例将支持一连串不确定编号(数量?)的<code>command</code>，也可以叫<code>log entries</code>。这些<code>entries</code>
通过索引来进行编号。具有给定索引的<code>log entry</code>将被提交，此时，您的<code>Raft</code>应该将这个条<code>log</code>发送到更大的服务上执行。</p><p>你应该遵循 <a href=https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf target=_blank rel=noopener>extended Raft paper</a>
中设计，特别是图 2.你将实现论文宏的大部分内容，包括<strong>保存持久化状态</strong>和节<strong>点故障自动重启后读取状态</strong>。你将不会实现集群成员的变化(Section 6)。</p><p>你可能会发现这个 <a href=https://thesquareplanet.com/blog/students-guide-to-raft/ target=_blank rel=noopener>指南</a>
很有用，还有这个关于 concurrency 的 <a href=https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt target=_blank rel=noopener>锁</a>
和 <a href=https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt target=_blank rel=noopener>结构</a>
的建议，如果需要更广泛的视角，可以看看<code>Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication</code> 和 <a href=https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf target=_blank rel=noopener>Bolosky et al</a>
。</p><p>请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。你可以参考 <a href=https://pdos.csail.mit.edu/6.824/labs/guidance.html target=_blank rel=noopener>指导页</a>
和这篇关于有效打印声明的 <a href=https://blog.josejg.com/debugging-pretty/ target=_blank rel=noopener>博文</a>
。</p><p>我们还提供了 <a href=https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf target=_blank rel=noopener>Raft 交互图</a>
，可以帮助阐明 <code>Raft</code> 代码如何与上层(使用者?)交互。</p><h2 id=the-code>The code<a hidden class=anchor aria-hidden=true href=#the-code>¶</a></h2><p>通过向<code>raft/raft.go</code>添加代码来实现<code>Raft</code>。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在<code>raft.go</code>的注释中找到更多细节。</p><div class="tip custom-block"><p class=custom-block-title>TIP</p><p>raft 实例只能通过 rpc 进行通信且必须使用<code>labrpc</code>这个包(例如不能使用文件以及共享变量)。</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// create a new Raft server instance:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>rf</span> <span class=o>:=</span> <span class=nf>Make</span><span class=p>(</span><span class=nx>peers</span><span class=p>,</span> <span class=nx>me</span><span class=p>,</span> <span class=nx>persister</span><span class=p>,</span> <span class=nx>applyCh</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// start agreement on a new log entry:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>rf</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>command</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>index</span><span class=p>,</span> <span class=nx>term</span><span class=p>,</span> <span class=nx>isleader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ask a Raft for its current term, and whether it thinks it is leader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>rf</span><span class=p>.</span><span class=nf>GetState</span><span class=p>()</span> <span class=p>(</span><span class=nx>term</span><span class=p>,</span> <span class=nx>isLeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// each time a new entry is committed to the log, each Raft peer
</span></span></span><span class=line><span class=cl><span class=c1>// should send an ApplyMsg to the service (or tester).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ApplyMsg</span>
</span></span></code></pre></div><h3 id=makepeers-labrpcclientend-me-intpersister-persister-applych-chan-applymsg>Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg)<a hidden class=anchor aria-hidden=true href=#makepeers-labrpcclientend-me-intpersister-persister-applych-chan-applymsg>¶</a></h3><p>用于创建 raft server。</p><ol><li>所有的 raft server 的端口都在<code>peers[]</code>存放(包括当前的服务)，当前服务的端口可以通过<code>peers[me]</code>来获取。</li><li>所有的服务的<code>perrs[]</code>数组都具有相同的顺序。</li><li><code>presister</code>是一个用来存放<code>persistent state</code>的地方，并且在初始的时候会保存最具的状态，如果有。</li><li><code>applyCh</code>是 service 或 tester 发送消息给 raft 的通道。<code>Make()</code>必须快速返回，所以它应该为一些长时间运行的任务启动<code>goruntines</code>。</li></ol><h3 id=startcommand-interface-int-int-bool>Start(command interface{}) (int, int, bool)<a hidden class=anchor aria-hidden=true href=#startcommand-interface-int-int-bool>¶</a></h3><p>使用 rafr 的服务(e.g a k/v server)希望就下一个要追加到 raft 日志的命令达成一致(就是追加到 raft 日志的下一条命令是相同的？)。如果当前 raft server 不是 leader，则返回 false。否则启动协议并<strong>立即返回</strong>，无需等待日志追加完成。<strong>所以无法保证次命令将一定会被提交到 raft 日志中，因为 leader 可能会失败或者在选举中失败</strong>。即使 raft 实例被 kill，这个函数也应该<code>retrun gracefully</code>。</p><p>第一个返回值是该命令出现的索引，如果它曾经被提交的话。第二个返回值是当前的术语(???)。如果这个服务器认为它是领导者，第三个返回值是真。</p><p>每个新提交的<code>raft log entity</code>都应该发送一个<code>AppliMsg</code>到<code>Make()</code>的<code>applyCh</code>中。</p><h2 id=2a>2A<a hidden class=anchor aria-hidden=true href=#2a>¶</a></h2><p>实现 Raft leader election 以及 heartbeats(<code>AppendEntries</code> RPCs 没有<code>log entries</code>.空的的意思?)。</p><p>2A 的目标是: 选出一个 leader，如果没有失败，它仍然是 leader，如果 old leader 失败或者与 old leader 之间的数据包发生丢失则由 new leader 接管。</p><div class="tip custom-block"><p class=custom-block-title>TIP</p><p>这个失败是 leader 出现故障的意思？就是说只要它没出现运行故障或者网络问题就永远是 leader？</p></div><p>要点:</p><ol><li>通过运行<code>go test -run 2A</code>来进行测试你的实现。</li><li>按照论文的图 2，主要关系发送和接收<code>RequestVote RPCs</code>，与<code>the Rules for Servers that relate to elections</code>以及<code>the State related to leader election</code>。</li><li>添加图 2 中与 leader election 相关的状态到<code>Raft</code>这个结构体中，且还需要定义一个结构来保存每个日志的信息。</li><li>实现<code>RequestVote()</code>，这样 raft 服务们就能互相投票了。添加<code>RequestVOteArgs</code>和<code>RequestVoteReply</code>者两个结构体。修改<code>Make()</code>，创建一个 goroutine，用于检查心跳消息，如果有一段时间没有收到 peer 的消息时将发送<code>RequestVote</code>RPCs 来定期发起领导者选举。这样，如果有 leader 了，peer 将知道谁是 leader，或者自己成为 leader。</li><li>实现心跳，需要定义一个<code>AppendEntries</code>RPC 结构(尽管你可能还不需要所有参数)，并且让 leader 定期发送它。编写一个<code>AppendEntries</code>RPC 的 handle method，用于重置选举超时，这样当有一个人已经当选时，其他服务器不会又成为 leader。</li><li>确保不同 peer 的选举超时不在同一时间发生，否则所有 peer 将只为自己投票，这样就没有人会成为 leader 了。</li><li>在测试是时，leader 每秒发送的 RPC 请求不能超过 10 次。</li><li>// he tester requires your Raft to elect a new leader within five</li></ol><h2 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>¶</a></h2><ol><li>项目地址: <a href=https://pdos.csail.mit.edu/6.824/labs/lab-raft.html target=_blank rel=noopener>https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></li><li>GFS 相关资料: <a href=https://fzdwx.github.io/posts/2022-10-07-gfs/#links target=_blank rel=noopener>https://fzdwx.github.io/posts/2022-10-07-gfs/#links</a></li><li>Raft paper: <a href=https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf target=_blank rel=noopener>https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></li><li>Diagram of Raft interactions： <a href=https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf target=_blank rel=noopener>https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf</a></li><li>Students guid to Raft: <a href=https://thesquareplanet.com/blog/students-guide-to-raft/ target=_blank rel=noopener>https://thesquareplanet.com/blog/students-guide-to-raft/</a></li><li>Raft locking: <a href=https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt target=_blank rel=noopener>https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt</a></li><li>Raft structure: <a href=https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt target=_blank rel=noopener>https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt</a></li><li>Paxos Replicated State Machines as the Basis of a High-Performance Data Store <a href=https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf target=_blank rel=noopener>https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf</a></li></ol></div><footer class=post-footer><nav class=paginav><a class=prev href=https://fzdwx.github.io/posts/2022-10-10-code-alias/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Code:alias</span></a>
<a class=next href=https://fzdwx.github.io/posts/2022-10-09-mario-nes/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>在Abstract Machine上玩超级马里奥</span></a></nav></footer></article></main><footer class=footer><span>Copyright <a href=https://github.com/fzdwx target=_blank rel=noopener>fzdwx</a>
since 2022</span></span>
<span><a target=_blank href=https://github.com/fzdwx/fzdwx.github.io/issues>欢迎交流</a></span></footer><script>lucide.createIcons()</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script><script src=/js/instantclick.min.js data-no-instant></script>
<script data-no-instant>InstantClick.init()</script></body></html>