<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>os on fzdwx</title>
    <link>https://fzdwx.github.io/tags/os/</link>
    <description>Recent content in os on fzdwx</description>
    <image>
      <url>https://fzdwx.github.io/images/party_parrot.gif</url>
      <link>https://fzdwx.github.io/images/party_parrot.gif</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx) since 2022</copyright>
    <lastBuildDate>Sun, 08 Jan 2023 08:44:38 +0800</lastBuildDate><atom:link href="https://fzdwx.github.io/tags/os/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统的分时多任务</title>
      <link>https://fzdwx.github.io/posts/2023-01-08-os-multi-programs/</link>
      <pubDate>Sun, 08 Jan 2023 08:44:38 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2023-01-08-os-multi-programs/</guid>
      <description>记录如何实现一个简单的支持运行多个程序的操作系统，比如如何暂停和恢复应用程序(换栈)，以及如何实现一个抢占式操作系统。</description>
      <content:encoded><![CDATA[




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>提高系统的性能和效率是操作系统的核心目标之一：</p>
<ol>
<li>通过提前加载应用程序到内存，减少应用程序切换开销</li>
<li>通过协作机制支持程序主动放弃处理器，提高系统执行效率</li>
<li>通过抢占机制支持程序被动放弃处理器，保证不同程序对处理器资源使用的公平性，也进一步提高了应用对 I/O 事件的响应效率</li>
</ol>
 </p>
</div>








<p>通过特权级机制我们可以轻松实现一个顺序执行程序的操作系统：</p>
<ol>
<li>在硬件级特权隔离机制的帮助之下，运行在更高特权级的操作系统不会受到有意或者无意出错的应用的影响</li>
<li>在硬件异常触发机制的帮助之下，可以全方位监控运行在用户态低特权级的应用执行</li>
<li>一旦应用越过了特权级界限或主动申请获得操作系统的服务，就会触发 Trap 进入到内核栈中进行处理</li>
<li>无论原因是应用出错或应用申请更高级别的权限，操作系统就会开始运行下一个程序</li>
</ol>
<p>可以看到这个操作系统的特是: <strong>在内存中同一时间最多只需要驻留一个应用</strong>。因为只要当一个应用结束运行或运行出错时，操作系统才会加载另一个应用程序到该内存 。</p>
<p>而一次只能运行一个程序是显然不符合我们对于操作系统的期望的，所以人们就考虑开始在内存中尽量同时驻留多个应用，提高处理器的利用率。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        多道程序
        
    </p>
    <p> 一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序 </p>
</div>








<p><figure id="a-/images/Pasted%20image%2020230108192734.png" class="align-center">
    <img src="/images/Pasted%20image%2020230108192734.png" alt="多道程序操作系统的结构"  />
    
    <figcaption>
       多道程序操作系统的结构
    </figcaption>
    
</figure></p>
<ol>
<li>首先 Qemu 把多个应用程序和 MultiprogOS 的 image 镜像加载到内存中</li>
<li>RustSBI(bootloader)完成基本的硬件初始化后，跳转到 MultiprogOS 的起始位置</li>
<li>MultiprogOS 首先进行正常运行前的初始化工作，建立栈空间和清空 bss 段</li>
<li>然后通过 AppManager 从 app 列表中把所有 app 都加载到内存中，并按指定顺序在用户态一个个的执行</li>
</ol>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        协作式操作系统
        
    </p>
    <p> <p>在<strong>多道程序</strong>运行方式下，一个程序如果不让出处理器，其他程序是无法执行的。如果一个应用由于
I/O 操作让处理器空闲或让处理器忙等，那其他需要处理器资源进行计算的应用还是没法使用空闲的处理器。</p>
<p>所以就相当让应用在执行 I/O 操作或空闲时，可以主动 <strong>释放处理器</strong>，让其他应用继续执行。由操作系统提供这样的服务(syscall)给应用程序调用,这种操作系统就是支持 多道程序 或 协作式多任务 的<strong>协作式操作系统</strong></p>
 </p>
</div>








<p><figure id="a-/images/Pasted%20image%2020230108193817.png" class="align-center">
    <img src="/images/Pasted%20image%2020230108193817.png" alt="协作式操作系统"  />
    
    <figcaption>
       协作式操作系统
    </figcaption>
    
</figure></p>
<ol>
<li>把 Appmanager 拆分为负责加载应用的 Loader 和管理应用运行过程的 TaskManger</li>
<li>Taskmanager 通过  task 任务控制块来管理应用程序的执行过程，支持应用程序主动放弃 CPU 并切换到另一个应用继续执行</li>
<li>应用程序在运行时有自己所在的内存空间和栈，确保被切换时相关信息不会被其他应用破坏</li>
<li>如果当前应用程序正在运行，则该应用对应的任务处于 Running 状态</li>
<li>如果该应用主动放弃处理器，则切换到 Ready 状态</li>
<li>操作系统进行任务切换时，需要把暂停任务的上下文(即任务用到的通用寄存器)保存起来</li>
<li>把要继续执行的任务的上下文恢复为暂停前的内容</li>
</ol>
<h2 id="抢占式操作系统">抢占式操作系统</h2>
<p>由于应用程序员在编写程序时，无法做到在程序合适的位置放置 <strong>放弃处理器的系统调用请求</strong>，这样系统的整体利用率还是无法提高。</p>
<p>所以还需要有一种机制能强制打断应用程序的执行，来提高系统的利用率。在计算机体系的硬件设计中，外设可以通过硬件中断机制来与处理器进行 I/O 交互操作。这种打断机制可以随时打断应用程序的执行，并让操作系统完成对外设的 I/O 响应。</p>
<p>而操作系统可以进一步用某种固定时长为时间间隔的外设中断(比如时钟中断)来强制打断一个程序的执行，这样一个程序只能运行一段时间(可以简称为一个<strong>时间片</strong>, time slice)就一定会让出处理器，且操作系统可以在处理外设的 I/O 响应后，让不同的应用程序分时占用处理器执行，并可通过统计程序占用处理器的总执行时间来评估程序对处理器资源的消耗。这种运行方式就是<strong>分时共享(time sharing)</strong> 或 <strong>抢占式多任务(multitasking)</strong>,也可以合称为<strong>分时多任务</strong>。</p>
<p>我们可以把:</p>
<ul>
<li>一个程序一次完整执行过程称为一次<strong>任务</strong>(task)</li>
<li>一个程序在一个时间片上占用处理器执行的过程称为一个<strong>任务片</strong>（task slice)</li>
</ul>
<p>操作系统对不同程序的执行过程中的任务片进行调度和管理，即通过平衡各个程序在整个时间段上的任务片数量就能达到一定程序的系统公平和高效的系统效率。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 在一个包含多个时间片的时间段上，会有属于不同程序的多个任务片在轮流占用处理器执行，这样的系统就是支持分时多任务或抢占式多任务的抢占式操作系统。 </p>
</div>








<p><figure id="a-/images/Pasted%20image%2020230108201513.png" class="align-center">
    <img src="/images/Pasted%20image%2020230108201513.png" alt="分时多任务操作系统"  />
    
    <figcaption>
       分时多任务操作系统
    </figcaption>
    
</figure></p>
<ol>
<li>改进 Trap Handle，支持时钟中断，从而可以抢占应用的执行</li>
<li>改进 TaskManger，提供任务调度功能，可以在收到时钟中断后统计任务的使用时间片，如果任务的时间片用完后，则切换任务</li>
</ol>
<h2 id="多道程序的放置与加载">多道程序的放置与加载</h2>
<p>每个应用都按照它的编号被分别放置并加载到内存中的不同位置，因为是一次性全部加载的，所以在切换到另一个应用执行时会很快，不需要清空前一个应用然后在加载当前应用的开销。</p>
<h3 id="多道程序放置">多道程序放置</h3>
<ol>
<li>调整每个用户应用程序构建时的链接脚本<code>linker.ld</code>中的起始地址<code>BASE_ADDRESS</code>,这个地址就是应用被内核加载到内存中的起始地址，所以每个应用也知道自己会被加载到某个地址运行</li>
<li>比如说第一个应用的地址范围是<code>BASE_ADDRESS</code> ～ <code>BASE_ADDRESS</code>+<code>APP_LIMIT</code>,第二个应用的地址范围是<code>BASE_ADDRESS</code>+<code>APP_LIMIT</code>~<code>BASE_ADDRESS</code>+2 * <code>APP_LIMIT</code>。</li>
<li>可以看出这就是另一种形式的硬编码，与每次复制应用程序到<code>BASE_ADDRESS</code>而言没什么区别</li>
<li>这么做的原因是因为操作系统的能力还比较弱，目前应用程序的编址方式是基于绝对位置的，并没做到与位置无关，内核也没有提供相应的地址重定位机制</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="n">base_address</span> <span class="o">=</span> <span class="mh">0x80400000</span>  
</span></span><span class="line"><span class="cl"><span class="n">step</span> <span class="o">=</span> <span class="mh">0x20000</span>  
</span></span><span class="line"><span class="cl"><span class="n">linker</span> <span class="o">=</span> <span class="s1">&#39;src/linker.ld&#39;</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="n">app_id</span> <span class="o">=</span> <span class="mi">0</span>  
</span></span><span class="line"><span class="cl"><span class="n">apps</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;src/bin&#39;</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="n">apps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">apps</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="p">[:</span><span class="n">app</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)]</span>  
</span></span><span class="line"><span class="cl">    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>  
</span></span><span class="line"><span class="cl">    <span class="n">lines_before</span> <span class="o">=</span> <span class="p">[]</span>  
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">linker</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>  
</span></span><span class="line"><span class="cl">            <span class="n">lines_before</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="n">替换初始的base_address</span> <span class="n">到每个应用具体的内存地址</span>
</span></span><span class="line"><span class="cl">            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">base_address</span><span class="p">),</span> <span class="nb">hex</span><span class="p">(</span><span class="n">base_address</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">app_id</span><span class="p">))</span>  
</span></span><span class="line"><span class="cl">            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">linker</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">编译应用程序</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;cargo build --bin </span><span class="si">%s</span><span class="s1"> --release&#39;</span> <span class="o">%</span> <span class="n">app</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[build.py] application </span><span class="si">%s</span><span class="s1"> start with address </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">base_address</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">app_id</span><span class="p">)))</span>  
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">还原到初始的base_address</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">linker</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines_before</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="n">app_id</span> <span class="o">=</span> <span class="n">app_id</span> <span class="o">+</span> <span class="mi">1</span>
</span></span></code></pre></div><h3 id="多道程序的加载">多道程序的加载</h3>
<p>前面一个操作系统的所有应用都是使用同一个固定的加载物理地址，所以内存中最多只能驻留一个应用，只要当它运行完毕或运行出错时才由操作系统加载一个新的应用来替换它。</p>
<p>但是我们要实现所有的应用在内核初始化的时候就一起加载到内存中。为了防止覆盖，所以要加载到不同的物理地址上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Load nth user app at  
</span></span></span><span class="line"><span class="cl"><span class="sd">/// [APP_BASE_ADDRESS + n * APP_SIZE_LIMIT, APP_BASE_ADDRESS + (n+1) * APP_SIZE_LIMIT).  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">load_apps</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span> <span class="nf">_num_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_app_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_num_app</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">app_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">core</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">num_app_ptr</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">num_app</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// clear i-cache first  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">asm!</span><span class="p">(</span><span class="s">&#34;fence.i&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// load apps  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">num_app</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 计算方式同放置时一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">base_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_base_i</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// clear region  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="n">base_i</span><span class="o">..</span><span class="n">base_i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">APP_SIZE_LIMIT</span><span class="p">)</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">addr</span><span class="o">|</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">).</span><span class="n">write_volatile</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// load app from data section to memory  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">core</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">app_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">app_start</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">app_start</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">core</span>::<span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">base_i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dst</span><span class="p">.</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">src</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="na">.align</span> <span class="mi">3</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.data</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">_num_app</span>  
</span></span><span class="line"><span class="cl"><span class="no">_num_app</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="mi">4</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="no">app_0_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="no">app_1_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="no">app_2_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="no">app_3_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.quad</span> <span class="no">app_3_end</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.data</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_0_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_0_end</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_0_start</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.incbin</span> <span class="s">&#34;../user/target/riscv64gc-unknown-none-elf/release/00power_3.bin&#34;</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_0_end</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.data</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_1_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_1_end</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_1_start</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.incbin</span> <span class="s">&#34;../user/target/riscv64gc-unknown-none-elf/release/01power_5.bin&#34;</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_1_end</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.data</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_2_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_2_end</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_2_start</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.incbin</span> <span class="s">&#34;../user/target/riscv64gc-unknown-none-elf/release/02power_7.bin&#34;</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_2_end</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.data</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_3_start</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.global</span> <span class="no">app_3_end</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_3_start</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.incbin</span> <span class="s">&#34;../user/target/riscv64gc-unknown-none-elf/release/03sleep.bin&#34;</span>  
</span></span><span class="line"><span class="cl"><span class="no">app_3_end</span><span class="p">:</span>
</span></span></code></pre></div><h3 id="执行应用程序">执行应用程序</h3>
<p>当应用程序的初始化放置完成后，或者某个应用程序结束或出错时就要调用<code>run_next_app</code>运行下一个程序。</p>
<p>此时 CPU 是 S 模式，而要切换到 U 模式下运行。这一过程与&nbsp;<a href="/posts/2022-12-30-os-privilege/#%e6%89%a7%e8%a1%8c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">执行应用程序</a>
类似。不同的是操作系统知道每个应用程序预先加载在内存中的位置，这就需要设置应用程序返回不同 Trap 上下文(保存了 放置程序起始地址的<code>epc</code>寄存器内容)：</p>
<ol>
<li>跳转到应用程序(i)的入口点 entry<sub>i</sub></li>
<li>切换到用户栈 stack<sub>i</sub></li>
</ol>
<p>这样的一个支持把多个应用的代码和数据放置到内存中，并能够依次执行每个应用的操作系统就完成了，但是它的任务调度的灵活性还有很大改进空间。</p>
<h2 id="任务切换">任务切换</h2>
<p>上面这这个操作系统还是一个应用会一直占用 CPU 直到它结束或者出错。为了提高效率，我们需要介绍新的概率: <strong>任务</strong>、<strong>任务切换</strong>、<strong>任务上下文</strong>。</p>
<p>首先我们把应用程序在不同时间段的执行过程分为两类：</p>
<ol>
<li>占用处理器执行有效任务的计算阶段</li>
<li>不必占用处理器的等待阶段(比如等待 I/O)</li>
</ol>
<p>这些阶段就形成了一个&quot;暂停~运行&hellip;&ldquo;组合的控制流或执行历史。</p>
<h3 id="任务">任务</h3>
<p>如果操作系统能在某个应用程序处于等待阶段的时候，把处理器转给另外一个处于计算阶段的应用程序，那么只要转换的开销不大，那么处理器的执行效率就会大大提高。</p>
<p>这需要应用程序在运行途中能主动让出 CPU 的使用权，等到操作系统让它再次执行后，那它才能继续执行。</p>
<p>我们把</p>
<ol>
<li>应用程序的一次执行过程称为一个<strong>任务</strong></li>
<li>应用执行过程中的一个时间片段或空闲片段称为“<strong>计算任务片</strong>”或“<strong>空闲任务片</strong>”</li>
</ol>
<p>当应用程序的所有任务片都完成后，应用程序的一次任务也就完成了。从一个程序的任务切换到另外一个程序的任务称为“<strong>任务切换</strong>”，为了确保切换后的任务能正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。</p>
<p>一条控制流需要支持“暂停～继续”，就需要提供一种控制流切换的机制，而且需要保证程序执行的控制流被切换出去之前和切换回来之后，能够继续正确执行。这需要让程序执行的状态(上下文 context)，即<strong>在执行过程中同步变化额度资源(如寄存器，栈等)保持不变，或者变化在它的预期之内</strong>。不是所有的资源都需要保存，事实上只有那些对于程序接下来的正确执行仍然有用，且在它被切换出去的时候有被覆盖风险的那些资源才有被保持的价值。这些需要保存与恢复的资源称为<strong>任务上下文(task context)</strong>。</p>
<h3 id="不同类型的上下文与切换">不同类型的上下文与切换</h3>
<p>在控制流切换的过程中，我们需要结合硬件机制和软件来实现保存和恢复任务上下文。任务的一次切换涉及到被换出和即将被换入的两条控制流(两个应用的不同任务)。前面介绍的两种上下文保存/恢复的例子：</p>
<ol>
<li>RISC-V 中的函数调用，为了支持嵌套函数调用，不仅需要硬件平台提供的跳转指令，同时还需要保存和恢复&nbsp;<a href="/posts/2022-12-10-risc-v/#risc-v-%e5%af%84%e5%ad%98%e5%99%a8%e5%90%8d%e7%a7%b0">函数调用上下文</a>
(比如说返回地址—— ra 寄存器，比如说需要保存的寄存器—— s0~s10)。
<ol>
<li>在这个例子中，函数调用包含在普通控制流(与异常控制流相对)之类，且始终用一个固定的栈来保存执行的历史记录，因此函数调用并不涉及控制流的特权级切换。</li>
<li>但是我们依然可以看成调用者与被调用者两个执行过程的“切换”</li>
</ol>
</li>
<li>在前面的特权级的笔记中涉及到了某种异常（Trap）控制流，即两条控制流的特权级切换,需要保存和恢复&nbsp;<a href="/posts/2022-12-30-os-privilege/#%e7%89%b9%e6%9d%83%e7%ba%a7%e5%88%87%e6%8d%a2">系统调用(Trap)上下文</a>
。为了让内核能够完全掌控应用的执行，且不会被应用破坏整个系统，就必须利用硬件提供的特权级机制，让应用和内核运行在不同的特权级。</li>
</ol>
<p>应用程序与操作系统打交道的核心在于硬件提供的 Trap 机制，也就是在 U 运行的应用控制流和在 S 运行的 Trap 控制流(操作系统的陷入处理部分)之间的切换。Trap 控制流是 Trap 触发的一瞬间生成的，它几乎唯一的目标就是处理 Trap 并恢复到原应用控制流。Trap 控制流需要把 Trap 上下文(几乎所有的通用寄存器)保存在自己的内核栈上，可以回看&nbsp;<a href="/posts/2022-12-30-os-privilege/#trap-%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9a%84%e4%bf%9d%e5%ad%98%e4%b8%8e%e6%81%a2%e5%a4%8d">Trap 上下文的保存与恢复</a>
。</p>
<h2 id="任务切换的设计与实现">任务切换的设计与实现</h2>
<p>现在要介绍的是一种与 Trap 不同的异常控制流,它们都是描述两条控制流之间的切换，如果将它和 Trap 切换进行比较，会有如下异同:</p>
<ul>
<li>与 Trap 切换不同，它不涉及特权级切换</li>
<li>与 Trap 切换不同，它的一部分是由编译器帮忙完成的</li>
<li>与 Trap 切换相同，它对应用是透明的</li>
</ul>
<p>任务切换是来自两个不同应用在内核中的 Trap 控制流之间的切换。当一个应用 Trap 到 S 模式的操作系统内核中进一步处理(操作系统的 Trap 控制流)的时候，Trap 控制流会调用一个特殊的 <code>__switch</code> 函数：在 <code>__switch</code> 返回之后，将继续从调用该函数的位置继续向下执行，但是其中却隐藏者复杂的控制流切换过程：</p>
<ol>
<li>调用 <code>__switch</code> 之后直到它返回前，原 Trap 控制流 A 会被切换出去，CPU 会运行另一个应用在内核中的 Trap 控制流 B</li>
<li>然后在某个合适的时机，原 Trap 控制流 A 才会从某一条 Trap 控制流 C（很可能不是 B）切换回来继续执行并最终返回</li>
</ol>
<p><code>__switch</code>函数和一个普通的函数之间的核心差别就是它会<strong>换栈</strong>。</p>
<p><figure id="a-/images/Pasted%20image%2020230110104125.png" class="align-center">
    <img src="/images/Pasted%20image%2020230110104125.png" alt=""  />
    
</figure></p>
<p>当 Trap 控制流准备调用 <code>__switch</code> 函数使任务从运行状态进入暂停状态的时候，在调用之前，内核栈会保存应用执行状态的 Trap 上下文以及内核在对 Trap 处理过程中留下的调用栈信息。由于之后还需要恢复并继续执行，所以必须要保存 CPU 当前的某些寄存器(如下图第一阶段中的最下一部分)，这些就是<strong>任务上下文</strong>。这些任务上下文都被保存在 <code>TaskManager</code> 中，从内存布局来看就是 <code>.data</code> 段中。</p>
<p>对于当前正在执行的任务的 Trap 控制流，我们用一个名为 <code>current_task_cx_ptr</code> 的变量来保存放置当前任务上下文的地址；而用 <code>next_task_cx_ptr</code> 的变量来保存放置下一个要执行任务的上下文的地址。利用 C 语言的引用来描述的话就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">TaskContext</span> <span class="o">*</span><span class="n">current_task_cx_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">task_cx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">TaskContext</span> <span class="o">*</span><span class="n">next_task_cx_ptr</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">task_cx</span><span class="p">;</span>
</span></span></code></pre></div><p><figure id="a-/images/Pasted%20image%2020230110110143.png" class="align-center">
    <img src="/images/Pasted%20image%2020230110110143.png" alt="switch 换栈"  />
    
    <figcaption>
       switch 换栈
    </figcaption>
    
</figure></p>
<p>假设某次 <code>__switch</code> 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容：</p>
<ol>
<li>在 Trap 控制流 A 调用函数之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的(处于暂停状态)</li>
<li>A 在 A 任务上下文空间中保存 CPU 当前寄存器的快照</li>
<li>读取 <code>next_task_cx_ptr</code> 指向的 B 任务上下文,恢复寄存器后，就做到了一个函数跨两条控制流执行： <em>通过换栈实现了控制流的切换</em>
<ol>
<li>恢复 <code>ra</code></li>
<li>恢复<code>s0~s11</code></li>
<li>恢复 <code>sp</code></li>
</ol>
</li>
<li>上一步寄存器恢复完成后，可以看到通过恢复 <code>sp</code> 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。当 CPU 执行 <code>ret</code> 指令完成 <code>__switch</code> 函数返回后，任务 B 就可以从调用 <code>__switch</code> 的位置继续向下执行</li>
</ol>
<p>这时候任务 A 处于暂停状态，而任务 B 恢复了上下文并处于运行状态。</p>



<details class="details custom-block">
    <summary>
        <span> 
        
            __switch 的实现
        
        </span>
    </summary>
    <p>
        <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.altmacro</span>  
</span></span><span class="line"><span class="cl"><span class="no">.macro</span> <span class="no">SAVE_SN</span> <span class="no">n</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sd</span> <span class="no">s</span><span class="err">\</span><span class="no">n</span><span class="p">,</span> <span class="p">(</span><span class="err">\</span><span class="no">n</span><span class="err">+</span><span class="mi">2</span><span class="p">)*</span><span class="mi">8</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="no">.endm</span>  
</span></span><span class="line"><span class="cl"><span class="no">.macro</span> <span class="no">LOAD_SN</span> <span class="no">n</span>  
</span></span><span class="line"><span class="cl">    <span class="no">ld</span> <span class="no">s</span><span class="err">\</span><span class="no">n</span><span class="p">,</span> <span class="p">(</span><span class="err">\</span><span class="no">n</span><span class="err">+</span><span class="mi">2</span><span class="p">)*</span><span class="mi">8</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="no">.endm</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.section</span> <span class="no">.text</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.globl</span> <span class="no">__switch</span>  
</span></span><span class="line"><span class="cl"><span class="no">__switch</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 阶段 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># __switch(  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#     current_task_cx_ptr: *mut TaskContext,  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#     next_task_cx_ptr: *const TaskContext  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># )  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 阶段 2 保存 curr 寄存器 sp ra s0~s11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save kernel stack of current task  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># save ra &amp; s0~s11 of current execution  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">0</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">12</span>  
</span></span><span class="line"><span class="cl">        <span class="no">SAVE_SN</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span> <span class="err">+</span> <span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 阶段 3 恢复 next 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore ra &amp; s0~s11 of next execution  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">0</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">12</span>  
</span></span><span class="line"><span class="cl">        <span class="no">LOAD_SN</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span> <span class="err">+</span> <span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># restore kernel stack of next task  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 阶段 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ret</span>  
</span></span></code></pre></div>
    </p>
</details>










<ol>
<li>保存 <code>ra</code> 是记录 <code>__switch</code> 返回后跳转的位置(<code>ret</code>执行完毕后)</li>
<li><code>s0~s11</code> 是规定被调用者保存的寄存器</li>
</ol>
<p>对应的 TaskContext 的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TaskContext</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ra</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sp</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span>: <span class="p">[</span><span class="kt">usize</span><span class="p">;</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 在 rust 中调用 __switch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">global_asm!</span><span class="p">(</span><span class="fm">include_str!</span><span class="p">(</span><span class="s">&#34;switch.S&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="n">TaskContext</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">__switch</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">current_task_cx_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">TaskContext</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">next_task_cx_ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">TaskContext</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="多道程序与协作式调度">多道程序与协作式调度</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>任务相关概念的扩展:</p>
<ul>
<li>任务运行状态: 任务从开始到结束执行过程中所处的不同运行状态，比如:未初始化、准备执行、正在执行、已推出</li>
<li>任务控制块： 管理程序的执行过程的任务上下文，控制程序的执行与暂停</li>
<li>任务相关系统调用： 应用程序和操作系统直接的接口，用于程序主动暂停 <code>sys_yield</code> 和主动退出 <code>sys_exit</code></li>
</ul>
 </p>
</div>








<h3 id="多道程序背景与-yield-系统调用">多道程序背景与 yield 系统调用</h3>
<p>我们知道 CPU 的处理速度远快于外设的 I/O 的，只有当 I/O 响应之后 CPU 才能继续计算。那么这是如何实现的？</p>
<p>通常外设会提供一个可读的寄存器记录它目前的工作状态，于是 CPU 需要不断原地循环读取它直到它的结果显示设备已经将请求处理完毕了，才能继续执行（这就是 <strong>忙等</strong> 的含义）。</p>
<p>而如果经常让 CPU 忙等的话，效率肯定是不符合预期的。多道程序是如何优化呢？</p>
<ol>
<li>内核管理多个应用程序</li>
<li>如果 I/O 的时间很常，可以切换任务去处理其他应用</li>
<li>在某次切换回来时去读取设备寄存器，如果已经返回则继续执行</li>
<li>这样，只要同时存在的应用够多，就能在一定程度上隐藏 I/O 处理的延迟</li>
</ol>
<p>这种任务切换应该是应用程序主动调用 <code>sys_yield</code> 来实现的。
<figure id="a-/images/Pasted%20image%2020230110202921.png" class="align-center">
    <img src="/images/Pasted%20image%2020230110202921.png" alt="紫色是外设开始处理 I/O,蓝色和绿色的两个应用程序分别占用 CPU 的时间"  />
    
    <figcaption>
       紫色是外设开始处理 I/O,蓝色和绿色的两个应用程序分别占用 CPU 的时间
    </figcaption>
    
</figure></p>
<h3 id="任务控制块与任务运行状态">任务控制块与任务运行状态</h3>
<p>在引入了任务切换机制后，内核需要管理多个未完成的应用，而且我们不能对应用完成的顺序做任何假定。所以我们必须维护任务的运行状态:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">TaskStatus</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">UnInit</span><span class="p">,</span><span class="w"> </span><span class="c1">// 未初始化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="n">Ready</span><span class="p">,</span><span class="w">  </span><span class="c1">// 准备运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="n">Running</span><span class="p">,</span><span class="c1">// 正在运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="n">Exited</span><span class="p">,</span><span class="w"> </span><span class="c1">// 已退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>内核还需要一个保存应用的更多信息，将它们保存在 <strong>任务控制快</strong> 中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TskControlBlock</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">task_status</span>: <span class="nc">TaskStatus</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">pub</span><span class="w"> </span><span class="n">task_cx</span>:     <span class="nc">TaskContext</span><span class="p">,</span><span class="w"> </span><span class="c1">// 任务上下文，内有ra,sp,s0~s11等寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="任务管理器">任务管理器</h3>
<p>一个全局的管理器，包含了所有要执行的任务</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TaskManager</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">num_app</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="c1">// 任务管理器管理的应用数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">inner</span>: <span class="nc">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskManagerInner</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">TaskManagerInner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tasks</span>: <span class="p">[</span><span class="n">TaskControlBlock</span><span class="p">;</span><span class="w"> </span><span class="n">MAX_APP_NUM</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">current_task</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="c1">// 正在执行的应用编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>我们可重用并扩展之前初始化 <code>TaskManager</code> 的全局实例 <code>TASK_MANAGER</code> ：</p>
<ol>
<li>每个应用的上下文(<code>TaskContext</code>)的 <code>ra</code> 都默认是 <code>__restore</code></li>
<li><code>init_app_cx</code> 为每个应用的内核栈都构建一个 <code>TrapContext</code>，且设置 <code>sepc</code>( Trap 返回后继续执行的位置) 的值为每个 App 的入口</li>
</ol>



<details class="details custom-block">
    <summary>
        <span> 
        
            初始全局 TaskManger代码
        
        </span>
    </summary>
    <p>
        <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Global variable: TASK_MANAGER  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">TASK_MANAGER</span>: <span class="nc">TaskManager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">num_app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">TaskControlBlock</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">task_cx</span>: <span class="nc">TaskContext</span>::<span class="n">zero_init</span><span class="p">(),</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">task_status</span>: <span class="nc">TaskStatus</span>::<span class="n">UnInit</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w"> </span><span class="n">MAX_APP_NUM</span><span class="p">];</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">tasks</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">task</span><span class="p">.</span><span class="n">task_cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaskContext</span>::<span class="n">goto_restore</span><span class="p">(</span><span class="n">init_app_cx</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">task</span><span class="p">.</span><span class="n">task_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaskStatus</span>::<span class="n">Ready</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">TaskManager</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">num_app</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">inner</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">UPSafeCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">TaskManagerInner</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">tasks</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">current_task</span>: <span class="mi">0</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">})</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>
    </p>
</details>










<h3 id="sys_yield-和-sys_exit-的实现">sys_yield 和 sys_exit 的实现</h3>
<ol>
<li><code>sys_yield</code> 与 <code>sys_exit</code> 的第一步就是更改当前任务的状态
<ol>
<li><code>sys_yield</code> -&gt; Ready</li>
<li><code>sys_exit</code> -&gt; Exited</li>
</ol>
</li>
<li>第二步都是运行下一个任务
<ol>
<li><code>self.find_next_task()</code> 找到下一个状态处于 <code>Ready</code> 的应用 ID</li>
<li>更改为 <code>Running</code> 状态</li>
<li>更新 <code>current_task</code></li>
<li>根据 current 和 next 进行换栈，也就是调用 <code>__switch</code></li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Switch current `Running` task to the task we have found,    
</span></span></span><span class="line"><span class="cl"><span class="sd">/// or there is no `Ready` task and we can exit with all applications completed    
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">run_next_task</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">find_next_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">exclusive_access</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner</span><span class="p">.</span><span class="n">current_task</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">inner</span><span class="p">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">task_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaskStatus</span>::<span class="n">Running</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">inner</span><span class="p">.</span><span class="n">current_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">current_task_cx_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">inner</span><span class="p">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">task_cx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">TaskContext</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">next_task_cx_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inner</span><span class="p">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">task_cx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">TaskContext</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">drop</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// before this, we should drop local variables that must be dropped manually  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">next_task_cx_ptr</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// go back to user mode  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;All applications completed!&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">board</span>::<span class="n">QEMUExit</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">crate</span>::<span class="n">board</span>::<span class="n">QEMU_EXIT_HANDLE</span><span class="p">.</span><span class="n">exit_success</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><figure id="a-/images/Pasted%20image%2020230110211219.png" class="align-center">
    <img src="/images/Pasted%20image%2020230110211219.png" alt="应用的运行状态变化"  />
    
    <figcaption>
       应用的运行状态变化
    </figcaption>
    
</figure></p>
<h3 id="第一次进入用户态">第一次进入用户态</h3>
<ol>
<li>第一次运行应用程序，调用 <code>__switch</code> 函数是用一个默认的 TaskContext 与 <code>task.0</code> ,进行换栈</li>
<li>每个应用程序的 TaskContext 的 <code>ra</code>  都默认是 <code>__restore</code>, 且都压入了一个默认的 <code>TrapContext</code>,这个 <code>TrapContect</code> 的 <code>sepc</code> 设置的值为每个应用程序的入口。即：</li>
<li>第一次运行时，调用 <code>__switch</code>，换入 <code>task.0</code></li>
<li>这时候 <code>ra</code> 会被设置为 <code>__restore</code> 的地址</li>
<li>返回后进入 <code>__restore</code> 的处理流程</li>
<li>由于<code>sret</code> 会跳转到 <code>sepc</code> 的地址，即 <code>task.0</code> 的入口</li>
<li>在运行 <code>__restore</code> 的过程中，特权级会被切换到用户态</li>
</ol>
<p>这里也只是一个简单的协作式操作系统，需要每个应用显示的调用 <code>yeild</code> 才能共享 CPU。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统的特权级机制</title>
      <link>https://fzdwx.github.io/posts/2022-12-30-os-privilege/</link>
      <pubDate>Fri, 30 Dec 2022 13:54:36 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-30-os-privilege/</guid>
      <description>特权级是为了隔离操作系统中用户程序与操作系统的，主要是防止用户程序的错误不会导致操作系统的一种机制。</description>
      <content:encoded><![CDATA[<p>应用程序会不可避免的出现错误，如果一个程序出现错误会导致其他程序或操作系统都无法运行那就是不可接受的。</p>
<p>所以人们提出<em>特权级</em>（Privilege）这一保护计算机系统不受有意或无意出错的程序破坏的机制，它让应用程序运行在<strong>用户态</strong>
，而操作系统运行在<strong>内核态</strong>，并且实现用户态和内核态的隔离。</p>
<p><figure id="a-/images/Pasted%20image%2020221230141140.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230141140.png" alt="一个支持顺序执行多个应用程序的操作系统结构图"  />
    
    <figcaption>
       一个支持顺序执行多个应用程序的操作系统结构图
    </figcaption>
    
</figure></p>
<p>主要通过 RustSBI 完成基本的硬件初始化后，跳转到操作系统的起始位置，操作系统然后建立栈空间并情况 bss 段（置0），然后通过
AppManager 从 app 列表中一次加载各个 app 到指定的内存在用户态执行。app 在执行时，会通过系统调用的方式得到操作系统提供的功能，比如输出字符串。</p>
<h2 id="特权级的软硬件协同设计">特权级的软硬件协同设计</h2>
<p>实现特权级机制的根本原因是<strong>应用程运行的安全性不可充分信任</strong>
。所以，计算机科学家和工程师想到了一个方法：让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受到程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。</p>
<ul>
<li>应用程序不能随意访问地址空间</li>
<li>应用程序不能执行某些可能破坏计算机系统的指令</li>
</ul>
<p>同时为了应用程序能获得操作系统的服务——应用程序和操作系统还需要有交互的手段。</p>
<ul>
<li>低特权级的软件只能做高特权级允许它做的操作</li>
<li>超出低特权级能力的功能必须寻求高特权级的帮助</li>
</ul>
<p>这样<strong>高特权级</strong>(操作系统)就成为<strong>低特权级</strong>（一般应用）的<strong>执行环境的总要组成部分</strong>。</p>
<p>为了实现这样的特权级机制，需要进行软硬件协同设计。一种简介的方式是： 处理器设置两个不同安全等级的执行环境，<strong>用户态特权级的执行环境和内核态特权级的执行环境</strong>。</p>
<ul>
<li>明确指出可能破坏计算机系统的内核态特权指令集子集</li>
<li>规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行</li>
<li>处理器在执行指令前会进行特权级安全检查，如果在用户态环境中执行内核态特权级指令就会产生异常</li>
</ul>
<p>传统的<code>call</code>和<code>ret</code>指令组合会直接绕过硬件的特权级保护检查，所以需要新的指令：</p>
<ul>
<li><code>ecall</code>： 执行环境调用，具有<strong>用户态</strong>到<strong>内核态</strong>的执行环境切换能力的<strong>函数调用</strong>指令
<ul>
<li>从当前特权级切换到比当前高一级</li>
</ul>
</li>
<li><code>eret</code>： 执行环境返回，基友<strong>内核态</strong>到<strong>用户态</strong>的执行环境切换能力的<strong>函数返回</strong>指令
<ul>
<li>切换到不高于当前特权级</li>
</ul>
</li>
</ul>
<p>硬件有了这样的机制之后，还需要操作系统的配合才能完成对操作系统自身的保护。</p>
<ol>
<li>操作系统需要提供能在执行<code>eret</code>前<strong>准备和恢复用户态执行应用程序的上下文</strong></li>
<li>在用户程序调用<code>ecall</code>后能<strong>检查应用程序的系统调用参数</strong>，确保参数不会破坏操作系统</li>
</ol>
<h2 id="risc-v-特权级架构">RISC-V 特权级架构</h2>
<table>
<thead>
<tr>
<th>级别</th>
<th>编码</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>00</td>
<td>用户/应用模式 (U,User/Application)</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S,Supervisor)</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>虚拟监督模式 (H,Hypervisor)</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M,Machine)</td>
</tr>
</tbody>
</table>
<p>级别数值越大则特权级越高，掌控硬件的能力越强。即 M 最强，U 最弱，在 CPU 层面只有 M 是必须的。</p>
<p><figure id="a-/images/Pasted%20image%2020221230152533.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230152533.png" alt="在特权级架构的角度看待一套支持应用程序运行的执行环境"  />
    
    <figcaption>
       在特权级架构的角度看待一套支持应用程序运行的执行环境
    </figcaption>
    
</figure></p>
<p>白色表示执行环境，黑色表示相邻两层执行环境之间的接口。SSE 代表<strong>监督模式执行环境</strong>，例如 RustSBI。</p>
<p>按需实现 RISC-V 特权级：</p>
<ol>
<li>简单的嵌入式应用只需实现 M</li>
<li>带有一定保护能力的嵌入式系统需要实现 M、U</li>
<li>复杂的多任务系统需要实现 M、S、U</li>
</ol>
<h3 id="操作系统异常控制流">操作系统异常控制流</h3>
<ol>
<li>中断： 由外部设备引起的外部 I/O 时间如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。</li>
<li>异常： 处理器执行指令期间检测到不正常的或非法的内部事件(如除零、数组越界等)</li>
<li>陷入: 程序在执行过程中通过系统调用请求操作系统服务时而有意引发的事件</li>
</ol>
<p>要处理上面的异常，都需要操作系统保存与恢复被 打断/陷入 前应用程序的控制流上下文。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>控制流上下文： 确保下一刻能继续正确执行控制流指令的物理资源，也可称为控制流所在执行环境的状态。</p>
<p>这里的物理资源即计算机硬件资源，如 CPU 的寄存器、内存等。</p>
 </p>
</div>








<p><strong>执行环境</strong>的另一种功能是对<strong>上层软件</strong>的执行进行监管管理： 当<strong>上层软件</strong>执行出现了异常或特殊情况，导致需要用到<strong>执行环境
<strong>中提供的功能，因此需要暂停</strong>上层软件</strong>的执行，转而运行<strong>执行环境</strong>的代码。</p>
<p>而<strong>上层软件</strong>和<strong>执行环境</strong>的<strong>特权等级</strong>往往不同，所以这个过程可能(大部分情况下)会有 CPU 的<strong>特权级切换</strong>。当<strong>执行环境
<strong>的代码运行结束后，我们就需要回到</strong>上层软件</strong>暂停的位置<strong>继续执行</strong>。在 RISC-V 中，这种异常控制流被称为<strong>异常</strong>，是 RISC-V
中的 <strong>trap</strong> 的一种。</p>
<p>用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：</p>
<ol>
<li>用户态软件为获得内核态操作系统的服务功能而执行特殊指令</li>
<li>在执行某条指令出现了错误(如执行了用户态不允许执行的指令)并被 CPU 检测到</li>
</ol>
<table>
<thead>
<tr>
<th>interrupt</th>
<th>exception code</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Instruction address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Instruction access fault</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>Illegal instruction</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>Breakpoint</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Load address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td>Load access fault</td>
</tr>
<tr>
<td>0</td>
<td>6</td>
<td>Store/AMO address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td>Store/AMO access fault</td>
</tr>
<tr>
<td>0</td>
<td>8</td>
<td>Environment call from U-mode</td>
</tr>
<tr>
<td>0</td>
<td>9</td>
<td>Environment call from S-mode</td>
</tr>
<tr>
<td>0</td>
<td>11</td>
<td>Environment call from M-mode</td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td>Instruction page fault</td>
</tr>
<tr>
<td>0</td>
<td>13</td>
<td>Load page fault</td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>Store/AMO page fault</td>
</tr>
</tbody>
</table>
<p>其中 <code>Breakpoint</code> 和 <code>Environment call</code> 两种异常指令称为 陷入 或 trap 类指令。通过在上层软件中执行一条特定的指令触发的：</p>
<ol>
<li>执行 <code>ebreak</code> 指令就会触发 <code>Breakpoint</code> 异常</li>
<li>执行 <code>ecall</code> 指令就会根据 CPU 当前所处的特权级而触发不同的异常(8/9/11)</li>
</ol>
<h3 id="ecall">ecall</h3>
<p>这是一种特殊的陷入类指令，相邻的两特权级软件之间的接口正是通过这种陷入机制实现的。M 模式软件 SEE 和 S 模式的内核之间的接口被称为<strong>监督模式二进制接口</strong>(Supervisor Binary interface, <strong>SBI</strong>)，而内核和 U 模式的应用程序之间的接口被称为<strong>应用程序二进制接口</strong>(Application Binary interface, <strong>ABI</strong>)——系统调用(<strong>syscall</strong>)。</p>
<p>而为什么叫二进制接口，是因为它是机器/汇编指令级的接口(没有针对某种特定的高级语言编写的内部调用接口)，而且不是普通的函数调用控制流，而是陷入异常控制流，会切换 CPU 特权级。所以只有机器/汇编级别才能满足跨语言的通用和灵活性。</p>
<p><figure id="a-/images/Pasted%20image%2020221230220510.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230220510.png" alt="在软件(应用，操作系统)执行过程中经常能看到特权级切换"  />
    
    <figcaption>
       在软件(应用，操作系统)执行过程中经常能看到特权级切换
    </figcaption>
    
</figure></p>
<p>总之出现:</p>
<ol>
<li>执行某一指令发生了某种错误(如除零、无效地址访问、无效指令等)</li>
<li>执行了高特权级指令</li>
<li>访问了不应该方法的高特权级的资源</li>
</ol>
<p>就需要将控制权移交给高特权级的软件来处理。当错误/异常恢复后，则重新回到低特权级的软件中执行，如果错误不能恢复，那么高特权级软件有权限杀死和清除低特权级软件。</p>
<h3 id="risc-v-的s级特权指令">RISC-V 的S级特权指令</h3>
<p>在 RISC-V 中有两类属于 S 模式的特权指令</p>
<ol>
<li>指令本身属于高特权级，如 <code>sret</code>(从 S 模式返回 U 模式)</li>
<li>访问的 S 模式下才能访问的寄存器或内存
<ol>
<li>sstatus: <code>SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息</li>
<li>spec: 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址</li>
<li>scause: 描述 Trap 的原因</li>
<li>stval: 给出 Trap 附加信息</li>
<li>stvec: 控制 Trap 处理代码的入口地址</li>
</ol>
</li>
</ol>
<h2 id="特权级切换">特权级切换</h2>
<p>当执行到一条 trap 类指令时(如<code>ecall</code>)，CPU 发现触发了一个异常并需要进行特殊处理，这涉及到执行环境切换，就是：</p>
<ol>
<li>用户态的执行环境中的应用程序通过调用<code>ecall</code>指令来向内核态的执行环境中的操作系统来请求某项服务</li>
<li>这时候 CPU 和操作系统就会完成用户态到内核态的执行环境切换</li>
<li>并在操作系统完成服务后再次切换回用户态执行环境</li>
<li>然后应用程序就会紧接着<code>ecall</code>指令的后一条继续执行</li>
</ol>
<p>在切换回来之后需要从发出 syscall 的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。</p>
<p>应用程序的上下文包括通用寄存器和栈两个主要部分。而 CPU 在不同特权级下共享一套通用寄存器，所以操作系统在处理 trap 的过程中也会使用到这些寄存器，就会改变应用程序的上下文。所以同函数调用一样，在执行操作系统的 trap 处理过程之前我们需要在某个地方(某内存块或内核的栈)保存这些寄存器并在 trap 处理结束之后恢复这些寄存器。</p>
<p>同时还有一些在 S 模式下专用的寄存器，也需要保证它们的变化在预期之内。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>执行环境： 主要负责给在其上执行的软件提供相应的功能与资源，并可在计算机系统中形成多层次的执行环境。</p>
<ol>
<li>比如之间运行在裸机硬件上的操作系统，其执行环境就是 计算机的硬件</li>
<li>后面就出现了在应用程序下面有了一层比较通用的函数库，这使得程序不用直接访问硬件了。所以应用程序的执行环境就是 函数库 -&gt; 计算机硬件</li>
<li>在后来，操作系统取代了函数库来访问硬件。 函数库 -&gt; 操作系统 -&gt; 计算机硬件</li>
</ol>
 </p>
</div>








<h3 id="特权级切换的硬件控制机制">特权级切换的硬件控制机制</h3>
<p>当 CPU 执行完一条指令(如<code>ecall</code>)并准备从 U 陷入到 S 时，硬件会完成：</p>
<ol>
<li><code>sstatus</code>的<code>SPP</code>会被修改为 CPU 当前的特权级(U/S)</li>
<li><code>sepc</code>会被修改为 trap 处理完成后默认会执行的下一条指令的地址</li>
<li><code>scause/stval</code>分别会被修改为这次 trap 的原因以及相关的附加信息</li>
<li>CPU 会跳转到 <code>stvec</code> 所设置的 trap 处理入口地址，并将当前特权级设置为 S,并从 trap 处理入口开始执行
<ol>
<li><code>stvec</code>保存了中断处理的入口地址</li>
<li>它后两个字段:
<ol>
<li>MODE 1~0, 2 bits</li>
<li>BASE 63~2, 62 bits</li>
</ol>
</li>
<li>当 MODE 为 0 时，<code>stvec</code>是 direct 模式，trap 的入口地址固定为 <code>BASE&lt;&lt;2</code></li>
</ol>
</li>
</ol>
<p>当 CPU 完成 trap 处理准备返回时，需要通过<code>sret</code>来完成:</p>
<ol>
<li>CPU 会将当前的特权级按照<code>sstatus</code>的<code>SPP</code>字段设置为 U/S</li>
<li>CPU 会跳转到<code>sepc</code>指向的指令并继续执行</li>
</ol>
<h3 id="用户栈和内核栈">用户栈和内核栈</h3>
<p>当 trap 触发的一瞬间，CPU 就会切换到 S 特权级并跳转到<code>stvec</code>设置的位置，但是在正式进入 S 特权级的处理之前，我们必须保存原控制流的寄存器状态，这一般是通过内核栈来保存的。这是专门为操作系统准备的内核栈，而不是应用程序运行时的用户栈。</p>
<p>使用两个栈主要是为了安全性:隔离数据，不让用户态的应用程序读取到内核态的操作系统的数据。</p>
<h3 id="trap-管理">Trap 管理</h3>
<p>特权级切换的核心就是对 trap 的管理：</p>
<ol>
<li>应用程序通过<code>ecall</code>进入到内核状态时，操作系统需要保存被打断的应用程序的 trap 上下文</li>
<li>操作系统根据 CSR 寄存器(上述 S 模式下专有的寄存器)，完成系统调用服务的分发与处理</li>
<li>操作系统完成系统调用后，需要恢复被打断的应用程序的 trap 上下文，并通过<code>sret</code>让应用程序进行执行</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[repr(C)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TrapContext</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">x</span>: <span class="p">[</span><span class="kt">usize</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">sstatus</span>: <span class="nc">Sstatus</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">sepc</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="trap-上下文的保存与恢复">Trap 上下文的保存与恢复</h4>
<p>在操作系统初始化时，我们通过修改<code>stvec</code>的值来指向 trap 处理入口点,即设置初始的<code>stvec</code>的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span> <span class="nf">__alltraps</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">// 默认为 BASE 为 __alltraps，MODE 为 direct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">stvec</span>::<span class="n">write</span><span class="p">(</span><span class="n">__alltraps</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">TrapMode</span>::<span class="n">Direct</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>trap 的处理流程如下：</p>
<ol>
<li>通过<code>__alltraps</code>将 trap 上下文保存在内核栈上，然后跳转到 <code>trap_handler</code> 函数完成 trap 分发及处理</li>
<li>当 <code>trap_handler</code>返回之后，使用<code>__restore</code>从保存在内核栈上的 trap 上下文恢复寄存器</li>
<li>最后通过<code>sret</code>指令回到应用程序执行</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__alltraps:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># csrrw rd csr rs =&gt; rd = csr, csr = rs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># sp = sscratch, sscratch = sp, 交换 sscratch 与 sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># sp 指向用户栈，sscratch 指向内核栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 交换后 sp 指向内核栈，sscratch 指向用户栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrrw</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">sp</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack, sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># allocate a TrapContext on kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 预分配 34 * 8 的栈帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">34</span><span class="p">*</span><span class="mi">8</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># save general-purpose registers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 保存 x0 ~ x31 跳过 x0(zero),x2(sp),x4(tp)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># skip sp(x2), we will save it later  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># skip tp(x4), application does not use it  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save x5~x31  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">27</span>  
</span></span><span class="line"><span class="cl">        <span class="no">SAVE_GP</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># we can use t0/t1/t2 freely, because they were saved on kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># t0 = sstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t0</span><span class="p">,</span> <span class="no">sstatus</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># t1 = spec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t1</span><span class="p">,</span> <span class="no">sepc</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 32*8 = t0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 33*8 = t1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># read user stack from sscratch and save it on the kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 2*8 = sscratch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t2</span><span class="p">,</span> <span class="no">sscratch</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sd</span> <span class="no">t2</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># set input argument of trap_handler(cx: &amp;mut TrapContext) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># a0 = 内核栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mv</span> <span class="no">a0</span><span class="p">,</span> <span class="no">sp</span>  
</span></span><span class="line"><span class="cl">    <span class="no">call</span> <span class="no">trap_handler</span>
</span></span></code></pre></div><p>当<code>trap_handler</code>返回之后会从<code>trap_handler</code>的下一条指令开始执行，也就是<code>__restore</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__restore:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># case1: start running app by __restore  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># case2: back to U after handling trap  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mv</span> <span class="no">sp</span><span class="p">,</span> <span class="no">a0</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore sstatus/sepc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 恢复在 __alltraps 保存的   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  <span class="c1"># sstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  <span class="c1"># spec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t2</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>   <span class="c1"># sscratch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">sstatus</span><span class="p">,</span> <span class="no">t0</span>  
</span></span><span class="line"><span class="cl">    <span class="no">csrw</span> <span class="no">sepc</span><span class="p">,</span> <span class="no">t1</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># 设置为用户栈 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">t2</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 恢复 x0 ~ x31 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore general-purpuse registers except sp/tp  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">ld</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">27</span>  
</span></span><span class="line"><span class="cl">        <span class="no">LOAD_GP</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># release TrapContext on kernel stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 释放栈帧  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">34</span><span class="p">*</span><span class="mi">8</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack, sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrrw</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">sp</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 返回到用户程序继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sret</span>
</span></span></code></pre></div>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p><code>sscratch</code>这个寄存器它：</p>
<ol>
<li>保存了内核栈的地址</li>
<li>作为一个中转站让<code>sp</code>（执行用户栈的地址）暂存在<code>sscratch</code>中</li>
</ol>
<p>通过<code>csrrw  sp, sscratch, sp</code>这一条指令就完成内核栈与用户栈的相互交换</p>
 </p>
</div>








<h4 id="trap-分发与处理">Trap 分发与处理</h4>
<ol>
<li>根据<code>scause</code>的<code>cause</code>进行分发处理</li>
<li>如果是<code>UserEnvCall</code>
<ol>
<li>则设置<code>sepc</code>为下一条指令</li>
<li>调用 syscall</li>
</ol>
</li>
<li>如果出现错误则直接运行下一个应用程序</li>
<li>如果是不支持的 trap 则直接抛出异常</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[no_mangle]</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// handle an interrupt, exception, or system call from user space  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">trap_handler</span><span class="p">(</span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TrapContext</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TrapContext</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">scause</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scause</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// get trap cause  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stval</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// get extra value  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">scause</span><span class="p">.</span><span class="n">cause</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">UserEnvCall</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cx</span><span class="p">.</span><span class="n">sepc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall</span><span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">12</span><span class="p">]])</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">StoreFault</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">StorePageFault</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;[kernel] PageFault in application, kernel killed it.&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">run_next_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">IllegalInstruction</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;[kernel] IllegalInstruction in application, kernel killed it.&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">run_next_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;Unsupported trap {:?}, stval = {:#x}!&#34;</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">scause</span><span class="p">.</span><span class="n">cause</span><span class="p">(),</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">stval</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cx</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="执行应用程序">执行应用程序</h3>
<p>当操作系统初始化完成或某个应用形成运行结束或失败时，就调用<code>run_next_app</code>运行下一个应用程序。此时是 S 模式而要切换到 U 模式，所以切换流程:</p>
<ol>
<li>构造应用程序开执行所需的 trap 上下文</li>
<li>通过<code>__restore</code>函数，从 trap 上下文中恢复应用程序执行所需的寄存器</li>
<li>设置<code>sepc</code>的值为<code>0x80400000</code>(固定为这个值，后续会把每个应用程序加载到这个地址)</li>
<li>切换<code>scratch</code>和<code>sp</code>，将<code>sp</code>指向应用程序用户栈</li>
<li>执行<code>sret</code>切换 S =&gt; U</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// init app context  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">app_init_context</span><span class="p">(</span><span class="n">entry</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sstatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sstatus</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// CSR sstatus  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">sstatus</span><span class="p">.</span><span class="n">set_spp</span><span class="p">(</span><span class="n">SPP</span>::<span class="n">User</span><span class="p">);</span><span class="w"> </span><span class="c1">//previous privilege mode: user mode  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">x</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">],</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sstatus</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sepc</span>: <span class="nc">entry</span><span class="p">,</span><span class="w"> </span><span class="c1">// entry point of app  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cx</span><span class="p">.</span><span class="n">set_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="c1">// app&#39;s user stack pointer  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">cx</span><span class="w"> </span><span class="c1">// return initial Trap Context of app  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// run next app  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run_next_app</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// ...
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span> <span class="nf">__restore</span><span class="p">(</span><span class="n">cx_addr</span>: <span class="kt">usize</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 在内核栈上压入一个 trap 上下文,它在栈顶,所以是 __restore 的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 即 a0 = 内核栈顶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 所以会有 `mv sp a0` 这一句,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// sepc 的值为固定的程序入口    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 根据`__restore`函数，如果是第一次调用，那么`sscratch`是什么时候设置为用户栈的？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 根据`mv sp a0`那么则 sp = a0 = trapContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 在`app_init_context`的实现中有`cx.set_sp(sp)`这一句即x[2] = sp = 用户栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 在`__restore`中有`ld t2, 2*8(sp)`与`csrw sscratch, t2`就完成了设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">__restore</span><span class="p">(</span><span class="n">KERNEL_STACK</span><span class="p">.</span><span class="n">push_context</span><span class="p">(</span><span class="n">TrapContext</span>::<span class="n">app_init_context</span><span class="p">(</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">APP_BASE_ADDRESS</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">USER_STACK</span><span class="p">.</span><span class="n">get_sp</span><span class="p">(),</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Unreachable in batch::run_current_app!&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统的并发编程</title>
      <link>https://fzdwx.github.io/posts/2022-12-16-os-concurrent/</link>
      <pubDate>Fri, 16 Dec 2022 20:54:45 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-16-os-concurrent/</guid>
      <description>从操作系统的层面讲要支持并发需要哪些条件</description>
      <content:encoded><![CDATA[<blockquote>
<p>操作系统是最早的并发程序之一。</p>
</blockquote>
<p>开始，我们肯定要理解什么是并发和并行以及它们的区别。</p>
<ul>
<li>并行： 可以同时处理多个任务。</li>
<li>并发： 可以执行多个任务，但是同时只能执行一个任务，会在它们之间进行切换。</li>
</ul>
<h2 id="如果一个操作系统要支持并发那么以下的哪些部分需要复制多份">如果一个操作系统要支持并发，那么以下的哪些部分需要复制多份？</h2>
<ol>
<li>全局变量</li>
<li>堆内存</li>
<li>函数调用栈</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221216211245.png" class="align-center">
    <img src="/images/Pasted%20image%2020221216211245.png" alt="答案显而易见的是 函数调用栈"  />
    
    <figcaption>
       答案显而易见的是 函数调用栈
    </figcaption>
    
</figure></p>
<p>并发编程为什么难？</p>
<ol>
<li>所有线程都共享一个堆内存</li>
<li>单个线程的状态机的执行结果是固定的，但是多线程不一样，因为它们涉及到一个线程切换的问题，这会导致每次程序运行的结果可能都是不一样的。</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221216211708.png" class="align-center">
    <img src="/images/Pasted%20image%2020221216211708.png" alt="多线程状态机执行示意图"  />
    
    <figcaption>
       多线程状态机执行示意图
    </figcaption>
    
</figure></p>
<h2 id="无法保证的三个特性">无法保证的三个特性</h2>
<ol>
<li>原子性: 一段代码执行时独占整个计算机系统
<ol>
<li>无法保证的例子： 两个线程对一个值进行 ++ N 次， 这个结果可能不是 2N</li>
<li>实现原子性： <code>lock</code> &amp; <code>unlock</code>
<ul>
<li>实现临界去的绝对串行化</li>
<li>其他部分仍然可以并行执行</li>
</ul>
</li>
</ol>
</li>
<li>顺序性: 代码按编写的顺序执行，也就是实现源代码的按顺序翻译(为汇编)。
<ol>
<li>会导致的原因: 编译器的优化(<strong>编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效</strong>。)，比如说 gcc 加<code>-O1/2</code></li>
<li>实际例子：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// =&gt; opt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span></code></pre></div></li>
<li>实现源代码的按顺序翻译： 在代码中插入“优化不能穿越的” barrier
<ol>
<li>asm volatile (&quot;&quot; ::: &ldquo;memory&rdquo;);
<ol>
<li>含义是 可以读写任何内存</li>
</ol>
</li>
<li>使用 volatile 变量
<ol>
<li>保持 c 语义和汇编语义一致</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="k">volatile</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span></span></code></pre></div></li>
</ol>
</li>
<li>可见性： 对某个共享内存的修改，其他线程要立马可见。
<ol>
<li>一段代码: 它的结果可能为: <code>0,0</code> <code>0,1</code> <code>1,0</code> <code>1,1</code> 4种情况, 但是只要有方法(f1 / f2)被执行就不会出现<code>0,0</code>这种结果。但实际的情况是<code>0,0</code>这个结果出现的次数最多。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	 <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">一个操</span>
</span></span><span class="line"><span class="cl">	 <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	 <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>原因是：现代处理器也是一个动态编译器。单个处理器把汇编（用电路）编译成更小的操作符。
<ol>
<li>在任何时刻，处理器都维护了一个操作符的容器</li>
<li>每一周期尽可能多的补充操作符</li>
<li>每一周期执行尽可能多的操作符</li>
<li>乱序执行，按序提交</li>
</ol>
</li>
<li>实现顺序一致性： 使用<code>mfence</code>指令或使用原子指令(lock),让它每次都到内存中去读取，而不读取缓存</li>
</ol>
</li>
</ol>
<h2 id="自旋锁-spin-lock">自旋锁 spin lock</h2>
<p>假如硬件能提供一条“瞬间完成” 的读 + 写的指令</p>
<ul>
<li>其他所有人暂停，load + store
<ul>
<li>如果有人同时请求，硬件选出一个胜利者</li>
<li>败者等胜利者完成后继续</li>
</ul>
</li>
</ul>
<h3 id="x86提供的-lock-前缀">X86提供的 lock 前缀</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sum</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">		<span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;lock addq $1, %0&#34;</span><span class="o">:</span> <span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">sum</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>atomic exchange(load + store)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">xchg</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&#34;lock xchg %0, %1&#34;</span> 
</span></span><span class="line"><span class="cl">		<span class="o">:</span> <span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="s">&#34;=a&#34;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;1&#34;</span><span class="p">(</span><span class="n">newval</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">result</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>实现自旋锁:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="nf">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span> <span class="nf">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="lock-指令的现代实现">lock 指令的现代实现</h3>
<p>在 L1 cache 层保持一致性</p>
<ul>
<li>所有 cpu 的L1缓存都用总线连起来</li>
<li>对某个内存 M 执行 lock，则其他所有缓存的 M 都无效（这个代价非常大）</li>
</ul>
<h2 id="risc-v-的原子操作">RISC-V 的原子操作</h2>
<p>原子操作的目的：</p>
<ol>
<li><code>a = load(x); if (a == xx){ store(x,y) }</code></li>
<li><code>a = load(x); store(x,y)</code></li>
<li><code>a = load(x); a++; store(x,a)</code></li>
</ol>
<p>它们的本质都是 load -&gt; exec(进行运算) -&gt; store</p>
<h3 id="load-reserved--store-conditional">Load reserved / Store Conditional</h3>
<p>LR: 在读取时会对这个内存加上一个标记，中断、其他处理器的写入都会导致标记消除</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lr.w</span> <span class="no">rd</span> <span class="p">(</span><span class="no">rs1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">rd</span> <span class="err">=</span> <span class="no">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reserve</span> <span class="no">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span>
</span></span></code></pre></div><p>SC: 如果那片内存还存在标记则继续写入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">sc.w</span> <span class="no">rd</span> <span class="no">rs2</span> <span class="p">(</span><span class="no">rs1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">if</span> <span class="no">still</span> <span class="no">reserved</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span> <span class="err">=</span> <span class="no">rs2</span>
</span></span><span class="line"><span class="cl">		<span class="nf">rd</span> <span class="err">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nl">else:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">rd</span> <span class="err">=</span> <span class="no">nonzero</span>
</span></span></code></pre></div><h3 id="实现-cas">实现 cas</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">cas</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmp_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">old_val</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">old_val</span> <span class="o">==</span> <span class="n">cmp_val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">cas:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lr.w</span> <span class="no">t0</span> <span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bne</span> <span class="no">t0</span> <span class="no">a1</span> <span class="no">fail</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sc.w</span> <span class="no">t0</span> <span class="no">a2</span> <span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bnez</span> <span class="no">t0</span> <span class="no">cas</span>
</span></span><span class="line"><span class="cl">	<span class="nf">li</span> <span class="no">a0</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jr</span> <span class="no">ra</span>
</span></span><span class="line"><span class="cl"><span class="nl">fail:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">li</span> <span class="no">a0</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ja</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="线程同步">线程同步</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>RISC-V 简介</title>
      <link>https://fzdwx.github.io/posts/2022-12-10-risc-v/</link>
      <pubDate>Sat, 10 Dec 2022 20:41:41 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-10-risc-v/</guid>
      <description>RISC-V 是一种指令集(汇编语言)，是一种 low-level 的编程语言，高级语言通过编译器编译到汇编语言</description>
      <content:encoded><![CDATA[<h2 id="resource">Resource</h2>
<ol>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf" target="_blank" rel="noopener">RISC-V Green Card</a>
</li>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/RISCV_Calling_Convention.pdf" target="_blank" rel="noopener">RISC-V Call convertion</a>
</li>
<li>&nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">P&amp;H(RISC-V)</a>
</li>
</ol>
<p>在汇编语言中没有变量这个概念，汇编语言通常操作的是<strong>寄存器</strong>。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <strong>寄存器</strong>（Register）是&nbsp;<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" title="中央处理器" target="_blank" rel="noopener">中央处理器</a>
内用来暂存指令、&nbsp;<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A" title="数据" target="_blank" rel="noopener">数据</a>
和&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80" title="内存地址" target="_blank" rel="noopener">地址</a>
的&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" title="电脑存储器" target="_blank" rel="noopener">电脑存储器</a>
。寄存器的存贮容量有限，读写速度非常快。在&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%9E%B6%E6%A7%8B" title="计算机体系结构" target="_blank" rel="noopener">计算机体系结构</a>
里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F" title="计算机程序" target="_blank" rel="noopener">计算机程序</a>
的执行。 </p>
</div>








<h2 id="risc-v-card">RISC-V Card</h2>
<h3 id="risc-v-操作数">RISC-V 操作数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210211515.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211515.png" alt=""  />
    
</figure></p>
<ul>
<li>如果寄存器的大小是 64位 则称为<strong>双字</strong>，32位 则是<strong>单字</strong>。</li>
<li>x<sub>0</sub> 被硬连接到 0
<ul>
<li><code>add x3, x4, x0</code> =&gt; <code>x3 = x4</code> (x0 is hard-wired to value 0)</li>
</ul>
</li>
</ul>
<h2 id="汇编指令">汇编指令</h2>
<p><figure id="a-/images/Pasted%20image%2020221210211545.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211545.png" alt=""  />
    
</figure><figure id="a-/images/Pasted%20image%2020221210211603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211603.png" alt=""  />
    
</figure></p>
<h2 id="存储操作数">存储操作数</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 将数据从内存复制到寄存器的数据传输指令称为 <em>载入指令(<code>load</code>)</em>。在 RISC-V 中指令是 <strong>ld</strong>,表示取双字。 </p>
</div>








<h3 id="一个从数组中取值的c程序写出汇编代码">一个从数组中取值的C程序，写出汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或<em>基址</em>位于 x22 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ld</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span> <span class="c1">// x9 = A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">add</span> <span class="no">x21</span><span class="p">,</span> <span class="no">x20</span><span class="p">,</span> <span class="no">x9</span><span class="c1">; // x21 = x20 + x9
</span></span></span></code></pre></div><p>存放基址的寄存器(x22)被称为<em>基址寄存器</em>, 数据传输指令中的 8 称为<em>偏移量</em>。</p>
<p><figure id="a-/images/Pasted%20image%2020221212130603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212130603.png" alt="实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数"  />
    
    <figcaption>
       实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数
    </figcaption>
    
</figure></p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        大端与小端编址
        
    </p>
    <p> <p>计算机分为两种，一种使用最左边或“大端”字节的地址作为双字地址，另一种使用最右端或“小端”字节的地址作为双字地址。</p>
<p>RISC-V 使用小端  。由于仅在以双字形式和 8 个单独字节访问相同数据时，字节顺序才有影响，因此大多情况不需要关系“大小端”。</p>
 </p>
</div>








<p>所以为了上面的代码获得正确的字节地址加到 x22 这个寄存器的偏移量为 64（8x8）。</p>
<p>与载入指令相反的指令通常被成为<em>存储指令(store)</em>,从寄存器复制数据到内存。指令是<code>sd</code>,表示存储双字。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 在一些体系结构中，字的起始地址必须是 4 的倍数，双字的起始地址必须是 8 的倍数。该要求成为<em>对齐限制</em> </p>
</div>








<p>RISC-V 和 Intel x86 没有对齐限制，但 MIPS 有这个限制。</p>
<p><figure id="a-/images/Pasted%20image%2020221212152022.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212152022.png" alt=""  />
    
</figure></p>
<h3 id="使用-load-和-store-编译生成指令">使用 load 和 store 编译生成指令</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>h 存放在 x21 中，A 的基址存放在 x22 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ld</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span>  <span class="c1">// x9 = A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">add</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x21</span><span class="p">,</span> <span class="no">x9</span> <span class="c1">// x9 = h + A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">sd</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">96</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span>  <span class="c1">// A[12] = x9
</span></span></span></code></pre></div><h3 id="将字符串复制程序编译为汇编">将字符串复制程序编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">[],</span><span class="kt">char</span> <span class="n">y</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>x, y 的基址存放在 x10 和 x11 中， i 存放在 x19 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">strcpy:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>  <span class="c1">// 调整栈指针，以存放一个item(x19)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sd</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    <span class="c1">// x19 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>  <span class="c1">// x19 = 0 + 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L1:</span> <span class="nf">add</span> <span class="no">x5</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x11</span> <span class="c1">// x5 = x19 + x11 =&gt; address of y[i] in x5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lbu</span> <span class="no">x6</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x5</span><span class="p">)</span>    <span class="c1">// temp: x6 = y[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x7</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x10</span> <span class="c1">// x5 = x19 + x11 =&gt; address of x[i] in x7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sd</span>  <span class="no">x6</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x7</span><span class="p">)</span>    <span class="c1">// x[i] = y[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">beq</span> <span class="no">x6</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">L2</span>   <span class="c1">// if x6 ==0 then go to L2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">// i = i  + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">jal</span> <span class="no">x0</span><span class="p">,</span> <span class="no">L1</span>       <span class="c1">// go to L1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L2:</span> <span class="nf">ld</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    <span class="c1">// 恢复 x19 以及栈指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span> 
</span></span><span class="line"><span class="cl">	<span class="no">jalr</span> <span class="no">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="一段循环代码编译为汇编">一段循环代码编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span>  <span class="mi">3</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>RISC-V 汇编（32 bit)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">	<span class="nf">add</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x8</span><span class="p">,</span> <span class="no">x0</span>     <span class="c1"># x9 = &amp;A[0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>    <span class="c1"># sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>    <span class="c1"># i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x13</span><span class="p">,</span><span class="no">x0</span><span class="p">,</span> <span class="mi">20</span>    <span class="c1"># 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">Loop:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bge</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x13</span><span class="p">,</span> <span class="no">Done</span> <span class="c1"># if x11 &gt; x13 go to Down(end loop)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">x12</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x9</span><span class="p">)</span>      <span class="c1"># x12 = A[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x12</span>  <span class="c1"># sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">4</span>     <span class="c1"># x9 = &amp;A[i+1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x11</span><span class="p">,</span> <span class="mi">1</span>   <span class="c1"># i++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">j</span> <span class="no">loop</span>
</span></span><span class="line"><span class="cl"><span class="nl">Done:</span>
</span></span></code></pre></div><h2 id="逻辑操作">逻辑操作</h2>
<ul>
<li><code>and</code> <code>andi</code>
<ul>
<li><code>and x5, x6, x9</code> =&gt; x5 = x6 &amp; x9</li>
<li><code>addi x5, x6, 3</code> =&gt; x5 = x6 &amp; 3</li>
</ul>
</li>
<li><code>sll</code> <code>ssli</code> , 左移(扩大)
<ul>
<li><code>slli x11, x23, 2</code> =&gt; x11 = x23 &laquo; 2</li>
<li>0000 0010  =&gt; 2</li>
<li>0000 1000 =&gt; 8</li>
</ul>
</li>
<li><code>srl</code> <code>srli</code> , 右移（缩小)
<ul>
<li><code>srli x23, x11, 2</code> = &gt; x23 = x11 &raquo; 2</li>
<li>0000 1000 =&gt; 8</li>
<li>0000 0010 =&gt; 2</li>
</ul>
</li>
<li><code>sra</code> <code>srai</code>, 算数右移
<ul>
<li>1111 1111 1111 1111 1111 1111 1110 0111 = -25</li>
<li><code>srai x10, x10, 4</code></li>
<li>1111 1111 1111 1111 1111 1111 1111 1110 = -2</li>
</ul>
</li>
</ul>
<h2 id="helpful-risc-v-assmebler-features">Helpful RISC-V Assmebler Features</h2>
<ol>
<li>a0 - a7 是参数寄存器(x10 - x17，用于函数调用。</li>
<li>zero 代表 x0</li>
<li><code>mv rd, rs = addi rd, rs, 0</code></li>
<li><code>li rd, 13 = addi rd, x0, 13</code></li>
<li><code>nop = addi x0, x0</code></li>
<li><code>la a1 Lable</code> 将 Label 的 地址 加载到 a1</li>
<li>a0 - a7(x10 - x17): 8 个寄存器用于参数传递以及两个返回值(a0 - a1)</li>
<li>ra（x1）: 一个返回 address 的寄存器，用于返回原点（调用的位置）</li>
<li>s0 - s1(x8 - x9) and s2 - s11 (s18 - x27): 保存的寄存器</li>
</ol>
<h2 id="risc-v-函数调用的转换">RISC-V 函数调用的转换</h2>
<ol>
<li>寄存器比内存快，所以使用它们</li>
<li><code>jal rd, Label</code> 跳转和链接
<ol>
<li><code>jal x1, 100</code></li>
</ol>
</li>
<li><code>jalr rd, rs, imm</code> 跳转和链接寄存器
<ol>
<li><code>jalr x1, 100(x5)</code></li>
</ol>
</li>
<li><code>jal Lable</code> =&gt; <code>jal ra, Lable</code> 调用函数</li>
<li><code>jalr s1</code> 当 s1 是方法指针时，这就是一个函数调用</li>
</ol>
<h3 id="一段函数调用转换为汇编">一段函数调用转换为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="err">1000</span> <span class="nf">mv</span> <span class="no">a0</span><span class="p">,</span> <span class="no">s0</span>              <span class="c1"># x = a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1004</span> <span class="nf">mv</span> <span class="no">a1</span><span class="p">,</span> <span class="no">s1</span>              <span class="c1"># y= b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1008</span> <span class="nf">addi</span> <span class="no">ra</span><span class="p">,</span> <span class="no">zero</span><span class="p">,</span> <span class="mi">1016</span>    <span class="c1"># 1016 is sum function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1012</span> <span class="nf">j</span>                      <span class="c1"># jump to sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1016</span> <span class="na">...</span> 
</span></span><span class="line"><span class="cl"><span class="no">...</span>
</span></span><span class="line"><span class="cl"><span class="err">2000</span> <span class="nl">sum:</span> <span class="nf">add</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>
</span></span><span class="line"><span class="cl"><span class="err">2004</span> <span class="nf">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><p>1008 ~ 1012 可以使用 <code>jal sum</code> 来替代、</p>
<h3 id="调用函数的基本步骤">调用函数的基本步骤</h3>
<ol>
<li>把需要的参数放到方法可以访问的地方（寄存器）</li>
<li>转移控制权给函数,使用(<code>jal</code>)
<ol>
<li>保持地址，并跳转到函数的地址</li>
</ol>
</li>
<li>获取函数执行所需的(local)存储资源</li>
<li>执行预期的函数</li>
<li>将返回值放在调用代码可以访问的地方，并恢复我们使用到的寄存器，释放本地存储</li>
<li>将控制器返回给主处理器（<code>ret</code>), 使用存储在寄存器中的地址，返回到调用它的地方</li>
</ol>
<h3 id="方法调用示例">方法调用示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>g,h,i,j in a0,a1,a2,a3</li>
<li>f in s0</li>
<li>temp is s1</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">leaf:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># prologue start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>   <span class="c1"># 腾出 8byte 来存放的2个整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>      <span class="c1"># 保存 s1, s0 到 sp 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">s0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># prologue end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">s0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>    <span class="c1"># f = g + h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">s1</span><span class="p">,</span> <span class="no">a2</span><span class="p">,</span> <span class="no">a3</span>    <span class="c1"># temp = i + j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sub</span> <span class="no">a0</span><span class="p">,</span> <span class="no">s0</span><span class="p">,</span> <span class="no">s1</span>    <span class="c1"># a0 = （g + h) - (i + j) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1"># epilogue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">s0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>      <span class="c1"># 恢复 s1, s0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    
</span></span><span class="line"><span class="cl">	<span class="no">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span> <span class="mi">8</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="no">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="sp">sp</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>sp 是栈指针，从内存空间 的最顶部开始向下增长，在 RISC-V 中使用 x2 这个寄存器。</p>
<ol>
<li>push 是减少 sp 的指针地址</li>
<li>pop 是增加</li>
</ol>
 </p>
</div>








<p>每个函数都有一组存放在栈上的数据，它们是<strong>栈帧</strong>（stack frame ），栈帧通常包含：</p>
<ol>
<li>返回地址</li>
<li>参数</li>
<li>使用的局部变量的空间</li>
</ol>
<h2 id="嵌套函数调用">嵌套函数调用</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sumSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 ra 中有一个 sumSquare 想要跳回的值，但是这个值会被调用 mult 覆盖。</p>
<ol>
<li>caller: 调用函数的人</li>
<li>calle： 被调用的函数</li>
<li>当被调用者从执行中返回时，调用者需要知道哪些寄存器可能发生了变化，哪些寄存器被保证是不变的。</li>
<li>寄存器规定： 即哪些寄存器在程序调用(<code>jal</code>) 后将被取消缓存 ，哪些可以被改变。
<ol>
<li>即有一些寄存器是易失的(temp),一些是要保存的（<strong>调用者需要恢复它们原来的值</strong>）。</li>
<li>这优化了每次进入栈帧的寄存器的数量</li>
</ol>
</li>
<li>分类:
<ol>
<li>跨函数调用保留:
<ol>
<li>sp, gp, tp</li>
<li>s0 - s11 (s0 is also fp)</li>
</ol>
</li>
<li>不保留:
<ol>
<li>参数寄存器以及返回寄存器： a0 - a7, ra</li>
<li>temp 寄存器: t0 - t6</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>上面代码的 RISC-V</p>
<p>x in a1, y in a1</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">sumSquare:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span> <span class="p">-</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sw</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// save retrun address to sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// save s1 to y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mv</span> <span class="no">a1</span><span class="p">,</span> <span class="no">a0</span>                <span class="c1">// y = x =&gt; mult(x,x)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">jal</span> <span class="no">mult</span>                 <span class="c1">// call mult
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// get y from sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>           <span class="c1">// mult() + y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// get retrun address from sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="risc-v-寄存器名称">RISC-V 寄存器名称</h2>
<p><figure id="a-/images/Pasted%20image%2020221213192858.png" class="align-center">
    <img src="/images/Pasted%20image%2020221213192858.png" alt=""  />
    
</figure></p>
<h2 id="risc-v-方法调用套路">RISC-V 方法调用套路</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">matmul:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 压栈，腾出空间保存我们要使用的几个 s 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span> <span class="no">sp</span> <span class="p">-</span><span class="mi">36</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">ra</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s0</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s1</span> <span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s2</span> <span class="mi">12</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s3</span> <span class="mi">16</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s4</span> <span class="mi">20</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s5</span> <span class="mi">24</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s6</span> <span class="mi">28</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s7</span> <span class="mi">32</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="no">body</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># xxx xxx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">end:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 恢复寄存器的值  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lw</span> <span class="no">ra</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s0</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s1</span> <span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s2</span> <span class="mi">12</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s3</span> <span class="mi">16</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s4</span> <span class="mi">20</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s5</span> <span class="mi">24</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s6</span> <span class="mi">28</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s7</span> <span class="mi">32</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">addi</span> <span class="no">sp</span> <span class="no">sp</span> <span class="mi">36</span>  
</span></span><span class="line"><span class="cl">    <span class="no">ret</span>  
</span></span></code></pre></div><h1 id="risc-v-指令二进制的表示">RISC-V 指令二进制的表示</h1>
<h2 id="r-格式布局">R 格式布局</h2>
<p>用于算术和逻辑运算的指令</p>
<p><figure id="a-/images/Pasted%20image%2020221224214056.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224214056.png" alt=""  />
    
</figure></p>
<ol>
<li>opcode，funct3, funct7 : 将告诉我们是否要执行加，减，左移，异或等操作。
<ol>
<li>R-format 的 opcode 固定为 0110011</li>
</ol>
</li>
<li>一个 add 操作： <code>add x18 x19 x10</code> =&gt; <code>x18 = x19 + x10</code></li>
<li><code>0000000 01010 10011 000 10010 0110011</code></li>
<li><code>rs2 = x19</code>, <code>rs1 = x10</code>, <code>rd = x18</code></li>
</ol>
<h2 id="i-格式布局">I 格式布局</h2>
<p>处理立即数，比如<code>addi rd rs1, imm</code> =&gt; <code>addi a0 a0 1</code></p>
<p><figure id="a-/images/Pasted%20image%2020221224220039.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224220039.png" alt=""  />
    
</figure></p>
<ol>
<li>imm 的范围是 -2084 ～ 2047</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221224220349.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224220349.png" alt="addi x15 x1 -50"  />
    
    <figcaption>
       addi x15 x1 -50
    </figcaption>
    
</figure></p>
<h2 id="risc-v-loads">RISC-V Loads</h2>
<p>load 指令也是 I 类型的。</p>
<p><figure id="a-/images/Pasted%20image%2020221224221104.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224221104.png" alt="lw x14 8(x2)"  />
    
    <figcaption>
       lw x14 8(x2)
    </figcaption>
    
</figure></p>
<h2 id="s-格式布局">S 格式布局</h2>
<p><figure id="a-/images/Pasted%20image%2020221224221434.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224221434.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>浮点数在计算机中的表示</title>
      <link>https://fzdwx.github.io/posts/2022-12-09-float-rep/</link>
      <pubDate>Fri, 09 Dec 2022 19:02:32 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-09-float-rep/</guid>
      <description>简单介绍浮点数的几种表示方式以及 RISC-V 中相关的浮点寄存器</description>
      <content:encoded><![CDATA[<h2 id="表示方法">表示方法</h2>
<figure class="align-center">
    $(-1)^{S}\times(1.xxx&hellip;x_{2}\times2^{{yyy&hellip;y}_{2}})$

    
    <figcaption>
        指数表示Y,尾数表示X
    </figcaption>
    
</figure>
<p><figure id="a-/images/Pasted%20image%2020221209193439.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193439.png" alt="单精度的表示方法"  />
    
    <figcaption>
       单精度的表示方法
    </figcaption>
    
</figure></p>
<p><figure id="a-/images/Pasted%20image%2020221209193511.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193511.png" alt="双精度的表示方法"  />
    
    <figcaption>
       双精度的表示方法
    </figcaption>
    
</figure></p>
<p>公式:</p>
<figure class="align-center">
    $(-1)^{S}\times{F}\times{2^{E}}$

    
    <figcaption>
        F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。
    </figcaption>
    
</figure>
<h2 id="移码表示法">移码表示法</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 最理想的表示法是将最小的负指数表示为 00&hellip;00<sub>2</sub>， 将最大的正指数表示为 11&hellip;11<sub>2</sub>。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 </p>
</div>








<p>IEEE 754规定:</p>
<ol>
<li>单精度的偏移值为 127
<ol>
<li>指数为 -1 表示 -1 + 127<sub>10</sub> = 126<sub>10</sub> = 01111110<sub>2</sub></li>
<li>+1 = 1 + 127<sup>10</sup> = 128<sub>10</sub> = 10000000<sub>2</sub></li>
<li>最大指数为127</li>
<li>最小为-126</li>
</ol>
</li>
<li>双精度的指数偏移值为 1023
<ol>
<li>1023</li>
<li>-1022</li>
</ol>
</li>
</ol>
<p>带偏移值的指数意味着一个由浮点数表示的值实际上是:</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<h3 id="表示---075sub10sub">表示 - 0.75<sub>10</sub></h3>
<p>分数表示为：</p>
<figure class="align-center">
    (-3/4)<sub>10</sub> = (-3/2<sup>2</sup>)<sub>10</sub>

    
</figure>
<p>二进制小数表示:</p>
<figure class="align-center">
    (-11/2<sup>2</sup>)<sub>10</sub> = -0.11<sub>2</sub>

    
    <figcaption>
        -11 右移 2 位
    </figcaption>
    
</figure>
<p>用科学计数法表示:</p>
<figure class="align-center">
    -0.11<sub>2</sub> x 2<sup>0</sup>

    
</figure>
<p>用规格化的科学计数法表示:</p>
<figure class="align-center">
    -1.1<sub>2</sub> x 2<sup>-1</sup>

    
</figure>
<p>由上面的公式的到：</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<ul>
<li>有效位数: 0.1<sub>2</sub></li>
<li>
<ul>
<li>1 = (- 1)<sup>S</sup> =&gt; S = 1<sub>2</sub></li>
</ul>
</li>
<li>指数 - 127 = -1 =&gt; 指数 = 126<sub>10</sub></li>
</ul>
<p>单精度可以表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210142957.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210142957.png" alt=""  />
    
</figure></p>
<p>双精度表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210143322.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143322.png" alt=""  />
    
</figure></p>
<h3 id="表示二进制浮点数为十进制浮点数">表示二进制浮点数为十进制浮点数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210143423.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143423.png" alt=""  />
    
</figure></p>
<ul>
<li>S = 1</li>
<li>有效位数: 0.01<sub>2</sub> =&gt; 1 x 2<sup>-2</sup>（右移两位） = 0.25</li>
<li>指数: 129</li>
</ul>
<p>根据公式:</p>
<p>$(-1)^{1}\times{(1 + 0.25)}\times{2^{129 - 127}}$</p>
<p>= $-1\times1.25\times2^2$</p>
<p>= $-1.25\times4$</p>
<p>= $-5$</p>
<blockquote>
<p>浮点加法与浮点乘法可以看 P&amp;H 3.5.4~3.5.5 &nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf</a>
</p>
</blockquote>
<h2 id="risc-v-中的浮点指令">RISC-V 中的浮点指令</h2>
<ul>
<li>算术
<ul>
<li>加法: <code>fadd.s</code> <code>fadd.d</code>
<ul>
<li><code>fadd.s f0, f1, f2</code> =&gt; <code>f0 = f1 + f2</code></li>
</ul>
</li>
<li>减法：<code>fsub</code> <code>fsub</code>
<ul>
<li><code>fsub.s f0, f1, f2</code> =&gt; <code>f0 = f1 - f2</code></li>
</ul>
</li>
<li>乘法: <code>fmul</code>
<ul>
<li><code>fmul.s f0, f1, f2</code> =&gt; <code>f0 = f1 * f2</code></li>
</ul>
</li>
<li>除法: <code>fdiv</code>
<ul>
<li><code>fdivs f0, f1, f2</code> =&gt; <code>f0 = f1 / f2</code></li>
</ul>
</li>
<li>平方根: <code>fsqrt</code>
<ul>
<li><code>fsqrt.s f0, f1</code> =&gt; <code>$f0 = \sqrt{f1}$</code></li>
</ul>
</li>
</ul>
</li>
<li>比较
<ul>
<li>相等: <code>feq</code>
<ul>
<li><code>feq.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 == f1, else 0</code></li>
</ul>
</li>
<li>小于: <code>flt</code>
<ul>
<li><code>flt.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt; f1, else 0</code></li>
</ul>
</li>
<li>小于或等于: <code>fle</code>
<ul>
<li><code>fle.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt;= f1, else 0</code></li>
</ul>
</li>
<li>如果比较结果为 真，则将整点寄存器设置 1,否则为 0</li>
<li>所以可以使用整数分支指令 <code>beq</code> 和 <code>bne</code> 来比较结果并进行分支</li>
</ul>
</li>
<li>取存指令:
<ul>
<li>双：<code>fld</code> <code>fsd</code>
<ul>
<li><code>fld f0, 8(x5)</code> =&gt; <code>f0 = Memory[x5 + 8]</code></li>
<li><code>fsd f0, 8(x5)</code> =&gt; <code>Memory[x5 +8] = f0</code></li>
</ul>
</li>
<li>单:<code>flw</code> <code>fsw</code></li>
<li>浮点数据传输指令的基址寄存器仍为整点寄存器</li>
<li>在 RISC-V中有独立的浮点寄存器: f0 ~ f31</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述指令都有单双精度版本，单精度以 <code>.s</code> 结尾，双精度以 <code>.d</code> 结尾</p>
</blockquote>
<p>一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中</p>
<pre tabindex="0"><code class="language-ricv-v" data-lang="ricv-v">flw    f0, 0(x10)     // 加载一个 32bit 的数到 f0
flw    f1, 4(x10)     // 加载一个 32bit 的数到 f1
fadd.s f2, f0, f1     // f2 = f0 + f1
fsw    f2, 8(x10)     // 保存来自 f2 的 32bit 的数
</code></pre>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。</p>
<p>例如一些寄存器中所有类型的操作数转换为单一的内部格式。</p>
 </p>
</div>








<h3 id="将一段-c-代码转换成-risc-v-的的汇编代码">将一段 C 代码转换成 RISC-V 的的汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">f2c</span><span class="p">(</span><span class="kt">float</span> <span class="n">qwe</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">retrun</span> <span class="p">((</span><span class="mf">5.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qwe</span> <span class="o">-</span> <span class="mf">32.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设参数 <code>qwe</code> 传入到寄存器 <code>f10</code> 中，且结果也存入 <code>f10</code>中:</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">f2c:
	flw    f0, const5(x3)  // f0 = 5.0f
	flw    f1, const9(x3)  // f1 = 9.0f
	fdiv.s f0, f0, f1      // f0 = 5.0f / 9.0f
	flw    f1, const32(x3) // f1 = 32.0f
	fsub.s f10, f10, f1    // f10 = qwe - 32.0f
	fmul.s f10, f0,  f10   // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); 
	jalr   x0, 0(x1)       // retrun
</code></pre><p>假设通过 <code>x3</code> 访问上面3个常量浮点数</p>
<h3 id="将二维矩阵的c代码转换为risc-v的汇编代码">将二维矩阵的C代码转换为RISC-V的汇编代码</h3>
<figure class="align-center">
    $C=C+A\times{B}$

    
</figure>
<p>假设A, B, C都是 32 x 32 的二维矩阵</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mm</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[][]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	mm:...
		li x28, 32        // x28 = 32
		li x5, 0          // i = 0;
L1:		li x6, 0          // j = 0;
L2:		li x7, 0          // k = 0;
		slli x30, x5, 5   // x30 = i * 2 ^ 5(size of row of c)
		add x30, x30, x6  // x30 = i * size(row) + j
		slli x30, x30, 3  // x30 = byte offset of [i][j] 8个字节,左移3位
		add x30, x10, x30 // x30 = byte address of c[i][j]
		fld f0, 0(x30)    // f0 = 8 bytes of c[i][j]
L3:     slli x29, x7, 5   // x29 = k * 2 ^ 5
		add x29, x29, x6  
		slli x29, x29, 3
		add x29, x12, x29
		fld f1, 0(x29)     // f1 = 8 bytes of b[k][j]
		slli x29,x5 5      // x29 = i * 2 ^ 5
		add x29, x29, x7
		slli x29, x29, 3
		add x29, x11, x29
		fld f2, 0(x29)     // f2 = a[i][k]
		fmul.d f1, f2, f1  // f1 = a[i][k] * b[k][j]
		fadd.d f0, f0 ,f1  // f0 = c[i][j] + a[i][k] * b[k][j]
		addi x7, x7, 1     // k = k + 1
		bltu x7, x28, L3   // if (k &lt; 32) go to L3
		fsd f0, 0(x30)     // c[i][j] = f0
		addi x6, x6, 1     // j = j + 1
		bltu x6, x28, L2   // if (j &lt; 32) go to L2
		addi x5, x5, 1     // i = i + 1
		bltu x5, x28, 1    // if (i &lt; 32) go to L1
</code></pre><h2 id="一些c语言和java的数据类型数据传输指令">一些C语言和Java的数据类型、数据传输指令：</h2>
<p><figure id="a-/images/Pasted%20image%2020221210170829.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210170829.png" alt=""  />
    
</figure></p>
<h3 id="二进制浮点数表示图">二进制浮点数表示图</h3>
<p><figure id="a-/images/Pasted%20image%2020221210194225.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210194225.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
