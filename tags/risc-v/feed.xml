<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>risc-v on fzdwx</title>
    <link>https://fzdwx.github.io/tags/risc-v/</link>
    <description>Recent content in risc-v on fzdwx</description>
    <image>
      <url>https://fzdwx.github.io/images/party_parrot.gif</url>
      <link>https://fzdwx.github.io/images/party_parrot.gif</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx) since 2022</copyright>
    <lastBuildDate>Sat, 10 Dec 2022 20:41:41 +0800</lastBuildDate><atom:link href="https://fzdwx.github.io/tags/risc-v/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RISC-V 简介</title>
      <link>https://fzdwx.github.io/posts/2022-12-10-risc-v/</link>
      <pubDate>Sat, 10 Dec 2022 20:41:41 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-10-risc-v/</guid>
      <description>在汇编语言中没有变量这个概念，汇编语言通常操作的是 寄存器。
TIP 寄存器（Register）是&amp;nbsp;中央处理器 内用来暂存指令、&amp;nbsp;数据 和&amp;nbsp;地址 的&amp;nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&amp;nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&amp;nbsp;计算机程序 的执行。
执行速度非常快，它们内置于CPU中。
RISC-V Card 1. RISC-V 操作数 x0 被硬连接到 0 add x3, x4, x0 =&amp;gt; x3 = x4 (x0 is hard-wired to value 0) 汇编语言 </description>
      <content:encoded><![CDATA[<p>在汇编语言中没有变量这个概念，汇编语言通常操作的是 寄存器。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p><strong>寄存器</strong>（Register）是&nbsp;<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" title="中央处理器" target="_blank" rel="noopener">中央处理器</a>
内用来暂存指令、&nbsp;<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A" title="数据" target="_blank" rel="noopener">数据</a>
和&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80" title="内存地址" target="_blank" rel="noopener">地址</a>
的&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" title="电脑存储器" target="_blank" rel="noopener">电脑存储器</a>
。寄存器的存贮容量有限，读写速度非常快。在&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%9E%B6%E6%A7%8B" title="计算机体系结构" target="_blank" rel="noopener">计算机体系结构</a>
里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F" title="计算机程序" target="_blank" rel="noopener">计算机程序</a>
的执行。</p>
<p>执行速度非常快，它们内置于CPU中。</p>
 </p>
</div>








<h2 id="risc-v-card">RISC-V Card</h2>
<h3 id="1-risc-v-操作数">1. RISC-V 操作数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210211515.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211515.png" alt=""  />
    
</figure></p>
<ul>
<li>x<sub>0</sub> 被硬连接到 0
<ul>
<li><code>add x3, x4, x0</code> =&gt; <code>x3 = x4</code> (x0 is hard-wired to value 0)</li>
</ul>
</li>
</ul>
<h2 id="汇编语言">汇编语言</h2>
<p><figure id="a-/images/Pasted%20image%2020221210211545.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211545.png" alt=""  />
    
</figure><figure id="a-/images/Pasted%20image%2020221210211603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211603.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>浮点数在计算机中的表示</title>
      <link>https://fzdwx.github.io/posts/2022-12-09-float-rep/</link>
      <pubDate>Fri, 09 Dec 2022 19:02:32 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-09-float-rep/</guid>
      <description>表示方法 $(-1)^{S}\times(1.xxx&amp;hellip;x_{2}\times2^{{yyy&amp;hellip;y}_{2}})$ 指数表示Y,尾数表示X 单精度的表示方法 双精度的表示方法 公式:
$(-1)^{S}\times{F}\times{2^{E}}$ F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。 移码表示法 TIP 最理想的表示法是将最小的负指数表示为 00&amp;hellip;002， 将最大的正指数表示为 11&amp;hellip;112。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 IEEE 754规定:
单精度的偏移值为 127 指数为 -1 表示 -1 + 12710 = 12610 = 011111102 +1 = 1 + 12710 = 12810 = 100000002 最大指数为127 最小为-126 双精度的指数偏移值为 1023 1023 -1022 带偏移值的指数意味着一个由浮点数表示的值实际上是:
$(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$ 表示 - 0.7510 分数表示为：
(-3/4)10 = (-3/22)10 二进制小数表示:
(-11/22)10 = -0.112 -11 右移 2 位 用科学计数法表示:</description>
      <content:encoded><![CDATA[<h2 id="表示方法">表示方法</h2>
<figure class="align-center">
    $(-1)^{S}\times(1.xxx&hellip;x_{2}\times2^{{yyy&hellip;y}_{2}})$

    
    <figcaption>
        指数表示Y,尾数表示X
    </figcaption>
    
</figure>
<p><figure id="a-/images/Pasted%20image%2020221209193439.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193439.png" alt="单精度的表示方法"  />
    
    <figcaption>
       单精度的表示方法
    </figcaption>
    
</figure></p>
<p><figure id="a-/images/Pasted%20image%2020221209193511.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193511.png" alt="双精度的表示方法"  />
    
    <figcaption>
       双精度的表示方法
    </figcaption>
    
</figure></p>
<p>公式:</p>
<figure class="align-center">
    $(-1)^{S}\times{F}\times{2^{E}}$

    
    <figcaption>
        F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。
    </figcaption>
    
</figure>
<h2 id="移码表示法">移码表示法</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 最理想的表示法是将最小的负指数表示为 00&hellip;00<sub>2</sub>， 将最大的正指数表示为 11&hellip;11<sub>2</sub>。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 </p>
</div>








<p>IEEE 754规定:</p>
<ol>
<li>单精度的偏移值为 127
<ol>
<li>指数为 -1 表示 -1 + 127<sub>10</sub> = 126<sub>10</sub> = 01111110<sub>2</sub></li>
<li>+1 = 1 + 127<sup>10</sup> = 128<sub>10</sub> = 10000000<sub>2</sub></li>
<li>最大指数为127</li>
<li>最小为-126</li>
</ol>
</li>
<li>双精度的指数偏移值为 1023
<ol>
<li>1023</li>
<li>-1022</li>
</ol>
</li>
</ol>
<p>带偏移值的指数意味着一个由浮点数表示的值实际上是:</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<h3 id="表示---075sub10sub">表示 - 0.75<sub>10</sub></h3>
<p>分数表示为：</p>
<figure class="align-center">
    (-3/4)<sub>10</sub> = (-3/2<sup>2</sup>)<sub>10</sub>

    
</figure>
<p>二进制小数表示:</p>
<figure class="align-center">
    (-11/2<sup>2</sup>)<sub>10</sub> = -0.11<sub>2</sub>

    
    <figcaption>
        -11 右移 2 位
    </figcaption>
    
</figure>
<p>用科学计数法表示:</p>
<figure class="align-center">
    -0.11<sub>2</sub> x 2<sup>0</sup>

    
</figure>
<p>用规格化的科学计数法表示:</p>
<figure class="align-center">
    -1.1<sub>2</sub> x 2<sup>-1</sup>

    
</figure>
<p>由上面的公式的到：</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<ul>
<li>有效位数: 0.1<sub>2</sub></li>
<li>
<ul>
<li>1 = (- 1)<sup>S</sup> =&gt; S = 1<sub>2</sub></li>
</ul>
</li>
<li>指数 - 127 = -1 =&gt; 指数 = 126<sub>10</sub></li>
</ul>
<p>单精度可以表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210142957.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210142957.png" alt=""  />
    
</figure></p>
<p>双精度表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210143322.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143322.png" alt=""  />
    
</figure></p>
<h3 id="表示二进制浮点数为十进制浮点数">表示二进制浮点数为十进制浮点数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210143423.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143423.png" alt=""  />
    
</figure></p>
<ul>
<li>S = 1</li>
<li>有效位数: 0.01<sub>2</sub> =&gt; 1 x 2<sup>-2</sup>（右移两位） = 0.25</li>
<li>指数: 129</li>
</ul>
<p>根据公式:</p>
<p>$(-1)^{1}\times{(1 + 0.25)}\times{2^{129 - 127}}$</p>
<p>= $-1\times1.25\times2^2$</p>
<p>= $-1.25\times4$</p>
<p>= $-5$</p>
<blockquote>
<p>浮点加法与浮点乘法可以看 P&amp;H 3.5.4~3.5.5 &nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf</a>
</p>
</blockquote>
<h2 id="risc-v-中的浮点指令">RISC-V 中的浮点指令</h2>
<ul>
<li>算术
<ul>
<li>加法: <code>fadd.s</code> <code>fadd.d</code>
<ul>
<li><code>fadd.s f0, f1, f2</code> =&gt; <code>f0 = f1 + f2</code></li>
</ul>
</li>
<li>减法：<code>fsub</code> <code>fsub</code>
<ul>
<li><code>fsub.s f0, f1, f2</code> =&gt; <code>f0 = f1 - f2</code></li>
</ul>
</li>
<li>乘法: <code>fmul</code>
<ul>
<li><code>fmul.s f0, f1, f2</code> =&gt; <code>f0 = f1 * f2</code></li>
</ul>
</li>
<li>除法: <code>fdiv</code>
<ul>
<li><code>fdivs f0, f1, f2</code> =&gt; <code>f0 = f1 / f2</code></li>
</ul>
</li>
<li>平方根: <code>fsqrt</code>
<ul>
<li><code>fsqrt.s f0, f1</code> =&gt; <code>$f0 = \sqrt{f1}$</code></li>
</ul>
</li>
</ul>
</li>
<li>比较
<ul>
<li>相等: <code>feq</code>
<ul>
<li><code>feq.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 == f1, else 0</code></li>
</ul>
</li>
<li>小于: <code>flt</code>
<ul>
<li><code>flt.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt; f1, else 0</code></li>
</ul>
</li>
<li>小于或等于: <code>fle</code>
<ul>
<li><code>fle.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt;= f1, else 0</code></li>
</ul>
</li>
<li>如果比较结果为 真，则将整点寄存器设置 1,否则为 0</li>
<li>所以可以使用整数分支指令 <code>beq</code> 和 <code>bne</code> 来比较结果并进行分支</li>
</ul>
</li>
<li>取存指令:
<ul>
<li>双：<code>fld</code> <code>fsd</code>
<ul>
<li><code>fld f0, 8(x5)</code> =&gt; <code>f0 = Memory[x5 + 8]</code></li>
<li><code>fsd f0, 8(x5)</code> =&gt; <code>Memory[x5 +8] = f0</code></li>
</ul>
</li>
<li>单:<code>flw</code> <code>fsw</code></li>
<li>浮点数据传输指令的基址寄存器仍为整点寄存器</li>
<li>在 RISC-V中有独立的浮点寄存器: f0 ~ f31</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述指令都有单双精度版本，单精度以 <code>.s</code> 结尾，双精度以 <code>.d</code> 结尾</p>
</blockquote>
<p>一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中</p>
<pre tabindex="0"><code class="language-ricv-v" data-lang="ricv-v">flw    f0, 0(x10)     // 加载一个 32bit 的数到 f0
flw    f1, 4(x10)     // 加载一个 32bit 的数到 f1
fadd.s f2, f0, f1     // f2 = f0 + f1
fsw    f2, 8(x10)     // 保存来自 f2 的 32bit 的数
</code></pre>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。</p>
<p>例如一些寄存器中所有类型的操作数转换为单一的内部格式。</p>
 </p>
</div>








<h3 id="将一段-c-代码转换成-risc-v-的的汇编代码">将一段 C 代码转换成 RISC-V 的的汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">f2c</span><span class="p">(</span><span class="kt">float</span> <span class="n">qwe</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">retrun</span> <span class="p">((</span><span class="mf">5.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qwe</span> <span class="o">-</span> <span class="mf">32.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设参数 <code>qwe</code> 传入到寄存器 <code>f10</code> 中，且结果也存入 <code>f10</code>中:</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">f2c:
	flw    f0, const5(x3)  // f0 = 5.0f
	flw    f1, const9(x3)  // f1 = 9.0f
	fdiv.s f0, f0, f1      // f0 = 5.0f / 9.0f
	flw    f1, const32(x3) // f1 = 32.0f
	fsub.s f10, f10, f1    // f10 = qwe - 32.0f
	fmul.s f10, f0,  f10   // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); 
	jalr   x0, 0(x1)       // retrun
</code></pre><p>假设通过 <code>x3</code> 访问上面3个常量浮点数</p>
<h3 id="将二维矩阵的c代码转换为risc-v的汇编代码">将二维矩阵的C代码转换为RISC-V的汇编代码</h3>
<figure class="align-center">
    $C=C+A\times{B}$

    
</figure>
<p>假设A, B, C都是 32 x 32 的二维矩阵</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mm</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[][]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	mm:...
		li x28, 32        // x28 = 32
		li x5, 0          // i = 0;
L1:		li x6, 0          // j = 0;
L2:		li x7, 0          // k = 0;
		slli x30, x5, 5   // x30 = i * 2 ^ 5(size of row of c)
		add x30, x30, x6  // x30 = i * size(row) + j
		slli x30, x30, 3  // x30 = byte offset of [i][j] 8个字节,左移3位
		add x30, x10, x30 // x30 = byte address of c[i][j]
		fld f0, 0(x30)    // f0 = 8 bytes of c[i][j]
L3:     slli x29, x7, 5   // x29 = k * 2 ^ 5
		add x29, x29, x6  
		slli x29, x29, 3
		add x29, x12, x29
		fld f1, 0(x29)     // f1 = 8 bytes of b[k][j]
		slli x29,x5 5      // x29 = i * 2 ^ 5
		add x29, x29, x7
		slli x29, x29, 3
		add x29, x11, x29
		fld f2, 0(x29)     // f2 = a[i][k]
		fmul.d f1, f2, f1  // f1 = a[i][k] * b[k][j]
		fadd.d f0, f0 ,f1  // f0 = c[i][j] + a[i][k] * b[k][j]
		addi x7, x7, 1     // k = k + 1
		bltu x7, x28, L3   // if (k &lt; 32) go to L3
		fsd f0, 0(x30)     // c[i][j] = f0
		addi x6, x6, 1     // j = j + 1
		bltu x6, x28, L2   // if (j &lt; 32) go to L2
		addi x5, x5, 1     // i = i + 1
		bltu x5, x28, 1    // if (i &lt; 32) go to L1
</code></pre><h2 id="一些c语言和java的数据类型数据传输指令">一些C语言和Java的数据类型、数据传输指令：</h2>
<p><figure id="a-/images/Pasted%20image%2020221210170829.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210170829.png" alt=""  />
    
</figure></p>
<h3 id="二进制浮点数表示图">二进制浮点数表示图</h3>
<p><figure id="a-/images/Pasted%20image%2020221210194225.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210194225.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
