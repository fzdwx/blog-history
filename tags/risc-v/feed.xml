<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>risc-v on fzdwx</title>
    <link>https://fzdwx.github.io/tags/risc-v/</link>
    <description>Recent content in risc-v on fzdwx</description>
    <image>
      <url>https://fzdwx.github.io/images/party_parrot.gif</url>
      <link>https://fzdwx.github.io/images/party_parrot.gif</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx) since 2022</copyright>
    <lastBuildDate>Sat, 10 Dec 2022 20:41:41 +0800</lastBuildDate><atom:link href="https://fzdwx.github.io/tags/risc-v/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RISC-V 简介</title>
      <link>https://fzdwx.github.io/posts/2022-12-10-risc-v/</link>
      <pubDate>Sat, 10 Dec 2022 20:41:41 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-10-risc-v/</guid>
      <description>Resource &amp;nbsp;RISC-V Green Card &amp;nbsp;RISC-V Call convertion &amp;nbsp;P&amp;amp;H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。
TIP 寄存器（Register）是&amp;nbsp;中央处理器 内用来暂存指令、&amp;nbsp;数据 和&amp;nbsp;地址 的&amp;nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&amp;nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&amp;nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 =&amp;gt; x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。
ld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。</description>
      <content:encoded><![CDATA[<h2 id="resource">Resource</h2>
<ol>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf" target="_blank" rel="noopener">RISC-V Green Card</a>
</li>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/RISCV_Calling_Convention.pdf" target="_blank" rel="noopener">RISC-V Call convertion</a>
</li>
<li>&nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">P&amp;H(RISC-V)</a>
</li>
</ol>
<p>在汇编语言中没有变量这个概念，汇编语言通常操作的是<strong>寄存器</strong>。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <strong>寄存器</strong>（Register）是&nbsp;<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" title="中央处理器" target="_blank" rel="noopener">中央处理器</a>
内用来暂存指令、&nbsp;<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A" title="数据" target="_blank" rel="noopener">数据</a>
和&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80" title="内存地址" target="_blank" rel="noopener">地址</a>
的&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" title="电脑存储器" target="_blank" rel="noopener">电脑存储器</a>
。寄存器的存贮容量有限，读写速度非常快。在&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%9E%B6%E6%A7%8B" title="计算机体系结构" target="_blank" rel="noopener">计算机体系结构</a>
里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F" title="计算机程序" target="_blank" rel="noopener">计算机程序</a>
的执行。 </p>
</div>








<h2 id="risc-v-card">RISC-V Card</h2>
<h3 id="risc-v-操作数">RISC-V 操作数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210211515.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211515.png" alt=""  />
    
</figure></p>
<ul>
<li>如果寄存器的大小是 64位 则称为<strong>双字</strong>，32位 则是<strong>单字</strong>。</li>
<li>x<sub>0</sub> 被硬连接到 0
<ul>
<li><code>add x3, x4, x0</code> =&gt; <code>x3 = x4</code> (x0 is hard-wired to value 0)</li>
</ul>
</li>
</ul>
<h2 id="汇编指令">汇编指令</h2>
<p><figure id="a-/images/Pasted%20image%2020221210211545.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211545.png" alt=""  />
    
</figure><figure id="a-/images/Pasted%20image%2020221210211603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211603.png" alt=""  />
    
</figure></p>
<h2 id="存储操作数">存储操作数</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 将数据从内存复制到寄存器的数据传输指令称为 <em>载入指令(<code>load</code>)</em>。在 RISC-V 中指令是 <strong>ld</strong>,表示取双字。 </p>
</div>








<h3 id="一个从数组中取值的c程序写出汇编代码">一个从数组中取值的C程序，写出汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或<em>基址</em>位于 x22 中。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">ld x9, 8(x22) // x9 = A[8]
add x21, x20, x9; // x21 = x20 + x9
</code></pre><p>存放基址的寄存器(x22)被称为<em>基址寄存器</em>, 数据传输指令中的 8 称为<em>偏移量</em>。</p>
<p><figure id="a-/images/Pasted%20image%2020221212130603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212130603.png" alt="实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数"  />
    
    <figcaption>
       实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数
    </figcaption>
    
</figure></p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        大端与小端编址
        
    </p>
    <p> <p>计算机分为两种，一种使用最左边或“大端”字节的地址作为双字地址，另一种使用最右端或“小端”字节的地址作为双字地址。</p>
<p>RISC-V 使用小端  。由于仅在以双字形式和 8 个单独字节访问相同数据时，字节顺序才有影响，因此大多情况不需要关系“大小端”。</p>
 </p>
</div>








<p>所以为了上面的代码获得正确的字节地址加到 x22 这个寄存器的偏移量为 64（8x8）。</p>
<p>与载入指令相反的指令通常被成为<em>存储指令(store)</em>,从寄存器复制数据到内存。指令是<code>sd</code>,表示存储双字。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 在一些体系结构中，字的起始地址必须是 4 的倍数，双字的起始地址必须是 8 的倍数。该要求成为<em>对齐限制</em> </p>
</div>








<p>RISC-V 和 Intel x86 没有对齐限制，但 MIPS 有这个限制。</p>
<p><figure id="a-/images/Pasted%20image%2020221212152022.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212152022.png" alt=""  />
    
</figure></p>
<h3 id="使用-load-和-store-编译生成指令">使用 load 和 store 编译生成指令</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>h 存放在 x21 中，A 的基址存放在 x22 中。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">ld x9, 64(x22)  // x9 = A[8]
add x9, x21, x9 // x9 = h + A[8]
sd x9, 96(x22)  // A[12] = x9
</code></pre><h3 id="将字符串复制程序编译为汇编">将字符串复制程序编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">[],</span><span class="kt">char</span> <span class="n">y</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>x, y 的基址存放在 x10 和 x11 中， i 存放在 x19 中。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">strcpy:
	addi sp, sp, -8  // 调整栈指针，以存放一个item(x19)
	sd x19, 0(sp)    // x19 入栈
	add x19, x0, x0  // x19 = 0 + 0
L1: add x5, x19, x11 // x5 = x19 + x11 =&gt; address of y[i] in x5
	lbu x6, 0(x5)    // temp: x6 = y[i]
	add x7, x19, x10 // x5 = x19 + x11 =&gt; address of x[i] in x7
	sd  x6, 0(x7)    // x[i] = y[i]
	beq x6, x0, L2   // if x6 ==0 then go to L2
	addi x19, x19, 1 // i = i  + 1
	jal x0, L1       // go to L1
L2: ld x19, 0(sp)    // 恢复 x19 以及栈指针
	addi sp, sp, 8 
	jalr x0, 0(x1)
</code></pre><h3 id="一段循环代码编译为汇编">一段循环代码编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span>  <span class="mi">3</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>RISC-V 汇编（32 bit)</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	add x9, x8, x0     # x9 = &amp;A[0]
	add x10, x0, x0    # sum
	add x11, x0, x0    # i
	addi x13,x0, 20    # 20
Loop:
	bge x11, x13, Done # if x11 &gt; x13 go to Down(end loop)
	lw x12, 0(x9)      # x12 = A[i]
	add x10, x10, x12  # sum
	addi x9, x9, 4     # x9 = &amp;A[i+1]
	addi x11, x11, 1   # i++
	j loop
Done:
</code></pre><h2 id="逻辑操作">逻辑操作</h2>
<ul>
<li><code>and</code> <code>andi</code>
<ul>
<li><code>and x5, x6, x9</code> =&gt; x5 = x6 &amp; x9</li>
<li><code>addi x5, x6, 3</code> =&gt; x5 = x6 &amp; 3</li>
</ul>
</li>
<li><code>sll</code> <code>ssli</code> , 左移(扩大)
<ul>
<li><code>slli x11, x23, 2</code> =&gt; x11 = x23 &laquo; 2</li>
<li>0000 0010  =&gt; 2</li>
<li>0000 1000 =&gt; 8</li>
</ul>
</li>
<li><code>srl</code> <code>srli</code> , 右移（缩小)
<ul>
<li><code>srli x23, x11, 2</code> = &gt; x23 = x11 &raquo; 2</li>
<li>0000 1000 =&gt; 8</li>
<li>0000 0010 =&gt; 2</li>
</ul>
</li>
<li><code>sra</code> <code>srai</code>, 算数右移
<ul>
<li>1111 1111 1111 1111 1111 1111 1110 0111 = -25</li>
<li><code>srai x10, x10, 4</code></li>
<li>1111 1111 1111 1111 1111 1111 1111 1110 = -2</li>
</ul>
</li>
</ul>
<h2 id="helpful-risc-v-assmebler-features">Helpful RISC-V Assmebler Features</h2>
<ol>
<li>a0 - a7 是参数寄存器(x10 - x17，用于函数调用。</li>
<li>zero 代表 x0</li>
<li><code>mv rd, rs = addi rd, rs, 0</code></li>
<li><code>li rd, 13 = addi rd, x0, 13</code></li>
<li><code>nop = addi x0, x0</code></li>
<li>a0 - a7(x10 - x17): 8 个寄存器用于参数传递以及两个返回值(a0 - a1)</li>
<li>ra（x1）: 一个返回 address 的寄存器，用于返回原点（调用的位置）</li>
<li>s0 - s1(x8 - x9) and s2 - s11 (s18 - x27): 保存的寄存器</li>
</ol>
<h2 id="risc-v-函数调用的转换">RISC-V 函数调用的转换</h2>
<ol>
<li>寄存器比内存快，所以使用它们</li>
<li><code>jal rd, Label</code> 跳转和链接
<ol>
<li><code>jal x1, 100</code></li>
</ol>
</li>
<li><code>jalr rd, rs, imm</code> 跳转和链接寄存器
<ol>
<li><code>jalr x1, 100(x5)</code></li>
</ol>
</li>
<li><code>jal Lable</code> =&gt; <code>jal ra, Lable</code> 调用函数</li>
</ol>
<h3 id="一段函数调用转换为汇编">一段函数调用转换为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">1000 mv a0, s0              # x = a
1004 mv a1, s1              # y= b
1008 addi ra, zero, 1016    # 1016 is sum function
1012 j                      # jump to sum
1016 ... 
...
2000 sum: add a0, a0, a1
2004 jr ra
</code></pre><p>1008 ~ 1012 可以使用 <code>jal sum</code> 来替代、</p>
<h3 id="调用函数的基本步骤">调用函数的基本步骤</h3>
<ol>
<li>把需要的参数放到方法可以访问的地方（寄存器）</li>
<li>转移控制权给函数,使用(<code>jal</code>)
<ol>
<li>保持地址，并跳转到函数的地址</li>
</ol>
</li>
<li>获取函数执行所需的(local)存储资源</li>
<li>执行预期的函数</li>
<li>将返回值放在调用代码可以访问的地方，并恢复我们使用到的寄存器，释放本地存储</li>
<li>将控制器返回给主处理器（<code>ret</code>), 使用存储在寄存器中的地址，返回到调用它的地方</li>
</ol>
<h3 id="方法调用示例">方法调用示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>g,h,i,j in a0,a1,a2,a3</li>
<li>f in s0</li>
<li>temp is s1</li>
</ol>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">leaf:
	# prologue start
	addi sp, sp, -8   # 腾出 8byte 来存放的2个整数
	sw s1, 4(sp)      # 保存 s1, s0 到 sp 中
	sw s0, 0(sp)
	# prologue end
	add s0, a0, a1    # f = g + h
	add s1, a2, a3    # temp = i + j
	sub a0, s0, s1    # a0 = （g + h) - (i + j) 

	# epilogue
	lw s0, 0(sp)      # 恢复 s1, s0
	lw s1, 4(sp)    
	addi sp, sp 8 

	jr ra
</code></pre><h2 id="sp">sp</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>sp 是栈指针，从内存空间 的最顶部开始向下增长，在 RISC-V 中使用 x2 这个寄存器。</p>
<ol>
<li>push 是减少 sp 的指针地址</li>
<li>pop 是增加</li>
</ol>
 </p>
</div>








<p>每个函数都有一组存放在栈上的数据，它们是<strong>栈帧</strong>（stack frame ），栈帧通常包含：</p>
<ol>
<li>返回地址</li>
<li>参数</li>
<li>使用的局部变量的空间</li>
</ol>
<h2 id="嵌套函数调用">嵌套函数调用</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sumSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 ra 中有一个 sumSquare 想要跳回的值，但是这个值会被调用 mult 覆盖。</p>
<ol>
<li>caller: 调用函数的人</li>
<li>calle： 被调用的函数</li>
<li>当被调用者从执行中返回时，调用者需要知道哪些寄存器可能发生了变化，哪些寄存器被保证是不变的。</li>
<li>寄存器规定： 即哪些寄存器在程序调用(<code>jal</code>) 后将被取消缓存 ，哪些可以被改变。
<ol>
<li>即有一些寄存器是易失的(temp),一些是要保存的（<strong>调用者需要恢复它们原来的值</strong>）。</li>
<li>这优化了每次进入栈帧的寄存器的数量</li>
</ol>
</li>
<li>分类:
<ol>
<li>跨函数调用保留:
<ol>
<li>sp, gp, tp</li>
<li>s0 - s11 (s0 is also fp)</li>
</ol>
</li>
<li>不保留:
<ol>
<li>参数寄存器以及返回寄存器： a0 - a7, ra</li>
<li>temp 寄存器: t0 - t6</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>上面代码的 RISC-V</p>
<p>x in a1, y in a1</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">sumSquare:
	addi sp, sp -8
	sw ra, 4(sp)             // save retrun address to sp
	sw a1, 0(sp)             // save s1 to y
	mv a1, a0                // y = x =&gt; mult(x,x)
	jal mult                 // call mult
	lw a1, 0(sp)             // get y from sp
	add a0, a0, a1           // mult() + y
	lw ra, 4(sp)             // get retrun address from sp
	addi sp, sp, 8
	jr ra
	
</code></pre><h2 id="risc-v-寄存器名称">RISC-V 寄存器名称</h2>
<p><figure id="a-/images/Pasted%20image%2020221213192858.png" class="align-center">
    <img src="/images/Pasted%20image%2020221213192858.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>浮点数在计算机中的表示</title>
      <link>https://fzdwx.github.io/posts/2022-12-09-float-rep/</link>
      <pubDate>Fri, 09 Dec 2022 19:02:32 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-09-float-rep/</guid>
      <description>表示方法 $(-1)^{S}\times(1.xxx&amp;hellip;x_{2}\times2^{{yyy&amp;hellip;y}_{2}})$ 指数表示Y,尾数表示X 单精度的表示方法 双精度的表示方法 公式:
$(-1)^{S}\times{F}\times{2^{E}}$ F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。 移码表示法 TIP 最理想的表示法是将最小的负指数表示为 00&amp;hellip;002， 将最大的正指数表示为 11&amp;hellip;112。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 IEEE 754规定:
单精度的偏移值为 127 指数为 -1 表示 -1 + 12710 = 12610 = 011111102 +1 = 1 + 12710 = 12810 = 100000002 最大指数为127 最小为-126 双精度的指数偏移值为 1023 1023 -1022 带偏移值的指数意味着一个由浮点数表示的值实际上是:
$(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$ 表示 - 0.7510 分数表示为：
(-3/4)10 = (-3/22)10 二进制小数表示:
(-11/22)10 = -0.112 -11 右移 2 位 用科学计数法表示:</description>
      <content:encoded><![CDATA[<h2 id="表示方法">表示方法</h2>
<figure class="align-center">
    $(-1)^{S}\times(1.xxx&hellip;x_{2}\times2^{{yyy&hellip;y}_{2}})$

    
    <figcaption>
        指数表示Y,尾数表示X
    </figcaption>
    
</figure>
<p><figure id="a-/images/Pasted%20image%2020221209193439.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193439.png" alt="单精度的表示方法"  />
    
    <figcaption>
       单精度的表示方法
    </figcaption>
    
</figure></p>
<p><figure id="a-/images/Pasted%20image%2020221209193511.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193511.png" alt="双精度的表示方法"  />
    
    <figcaption>
       双精度的表示方法
    </figcaption>
    
</figure></p>
<p>公式:</p>
<figure class="align-center">
    $(-1)^{S}\times{F}\times{2^{E}}$

    
    <figcaption>
        F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。
    </figcaption>
    
</figure>
<h2 id="移码表示法">移码表示法</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 最理想的表示法是将最小的负指数表示为 00&hellip;00<sub>2</sub>， 将最大的正指数表示为 11&hellip;11<sub>2</sub>。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 </p>
</div>








<p>IEEE 754规定:</p>
<ol>
<li>单精度的偏移值为 127
<ol>
<li>指数为 -1 表示 -1 + 127<sub>10</sub> = 126<sub>10</sub> = 01111110<sub>2</sub></li>
<li>+1 = 1 + 127<sup>10</sup> = 128<sub>10</sub> = 10000000<sub>2</sub></li>
<li>最大指数为127</li>
<li>最小为-126</li>
</ol>
</li>
<li>双精度的指数偏移值为 1023
<ol>
<li>1023</li>
<li>-1022</li>
</ol>
</li>
</ol>
<p>带偏移值的指数意味着一个由浮点数表示的值实际上是:</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<h3 id="表示---075sub10sub">表示 - 0.75<sub>10</sub></h3>
<p>分数表示为：</p>
<figure class="align-center">
    (-3/4)<sub>10</sub> = (-3/2<sup>2</sup>)<sub>10</sub>

    
</figure>
<p>二进制小数表示:</p>
<figure class="align-center">
    (-11/2<sup>2</sup>)<sub>10</sub> = -0.11<sub>2</sub>

    
    <figcaption>
        -11 右移 2 位
    </figcaption>
    
</figure>
<p>用科学计数法表示:</p>
<figure class="align-center">
    -0.11<sub>2</sub> x 2<sup>0</sup>

    
</figure>
<p>用规格化的科学计数法表示:</p>
<figure class="align-center">
    -1.1<sub>2</sub> x 2<sup>-1</sup>

    
</figure>
<p>由上面的公式的到：</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<ul>
<li>有效位数: 0.1<sub>2</sub></li>
<li>
<ul>
<li>1 = (- 1)<sup>S</sup> =&gt; S = 1<sub>2</sub></li>
</ul>
</li>
<li>指数 - 127 = -1 =&gt; 指数 = 126<sub>10</sub></li>
</ul>
<p>单精度可以表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210142957.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210142957.png" alt=""  />
    
</figure></p>
<p>双精度表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210143322.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143322.png" alt=""  />
    
</figure></p>
<h3 id="表示二进制浮点数为十进制浮点数">表示二进制浮点数为十进制浮点数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210143423.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143423.png" alt=""  />
    
</figure></p>
<ul>
<li>S = 1</li>
<li>有效位数: 0.01<sub>2</sub> =&gt; 1 x 2<sup>-2</sup>（右移两位） = 0.25</li>
<li>指数: 129</li>
</ul>
<p>根据公式:</p>
<p>$(-1)^{1}\times{(1 + 0.25)}\times{2^{129 - 127}}$</p>
<p>= $-1\times1.25\times2^2$</p>
<p>= $-1.25\times4$</p>
<p>= $-5$</p>
<blockquote>
<p>浮点加法与浮点乘法可以看 P&amp;H 3.5.4~3.5.5 &nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf</a>
</p>
</blockquote>
<h2 id="risc-v-中的浮点指令">RISC-V 中的浮点指令</h2>
<ul>
<li>算术
<ul>
<li>加法: <code>fadd.s</code> <code>fadd.d</code>
<ul>
<li><code>fadd.s f0, f1, f2</code> =&gt; <code>f0 = f1 + f2</code></li>
</ul>
</li>
<li>减法：<code>fsub</code> <code>fsub</code>
<ul>
<li><code>fsub.s f0, f1, f2</code> =&gt; <code>f0 = f1 - f2</code></li>
</ul>
</li>
<li>乘法: <code>fmul</code>
<ul>
<li><code>fmul.s f0, f1, f2</code> =&gt; <code>f0 = f1 * f2</code></li>
</ul>
</li>
<li>除法: <code>fdiv</code>
<ul>
<li><code>fdivs f0, f1, f2</code> =&gt; <code>f0 = f1 / f2</code></li>
</ul>
</li>
<li>平方根: <code>fsqrt</code>
<ul>
<li><code>fsqrt.s f0, f1</code> =&gt; <code>$f0 = \sqrt{f1}$</code></li>
</ul>
</li>
</ul>
</li>
<li>比较
<ul>
<li>相等: <code>feq</code>
<ul>
<li><code>feq.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 == f1, else 0</code></li>
</ul>
</li>
<li>小于: <code>flt</code>
<ul>
<li><code>flt.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt; f1, else 0</code></li>
</ul>
</li>
<li>小于或等于: <code>fle</code>
<ul>
<li><code>fle.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt;= f1, else 0</code></li>
</ul>
</li>
<li>如果比较结果为 真，则将整点寄存器设置 1,否则为 0</li>
<li>所以可以使用整数分支指令 <code>beq</code> 和 <code>bne</code> 来比较结果并进行分支</li>
</ul>
</li>
<li>取存指令:
<ul>
<li>双：<code>fld</code> <code>fsd</code>
<ul>
<li><code>fld f0, 8(x5)</code> =&gt; <code>f0 = Memory[x5 + 8]</code></li>
<li><code>fsd f0, 8(x5)</code> =&gt; <code>Memory[x5 +8] = f0</code></li>
</ul>
</li>
<li>单:<code>flw</code> <code>fsw</code></li>
<li>浮点数据传输指令的基址寄存器仍为整点寄存器</li>
<li>在 RISC-V中有独立的浮点寄存器: f0 ~ f31</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述指令都有单双精度版本，单精度以 <code>.s</code> 结尾，双精度以 <code>.d</code> 结尾</p>
</blockquote>
<p>一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中</p>
<pre tabindex="0"><code class="language-ricv-v" data-lang="ricv-v">flw    f0, 0(x10)     // 加载一个 32bit 的数到 f0
flw    f1, 4(x10)     // 加载一个 32bit 的数到 f1
fadd.s f2, f0, f1     // f2 = f0 + f1
fsw    f2, 8(x10)     // 保存来自 f2 的 32bit 的数
</code></pre>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。</p>
<p>例如一些寄存器中所有类型的操作数转换为单一的内部格式。</p>
 </p>
</div>








<h3 id="将一段-c-代码转换成-risc-v-的的汇编代码">将一段 C 代码转换成 RISC-V 的的汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">f2c</span><span class="p">(</span><span class="kt">float</span> <span class="n">qwe</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">retrun</span> <span class="p">((</span><span class="mf">5.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qwe</span> <span class="o">-</span> <span class="mf">32.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设参数 <code>qwe</code> 传入到寄存器 <code>f10</code> 中，且结果也存入 <code>f10</code>中:</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">f2c:
	flw    f0, const5(x3)  // f0 = 5.0f
	flw    f1, const9(x3)  // f1 = 9.0f
	fdiv.s f0, f0, f1      // f0 = 5.0f / 9.0f
	flw    f1, const32(x3) // f1 = 32.0f
	fsub.s f10, f10, f1    // f10 = qwe - 32.0f
	fmul.s f10, f0,  f10   // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); 
	jalr   x0, 0(x1)       // retrun
</code></pre><p>假设通过 <code>x3</code> 访问上面3个常量浮点数</p>
<h3 id="将二维矩阵的c代码转换为risc-v的汇编代码">将二维矩阵的C代码转换为RISC-V的汇编代码</h3>
<figure class="align-center">
    $C=C+A\times{B}$

    
</figure>
<p>假设A, B, C都是 32 x 32 的二维矩阵</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mm</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[][]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	mm:...
		li x28, 32        // x28 = 32
		li x5, 0          // i = 0;
L1:		li x6, 0          // j = 0;
L2:		li x7, 0          // k = 0;
		slli x30, x5, 5   // x30 = i * 2 ^ 5(size of row of c)
		add x30, x30, x6  // x30 = i * size(row) + j
		slli x30, x30, 3  // x30 = byte offset of [i][j] 8个字节,左移3位
		add x30, x10, x30 // x30 = byte address of c[i][j]
		fld f0, 0(x30)    // f0 = 8 bytes of c[i][j]
L3:     slli x29, x7, 5   // x29 = k * 2 ^ 5
		add x29, x29, x6  
		slli x29, x29, 3
		add x29, x12, x29
		fld f1, 0(x29)     // f1 = 8 bytes of b[k][j]
		slli x29,x5 5      // x29 = i * 2 ^ 5
		add x29, x29, x7
		slli x29, x29, 3
		add x29, x11, x29
		fld f2, 0(x29)     // f2 = a[i][k]
		fmul.d f1, f2, f1  // f1 = a[i][k] * b[k][j]
		fadd.d f0, f0 ,f1  // f0 = c[i][j] + a[i][k] * b[k][j]
		addi x7, x7, 1     // k = k + 1
		bltu x7, x28, L3   // if (k &lt; 32) go to L3
		fsd f0, 0(x30)     // c[i][j] = f0
		addi x6, x6, 1     // j = j + 1
		bltu x6, x28, L2   // if (j &lt; 32) go to L2
		addi x5, x5, 1     // i = i + 1
		bltu x5, x28, 1    // if (i &lt; 32) go to L1
</code></pre><h2 id="一些c语言和java的数据类型数据传输指令">一些C语言和Java的数据类型、数据传输指令：</h2>
<p><figure id="a-/images/Pasted%20image%2020221210170829.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210170829.png" alt=""  />
    
</figure></p>
<h3 id="二进制浮点数表示图">二进制浮点数表示图</h3>
<p><figure id="a-/images/Pasted%20image%2020221210194225.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210194225.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
