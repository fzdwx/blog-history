<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>note on fzdwx</title>
    <link>https://fzdwx.github.io/tags/note/</link>
    <description>Recent content in note on fzdwx</description>
    <image>
      <url>https://fzdwx.github.io/images/party_parrot.gif</url>
      <link>https://fzdwx.github.io/images/party_parrot.gif</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx) since 2022</copyright>
    <lastBuildDate>Fri, 30 Dec 2022 13:54:36 +0800</lastBuildDate><atom:link href="https://fzdwx.github.io/tags/note/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统的特权级机制</title>
      <link>https://fzdwx.github.io/posts/2022-12-30-os-privilege/</link>
      <pubDate>Fri, 30 Dec 2022 13:54:36 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-30-os-privilege/</guid>
      <description>应用程序会不可避免的出现错误，如果一个程序出现错误会导致其他程序或操作系统都无法运行那就是不可接受的。
所以人们提出特权级（Privilege）这一保护计算机系统不受有意或无意出错的程序破坏的机制，它让应用程序运行在用户态 ，而操作系统运行在内核态，并且实现用户态和内核态的隔离。
一个支持顺序执行多个应用程序的操作系统结构图 主要通过 RustSBI 完成基本的硬件初始化后，跳转到操作系统的起始位置，操作系统然后建立栈空间并情况 bss 段（置0），然后通过 AppManager 从 app 列表中一次加载各个 app 到指定的内存在用户态执行。app 在执行时，会通过系统调用的方式得到操作系统提供的功能，比如输出字符串。
特权级的软硬件协同设计 实现特权级机制的根本原因是应用程运行的安全性不可充分信任 。所以，计算机科学家和工程师想到了一个方法：让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受到程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。
应用程序不能访问任意的地址空间 应用程序不能执行某些可能破坏计算机系统的指令 同时为了应用程序能获得操作系统的服务——应用程序和操作系统还需要有交互的手段。
低特权级的软件只能做高特权级允许它做的操作 超出低特权级能力的功能必须寻求高特权级的帮助 这样高特权级(操作系统)就成为低特权级（一般应用）的执行环境的总要组成部分。
为了实现这样的特权级机制，需要进行软硬件协同设计。一种简介的方式是： 处理器设置两个不同安全等级的执行环境，* 用户态特权级的执行环境和内核态特权级的执行环境*。
明确指出可能破坏计算机系统的内核态特权指令集子集 规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行 处理器在执行指令前会进行特权级安全检查，如果在用户态环境中执行内核态特权级指令就会产生异常 传统的call和ret指令组合会直接绕过硬件的特权级保护检查，所以需要新的指令：
ecall： 执行环境调用，具有用户态到内核态的执行环境切换能力的函数调用指令 从当前特权级切换到比当前高一级 eret： 执行环境返回，基友内核态到用户态的执行环境切换能力的函数返回指令 切换到不高于当前特权级 硬件有了这样的机制之后，还需要操作系统的配合才能完成对操作系统自身的保护。
操作系统需要提供能在执行eret前准备和恢复用户态执行应用程序的上下文 在用户程序调用ecall后能检查应用程序的系统调用参数，确保参数不会破坏操作系统 RISC-V 特权级架构 级别 编码 名称 0 00 用户/应用模式 (U,User/Application) 1 01 监督模式 (S,Supervisor) 2 10 虚拟监督模式 (H,Hypervisor) 3 11 机器模式 (M,Machine) 级别数值越大则特权级越高，掌控硬件的能力越强。即 M 最强，U 最弱，在 CPU 层面只有 M 是必须的。</description>
      <content:encoded><![CDATA[<p>应用程序会不可避免的出现错误，如果一个程序出现错误会导致其他程序或操作系统都无法运行那就是不可接受的。</p>
<p>所以人们提出<em>特权级</em>（Privilege）这一保护计算机系统不受有意或无意出错的程序破坏的机制，它让应用程序运行在<strong>用户态</strong>
，而操作系统运行在<strong>内核态</strong>，并且实现用户态和内核态的隔离。</p>
<p><figure id="a-/images/Pasted%20image%2020221230141140.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230141140.png" alt="一个支持顺序执行多个应用程序的操作系统结构图"  />
    
    <figcaption>
       一个支持顺序执行多个应用程序的操作系统结构图
    </figcaption>
    
</figure></p>
<p>主要通过 RustSBI 完成基本的硬件初始化后，跳转到操作系统的起始位置，操作系统然后建立栈空间并情况 bss 段（置0），然后通过
AppManager 从 app 列表中一次加载各个 app 到指定的内存在用户态执行。app 在执行时，会通过系统调用的方式得到操作系统提供的功能，比如输出字符串。</p>
<h2 id="特权级的软硬件协同设计">特权级的软硬件协同设计</h2>
<p>实现特权级机制的根本原因是<strong>应用程运行的安全性不可充分信任</strong>
。所以，计算机科学家和工程师想到了一个方法：让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受到程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。</p>
<ul>
<li>应用程序不能访问任意的地址空间</li>
<li>应用程序不能执行某些可能破坏计算机系统的指令</li>
</ul>
<p>同时为了应用程序能获得操作系统的服务——应用程序和操作系统还需要有交互的手段。</p>
<ul>
<li>低特权级的软件只能做高特权级允许它做的操作</li>
<li>超出低特权级能力的功能必须寻求高特权级的帮助</li>
</ul>
<p>这样<strong>高特权级</strong>(操作系统)就成为<strong>低特权级</strong>（一般应用）的<strong>执行环境的总要组成部分</strong>。</p>
<p>为了实现这样的特权级机制，需要进行软硬件协同设计。一种简介的方式是： 处理器设置两个不同安全等级的执行环境，*
<em>用户态特权级的执行环境和内核态特权级的执行环境</em>*。</p>
<ul>
<li>明确指出可能破坏计算机系统的内核态特权指令集子集</li>
<li>规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行</li>
<li>处理器在执行指令前会进行特权级安全检查，如果在用户态环境中执行内核态特权级指令就会产生异常</li>
</ul>
<p>传统的<code>call</code>和<code>ret</code>指令组合会直接绕过硬件的特权级保护检查，所以需要新的指令：</p>
<ul>
<li><code>ecall</code>： 执行环境调用，具有<strong>用户态</strong>到<strong>内核态</strong>的执行环境切换能力的<strong>函数调用</strong>指令
<ul>
<li>从当前特权级切换到比当前高一级</li>
</ul>
</li>
<li><code>eret</code>： 执行环境返回，基友<strong>内核态</strong>到<strong>用户态</strong>的执行环境切换能力的<strong>函数返回</strong>指令
<ul>
<li>切换到不高于当前特权级</li>
</ul>
</li>
</ul>
<p>硬件有了这样的机制之后，还需要操作系统的配合才能完成对操作系统自身的保护。</p>
<ol>
<li>操作系统需要提供能在执行<code>eret</code>前<strong>准备和恢复用户态执行应用程序的上下文</strong></li>
<li>在用户程序调用<code>ecall</code>后能<strong>检查应用程序的系统调用参数</strong>，确保参数不会破坏操作系统</li>
</ol>
<h2 id="risc-v-特权级架构">RISC-V 特权级架构</h2>
<table>
<thead>
<tr>
<th>级别</th>
<th>编码</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>00</td>
<td>用户/应用模式 (U,User/Application)</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S,Supervisor)</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>虚拟监督模式 (H,Hypervisor)</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M,Machine)</td>
</tr>
</tbody>
</table>
<p>级别数值越大则特权级越高，掌控硬件的能力越强。即 M 最强，U 最弱，在 CPU 层面只有 M 是必须的。</p>
<p><figure id="a-/images/Pasted%20image%2020221230152533.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230152533.png" alt="在特权级架构的角度看待一套支持应用程序运行的执行环境"  />
    
    <figcaption>
       在特权级架构的角度看待一套支持应用程序运行的执行环境
    </figcaption>
    
</figure></p>
<p>白色表示执行环境，黑色表示相邻两层执行环境之间的接口。SSE 代表<strong>监督模式执行环境</strong>，例如 RustSBI。</p>
<p>按需实现 RISC-V 特权级：</p>
<ol>
<li>简单的嵌入式应用只需实现 M</li>
<li>带有一定保护能力的嵌入式系统需要实现 M、U</li>
<li>复杂的多任务系统需要实现 M、S、U</li>
</ol>
<h3 id="操作系统异常控制流">操作系统异常控制流</h3>
<ol>
<li>中断： 由外部设备引起的外部 I/O 时间如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。</li>
<li>异常： 处理器执行指令期间检测到不正常的或非法的内部事件(如除零、数组越界等)</li>
<li>陷入: 程序在执行过程中通过系统调用请求操作系统服务时而有意引发的事件</li>
</ol>
<p>要处理上面的异常，都需要操作系统保存与恢复被 打断/陷入 前应用程序的控制流上下文。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>控制流上下文： 确保下一刻能继续正确执行控制流指令的物理资源，也可称为控制流所在执行环境的状态。</p>
<p>这里的物理资源即计算机硬件资源，如 CPU 的寄存器、内存等。</p>
 </p>
</div>








<p><strong>执行环境</strong>的另一种功能是对<strong>上层软件</strong>的执行进行监管管理： 当<strong>上层软件</strong>执行出现了异常或特殊情况，导致需要用到<strong>执行环境
<strong>中提供的功能，因此需要暂停</strong>上层软件</strong>的执行，转而运行<strong>执行环境</strong>的代码。</p>
<p>而<strong>上层软件</strong>和<strong>执行环境</strong>的<strong>特权等级</strong>往往不同，所以这个过程可能(大部分情况下)会有 CPU 的<strong>特权级切换</strong>。当<strong>执行环境
<strong>的代码运行结束后，我们就需要回到</strong>上层软件</strong>暂停的位置<strong>继续执行</strong>。在 RISC-V 中，这种异常控制流被称为<strong>异常</strong>，是 RISC-V
中的 <strong>trap</strong> 的一种。</p>
<p>用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：</p>
<ol>
<li>用户态软件为获得内核态操作系统的服务功能而执行特殊指令</li>
<li>在执行某条指令出现了错误(如执行了用户态不允许执行的指令)并被 CPU 检测到</li>
</ol>
<table>
<thead>
<tr>
<th>interrupt</th>
<th>exception code</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Instruction address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Instruction access fault</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>Illegal instruction</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>Breakpoint</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Load address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td>Load access fault</td>
</tr>
<tr>
<td>0</td>
<td>6</td>
<td>Store/AMO address misaligned</td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td>Store/AMO access fault</td>
</tr>
<tr>
<td>0</td>
<td>8</td>
<td>Environment call from U-mode</td>
</tr>
<tr>
<td>0</td>
<td>9</td>
<td>Environment call from S-mode</td>
</tr>
<tr>
<td>0</td>
<td>11</td>
<td>Environment call from M-mode</td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td>Instruction page fault</td>
</tr>
<tr>
<td>0</td>
<td>13</td>
<td>Load page fault</td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>Store/AMO page fault</td>
</tr>
</tbody>
</table>
<p>其中 <code>Breakpoint</code> 和 <code>Environment call</code> 两种异常指令称为 陷入 或 trap 类指令。通过在上层软件中执行一条特定的指令触发的：</p>
<ol>
<li>执行 <code>ebreak</code> 指令就会触发 <code>Breakpoint</code> 异常</li>
<li>执行 <code>ecall</code> 指令就会根据 CPU 当前所处的特权级而触发不同的异常(8/9/11)</li>
</ol>
<h3 id="ecall">ecall</h3>
<p>这是一种特殊的陷入类指令，相邻的两特权级软件之间的接口正是通过这种陷入机制实现的。M 模式软件 SEE 和 S 模式的内核之间的接口被称为<strong>监督模式二进制接口</strong>(Supervisor Binary interface, <strong>SBI</strong>)，而内核和 U 模式的应用程序之间的接口被称为<strong>应用程序二进制接口</strong>(Application Binary interface, <strong>ABI</strong>)——系统调用(<strong>syscall</strong>)。</p>
<p>而为什么叫二进制接口，是因为它是机器/汇编指令级的接口(没有针对某种特定的高级语言编写的内部调用接口)，而且不是普通的函数调用控制流，而是陷入异常控制流，会切换 CPU 特权级。所以只有机器/汇编级别才能满足跨语言的通用和灵活性。</p>
<p><figure id="a-/images/Pasted%20image%2020221230220510.png" class="align-center">
    <img src="/images/Pasted%20image%2020221230220510.png" alt="在软件(应用，操作系统)执行过程中经常能看到特权级切换"  />
    
    <figcaption>
       在软件(应用，操作系统)执行过程中经常能看到特权级切换
    </figcaption>
    
</figure></p>
<p>总之出现:</p>
<ol>
<li>执行某一指令发生了某种错误(如除零、无效地址访问、无效指令等)</li>
<li>执行了高特权级指令</li>
<li>访问了不应该方法的高特权级的资源</li>
</ol>
<p>就需要将控制权移交给高特权级的软件来处理。当错误/异常恢复后，则重新回到低特权级的软件中执行，如果错误不能恢复，那么高特权级软件有权限杀死和清除低特权级软件。</p>
<h3 id="risc-v-的s级特权指令">RISC-V 的S级特权指令</h3>
<p>在 RISC-V 中有两类属于 S 模式的特权指令</p>
<ol>
<li>指令本身属于高特权级，如 <code>sret</code>(从 S 模式返回 U 模式)</li>
<li>访问的 S 模式下才能访问的寄存器或内存
<ol>
<li>sstatus: <code>SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息</li>
<li>spec: 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址</li>
<li>scause: 描述 Trap 的原因</li>
<li>stval: 给出 Trap 附加信息</li>
<li>stvec: 控制 Trap 处理代码的入口地址</li>
</ol>
</li>
</ol>
<h2 id="特权级切换">特权级切换</h2>
<p>当执行到一条 trap 类指令时(如<code>ecall</code>)，CPU 发现触发了一个异常并需要进行特殊处理，这涉及到执行环境切换，就是：</p>
<ol>
<li>用户态的执行环境中的应用程序通过调用<code>ecall</code>指令来向内核态的执行环境中的操作系统来请求某项服务</li>
<li>这时候 CPU 和操作系统就会完成用户态到内核态的执行环境切换</li>
<li>并在操作系统完成服务后再次切换回用户态执行环境</li>
<li>然后应用程序就会紧接着<code>ecall</code>指令的后一条继续执行</li>
</ol>
<p>在切换回来之后需要从发出 syscall 的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。</p>
<p>应用程序的上下文包括通用寄存器和栈两个主要部分。而 CPU 在不同特权级下共享一套通用寄存器，所以操作系统在处理 trap 的过程中也会使用到这些寄存器，就会改变应用程序的上下文。所以同函数调用一样，在执行操作系统的 trap 处理过程之前我们需要在某个地方(某内存块或内核的栈)保存这些寄存器并在 trap 处理结束之后恢复这些寄存器。</p>
<p>同时还有一些在 S 模式下专用的寄存器，也需要保证它们的变化在预期之内。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>执行环境： 主要负责给在其上执行的软件提供相应的功能与资源，并可在计算机系统中形成多层次的执行环境。</p>
<ol>
<li>比如之间运行在裸机硬件上的操作系统，其执行环境就是 计算机的硬件</li>
<li>后面就出现了在应用程序下面有了一层比较通用的函数库，这使得程序不用直接访问硬件了。所以应用程序的执行环境就是 函数库 -&gt; 计算机硬件</li>
<li>在后来，操作系统取代了函数库来访问硬件。 函数库 -&gt; 操作系统 -&gt; 计算机硬件</li>
</ol>
 </p>
</div>








<h3 id="特权级切换的硬件控制机制">特权级切换的硬件控制机制</h3>
<p>当 CPU 执行完一条指令(如<code>ecall</code>)并准备从 U 陷入到 S 时，硬件会完成：</p>
<ol>
<li><code>sstatus</code>的<code>SPP</code>会被修改为 CPU 当前的特权级(U/S)</li>
<li><code>sepc</code>会被修改为 trap 处理完成后默认会执行的下一条指令的地址</li>
<li><code>scause/stval</code>分别会被修改为这次 trap 的原因以及相关的附加信息</li>
<li>CPU 会跳转到 <code>stvec</code> 所设置的 trap 处理入口地址，并将当前特权级设置为 S,并从 trap 处理入口开始执行
<ol>
<li><code>stvec</code>保存了中断处理的入口地址</li>
<li>它后两个字段:
<ol>
<li>MODE 1~0, 2 bits</li>
<li>BASE 63~2, 62 bits</li>
</ol>
</li>
<li>当 MODE 为 0 时，<code>stvec</code>是 direct 模式，trap 的入口地址固定为 <code>BASE&lt;&lt;2</code></li>
</ol>
</li>
</ol>
<p>当 CPU 完成 trap 处理准备返回时，需要通过<code>sret</code>来完成:</p>
<ol>
<li>CPU 会将当前的特权级按照<code>sstatus</code>的<code>SPP</code>字段设置为 U/S</li>
<li>CPU 会跳转到<code>sepc</code>指向的指令并继续执行</li>
</ol>
<h3 id="用户栈和内核栈">用户栈和内核栈</h3>
<p>当 trap 触发的一瞬间，CPU 就会切换到 S 特权级并跳转到<code>stvec</code>设置的位置，但是在正式进入 S 特权级的处理之前，我们必须保存原控制流的寄存器状态，这一般是通过内核栈来保存的。这是专门为操作系统准备的内核栈，而不是应用程序运行时的用户栈。</p>
<p>使用两个栈主要是为了安全性:隔离数据，不让用户态的应用程序读取到内核态的操作系统的数据。</p>
<h3 id="trap-管理">Trap 管理</h3>
<p>特权级
切换的核心就是对 trap 的管理：</p>
<ol>
<li>应用程序通过<code>ecall</code>进入到内核状态时，操作系统需要保存被打断的应用程序的 trap 上下文</li>
<li>操作系统根据 CSR 寄存器(上述 S 模式下专有的寄存器)，完成系统调用服务的分发与处理</li>
<li>操作系统完成系统调用后，需要恢复被打断的应用程序的 trap 上下文，并通过<code>sret</code>让应用程序进行执行</li>
</ol>
<h4 id="trap-上下文的保存与恢复">Trap 上下文的保存与恢复</h4>
<p>在操作系统初始化时，我们通过修改<code>stvec</code>的值来指向 trap 处理入口点,即设置初始的<code>stvec</code>的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span> <span class="nf">__alltraps</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">// 默认为 BASE 为 __alltraps，MODE 为 direct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">stvec</span>::<span class="n">write</span><span class="p">(</span><span class="n">__alltraps</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">TrapMode</span>::<span class="n">Direct</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>trap 的处理流程如下：</p>
<ol>
<li>通过<code>__alltraps</code>将 trap 上下文保存在内核栈上，然后跳转到 <code>trap_handler</code> 函数完成 trap 分发及处理</li>
<li>当 <code>trap_handler</code>返回之后，使用<code>__restore</code>从保存在内核栈上的 trap 上下文恢复寄存器</li>
<li>最后通过<code>sret</code>指令回到应用程序执行</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__alltraps:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># csrrw rd csr rs =&gt; rd = csr, csr = rs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># sp = sscratch, sscratch = sp, 交换 sscratch 与 sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># sp 指向用户栈，sscratch 指向内核栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 交换后 sp 指向内核栈，sscratch 指向用户栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrrw</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">sp</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack, sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># allocate a TrapContext on kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 预分配 34 * 8 的栈帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">34</span><span class="p">*</span><span class="mi">8</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># save general-purpose registers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 保存 x0 ~ x31 跳过 x0(zero),x2(sp),x4(tp)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># skip sp(x2), we will save it later  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># skip tp(x4), application does not use it  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save x5~x31  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">27</span>  
</span></span><span class="line"><span class="cl">        <span class="no">SAVE_GP</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># we can use t0/t1/t2 freely, because they were saved on kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># t0 = sstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t0</span><span class="p">,</span> <span class="no">sstatus</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># t1 = spec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t1</span><span class="p">,</span> <span class="no">sepc</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 32*8 = t0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 33*8 = t1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># read user stack from sscratch and save it on the kernel stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 2*8 = sscratch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t2</span><span class="p">,</span> <span class="no">sscratch</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sd</span> <span class="no">t2</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># set input argument of trap_handler(cx: &amp;mut TrapContext) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># a0 = 内核栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mv</span> <span class="no">a0</span><span class="p">,</span> <span class="no">sp</span>  
</span></span><span class="line"><span class="cl">    <span class="no">call</span> <span class="no">trap_handler</span>
</span></span></code></pre></div><p>当<code>trap_handler</code>返回之后会从<code>trap_handler</code>的下一条指令开始执行，也就是<code>__restore</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__restore:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># case1: start running app by __restore  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># case2: back to U after handling trap  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mv</span> <span class="no">sp</span><span class="p">,</span> <span class="no">a0</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore sstatus/sepc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 恢复在 __alltraps 保存的   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  <span class="c1"># sstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  <span class="c1"># spec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t2</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>   <span class="c1"># sscratch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">sstatus</span><span class="p">,</span> <span class="no">t0</span>  
</span></span><span class="line"><span class="cl">    <span class="no">csrw</span> <span class="no">sepc</span><span class="p">,</span> <span class="no">t1</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># 设置为用户栈 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">t2</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 恢复 x0 ~ x31 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore general-purpuse registers except sp/tp  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">ld</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.rept</span> <span class="mi">27</span>  
</span></span><span class="line"><span class="cl">        <span class="no">LOAD_GP</span> <span class="nv">%n</span>  
</span></span><span class="line"><span class="cl">        <span class="no">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>  
</span></span><span class="line"><span class="cl">    <span class="no">.endr</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># release TrapContext on kernel stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 释放栈帧  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">34</span><span class="p">*</span><span class="mi">8</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;kernel stack, sscratch-&gt;user stack  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrrw</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">sp</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 返回到用户程序继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sret</span>
</span></span></code></pre></div>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p><code>sscratch</code>这个寄存器它：</p>
<ol>
<li>保存了内核栈的地址</li>
<li>作为一个中转站让<code>sp</code>（执行用户栈的地址）暂存在<code>sscratch</code>中</li>
</ol>
<p>通过<code>csrrw  sp, sscratch, sp</code>这一条指令就完成内核栈与用户栈的相互交换</p>
 </p>
</div>








<h4 id="trap-分发与处理">Trap 分发与处理</h4>
<ol>
<li>根据<code>scause</code>的<code>cause</code>进行分发处理</li>
<li>如果是<code>UserEnvCall</code>
<ol>
<li>则设置<code>sepc</code>为下一条指令</li>
<li>调用 syscall</li>
</ol>
</li>
<li>如果出现错误则直接运行下一个应用程序</li>
<li>如果是不支持的 trap 则直接抛出异常</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[no_mangle]</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// handle an interrupt, exception, or system call from user space  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">trap_handler</span><span class="p">(</span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TrapContext</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">TrapContext</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">scause</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scause</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// get trap cause  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stval</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// get extra value  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">scause</span><span class="p">.</span><span class="n">cause</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">UserEnvCall</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cx</span><span class="p">.</span><span class="n">sepc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall</span><span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">cx</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">12</span><span class="p">]])</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">StoreFault</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">StorePageFault</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;[kernel] PageFault in application, kernel killed it.&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">run_next_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Trap</span>::<span class="n">Exception</span><span class="p">(</span><span class="n">Exception</span>::<span class="n">IllegalInstruction</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;[kernel] IllegalInstruction in application, kernel killed it.&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">run_next_app</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;Unsupported trap {:?}, stval = {:#x}!&#34;</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">scause</span><span class="p">.</span><span class="n">cause</span><span class="p">(),</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">stval</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cx</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="执行应用程序">执行应用程序</h3>
<p>当操作系统初始化完成或某个应用形成运行结束或失败时，就调用<code>run_next_app</code>运行下一个应用程序。此时是 S 模式而要切换到 U 模式，所以切换流程:</p>
<ol>
<li>构造应用程序开执行所需的 trap 上下文</li>
<li>通过<code>__restore</code>函数，从 trap 上下文中恢复应用程序执行所需的寄存器</li>
<li>设置<code>sepc</code>的值为<code>0x80400000</code>(固定为这个值，后续会把每个应用程序加载到这个地址)</li>
<li>切换<code>scratch</code>和<code>sp</code>，将<code>sp</code>指向应用程序用户栈</li>
<li>执行<code>sret</code>切换 S =&gt; U</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// init app context  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">app_init_context</span><span class="p">(</span><span class="n">entry</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sstatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sstatus</span>::<span class="n">read</span><span class="p">();</span><span class="w"> </span><span class="c1">// CSR sstatus  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">sstatus</span><span class="p">.</span><span class="n">set_spp</span><span class="p">(</span><span class="n">SPP</span>::<span class="n">User</span><span class="p">);</span><span class="w"> </span><span class="c1">//previous privilege mode: user mode  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">x</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">],</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sstatus</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sepc</span>: <span class="nc">entry</span><span class="p">,</span><span class="w"> </span><span class="c1">// entry point of app  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cx</span><span class="p">.</span><span class="n">set_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="c1">// app&#39;s user stack pointer  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">cx</span><span class="w"> </span><span class="c1">// return initial Trap Context of app  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// run next app  
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run_next_app</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// ...
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">fn</span> <span class="nf">__restore</span><span class="p">(</span><span class="n">cx_addr</span>: <span class="kt">usize</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 在内核栈上压入一个 trap 上下文,它在栈顶,所以是 __restore 的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 即 a0 = 内核栈顶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 所以会有 `mv sp a0` 这一句,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// sepc 的值为固定的程序入口    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 根据`__restore`函数，如果是第一次调用，那么`sscratch`是什么时候设置为用户栈的？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 根据`mv sp a0`那么则 sp = a0 = trapContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 在`app_init_context`的实现中有`cx.set_sp(sp)`这一句即x[2] = sp = 用户栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 在`__restore`中有`ld t2, 2*8(sp)`与`csrw sscratch, t2`就完成了设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">__restore</span><span class="p">(</span><span class="n">KERNEL_STACK</span><span class="p">.</span><span class="n">push_context</span><span class="p">(</span><span class="n">TrapContext</span>::<span class="n">app_init_context</span><span class="p">(</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">APP_BASE_ADDRESS</span><span class="p">,</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">USER_STACK</span><span class="p">.</span><span class="n">get_sp</span><span class="p">(),</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Unreachable in batch::run_current_app!&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统的并发编程</title>
      <link>https://fzdwx.github.io/posts/2022-12-16-os-concurrent/</link>
      <pubDate>Fri, 16 Dec 2022 20:54:45 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-16-os-concurrent/</guid>
      <description>操作系统是最早的并发程序之一。
开始，我们肯定要理解什么是并发和并行以及它们的区别。
并行： 可以同时处理多个任务。 并发： 可以执行多个任务，但是同时只能执行一个任务，会在它们之间进行切换。 如果一个操作系统要支持并发，那么以下的哪些部分需要复制多份？ 全局变量 堆内存 函数调用栈 答案显而易见的是 函数调用栈 并发编程为什么难？
所有线程都共享一个堆内存 单个线程的状态机的执行结果是固定的，但是多线程不一样，因为它们涉及到一个线程切换的问题，这会导致每次程序运行的结果可能都是不一样的。 多线程状态机执行示意图 无法保证的三个特性 原子性: 一段代码执行时独占整个计算机系统 无法保证的例子： 两个线程对一个值进行 ++ N 次， 这个结果可能不是 2N 实现原子性： lock &amp;amp; unlock 实现临界去的绝对串行化 其他部分仍然可以并行执行 顺序性: 代码按编写的顺序执行，也就是实现源代码的按顺序翻译(为汇编)。 会导致的原因: 编译器的优化(编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。)，比如说 gcc 加-O1/2 实际例子： while(!done); // =&amp;gt; opt if (!done) while(1); 实现源代码的按顺序翻译： 在代码中插入“优化不能穿越的” barrier asm volatile (&amp;quot;&amp;quot; ::: &amp;ldquo;memory&amp;rdquo;); 含义是 可以读写任何内存 使用 volatile 变量 保持 c 语义和汇编语义一致 extern int volatile done; while(!</description>
      <content:encoded><![CDATA[<blockquote>
<p>操作系统是最早的并发程序之一。</p>
</blockquote>
<p>开始，我们肯定要理解什么是并发和并行以及它们的区别。</p>
<ul>
<li>并行： 可以同时处理多个任务。</li>
<li>并发： 可以执行多个任务，但是同时只能执行一个任务，会在它们之间进行切换。</li>
</ul>
<h2 id="如果一个操作系统要支持并发那么以下的哪些部分需要复制多份">如果一个操作系统要支持并发，那么以下的哪些部分需要复制多份？</h2>
<ol>
<li>全局变量</li>
<li>堆内存</li>
<li>函数调用栈</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221216211245.png" class="align-center">
    <img src="/images/Pasted%20image%2020221216211245.png" alt="答案显而易见的是 函数调用栈"  />
    
    <figcaption>
       答案显而易见的是 函数调用栈
    </figcaption>
    
</figure></p>
<p>并发编程为什么难？</p>
<ol>
<li>所有线程都共享一个堆内存</li>
<li>单个线程的状态机的执行结果是固定的，但是多线程不一样，因为它们涉及到一个线程切换的问题，这会导致每次程序运行的结果可能都是不一样的。</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221216211708.png" class="align-center">
    <img src="/images/Pasted%20image%2020221216211708.png" alt="多线程状态机执行示意图"  />
    
    <figcaption>
       多线程状态机执行示意图
    </figcaption>
    
</figure></p>
<h2 id="无法保证的三个特性">无法保证的三个特性</h2>
<ol>
<li>原子性: 一段代码执行时独占整个计算机系统
<ol>
<li>无法保证的例子： 两个线程对一个值进行 ++ N 次， 这个结果可能不是 2N</li>
<li>实现原子性： <code>lock</code> &amp; <code>unlock</code>
<ul>
<li>实现临界去的绝对串行化</li>
<li>其他部分仍然可以并行执行</li>
</ul>
</li>
</ol>
</li>
<li>顺序性: 代码按编写的顺序执行，也就是实现源代码的按顺序翻译(为汇编)。
<ol>
<li>会导致的原因: 编译器的优化(<strong>编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效</strong>。)，比如说 gcc 加<code>-O1/2</code></li>
<li>实际例子：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// =&gt; opt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span></code></pre></div></li>
<li>实现源代码的按顺序翻译： 在代码中插入“优化不能穿越的” barrier
<ol>
<li>asm volatile (&quot;&quot; ::: &ldquo;memory&rdquo;);
<ol>
<li>含义是 可以读写任何内存</li>
</ol>
</li>
<li>使用 volatile 变量
<ol>
<li>保持 c 语义和汇编语义一致</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="k">volatile</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span></span></code></pre></div></li>
</ol>
</li>
<li>可见性： 对某个共享内存的修改，其他线程要立马可见。
<ol>
<li>一段代码: 它的结果可能为: <code>0,0</code> <code>0,1</code> <code>1,0</code> <code>1,1</code> 4种情况, 但是只要有方法(f1 / f2)被执行就不会出现<code>0,0</code>这种结果。但实际的情况是<code>0,0</code>这个结果出现的次数最多。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	 <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	 <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	 <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>原因是：现代处理器也是一个动态编译器。单个处理器把汇编（用电路）编译成更小的操作符。
<ol>
<li>在任何时刻，处理器都维护了一个操作符的容器</li>
<li>每一周期尽可能多的补充操作符</li>
<li>每一周期执行尽可能多的操作符</li>
<li>乱序执行，按序提交</li>
</ol>
</li>
<li>实现顺序一致性： 使用<code>mfence</code>指令或使用原子指令(lock),让它每次都到内存中去读取，而不读取缓存</li>
</ol>
</li>
</ol>
<h2 id="自旋锁-spin-lock">自旋锁 spin lock</h2>
<p>假如硬件能提供一条“瞬间完成” 的读 + 写的指令</p>
<ul>
<li>其他所有人暂停，load + store
<ul>
<li>如果有人同时请求，硬件选出一个胜利者</li>
<li>败者等胜利者完成后继续</li>
</ul>
</li>
</ul>
<h3 id="x86提供的-lock-前缀">X86提供的 lock 前缀</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sum</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">		<span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;lock addq $1, %0&#34;</span><span class="o">:</span> <span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">sum</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>atomic exchange(load + store)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">xchg</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&#34;lock xchg %0, %1&#34;</span> 
</span></span><span class="line"><span class="cl">		<span class="o">:</span> <span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="s">&#34;=a&#34;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;1&#34;</span><span class="p">(</span><span class="n">newval</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">result</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>实现自旋锁:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="nf">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span> <span class="nf">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="lock-指令的现代实现">lock 指令的现代实现</h3>
<p>在 L1 cache 层保持一致性</p>
<ul>
<li>所有 cpu 的L1缓存都用总线连起来</li>
<li>对某个内存 M 执行 lock，则其他所有缓存的 M 都无效（这个代价非常大）</li>
</ul>
<h2 id="risc-v-的原子操作">RISC-V 的原子操作</h2>
<p>原子操作的目的：</p>
<ol>
<li><code>a = load(x); if (a == xx){ store(x,y) }</code></li>
<li><code>a = load(x); store(x,y)</code></li>
<li><code>a = load(x); a++; store(x,a)</code></li>
</ol>
<p>它们的本质都是 load -&gt; exec(进行运算) -&gt; store</p>
<h3 id="load-reserved--store-conditional">Load reserved / Store Conditional</h3>
<p>LR: 在读取时会对这个内存加上一个标记，中断、其他处理器的写入都会导致标记消除</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lr.w</span> <span class="no">rd</span> <span class="p">(</span><span class="no">rs1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">rd</span> <span class="err">=</span> <span class="no">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reserve</span> <span class="no">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span>
</span></span></code></pre></div><p>SC: 如果那片内存还存在标记则继续写入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">sc.w</span> <span class="no">rd</span> <span class="no">rs2</span> <span class="p">(</span><span class="no">rs1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">if</span> <span class="no">still</span> <span class="no">reserved</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">M</span><span class="p">[</span><span class="no">rs1</span><span class="p">]</span> <span class="err">=</span> <span class="no">rs2</span>
</span></span><span class="line"><span class="cl">		<span class="nf">rd</span> <span class="err">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nl">else:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">rd</span> <span class="err">=</span> <span class="no">nonzero</span>
</span></span></code></pre></div><h3 id="实现-cas">实现 cas</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">cas</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmp_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">old_val</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">old_val</span> <span class="o">==</span> <span class="n">cmp_val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">cas:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lr.w</span> <span class="no">t0</span> <span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bne</span> <span class="no">t0</span> <span class="no">a1</span> <span class="no">fail</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sc.w</span> <span class="no">t0</span> <span class="no">a2</span> <span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bnez</span> <span class="no">t0</span> <span class="no">cas</span>
</span></span><span class="line"><span class="cl">	<span class="nf">li</span> <span class="no">a0</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jr</span> <span class="no">ra</span>
</span></span><span class="line"><span class="cl"><span class="nl">fail:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">li</span> <span class="no">a0</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ja</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="线程同步">线程同步</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>RISC-V 简介</title>
      <link>https://fzdwx.github.io/posts/2022-12-10-risc-v/</link>
      <pubDate>Sat, 10 Dec 2022 20:41:41 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-10-risc-v/</guid>
      <description>Resource &amp;nbsp;RISC-V Green Card &amp;nbsp;RISC-V Call convertion &amp;nbsp;P&amp;amp;H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。
TIP 寄存器（Register）是&amp;nbsp;中央处理器 内用来暂存指令、&amp;nbsp;数据 和&amp;nbsp;地址 的&amp;nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在&amp;nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&amp;nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 =&amp;gt; x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。
ld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。</description>
      <content:encoded><![CDATA[<h2 id="resource">Resource</h2>
<ol>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf" target="_blank" rel="noopener">RISC-V Green Card</a>
</li>
<li>&nbsp;<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/RISCV_Calling_Convention.pdf" target="_blank" rel="noopener">RISC-V Call convertion</a>
</li>
<li>&nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">P&amp;H(RISC-V)</a>
</li>
</ol>
<p>在汇编语言中没有变量这个概念，汇编语言通常操作的是<strong>寄存器</strong>。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <strong>寄存器</strong>（Register）是&nbsp;<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" title="中央处理器" target="_blank" rel="noopener">中央处理器</a>
内用来暂存指令、&nbsp;<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A" title="数据" target="_blank" rel="noopener">数据</a>
和&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80" title="内存地址" target="_blank" rel="noopener">地址</a>
的&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" title="电脑存储器" target="_blank" rel="noopener">电脑存储器</a>
。寄存器的存贮容量有限，读写速度非常快。在&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%9E%B6%E6%A7%8B" title="计算机体系结构" target="_blank" rel="noopener">计算机体系结构</a>
里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速&nbsp;<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F" title="计算机程序" target="_blank" rel="noopener">计算机程序</a>
的执行。 </p>
</div>








<h2 id="risc-v-card">RISC-V Card</h2>
<h3 id="risc-v-操作数">RISC-V 操作数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210211515.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211515.png" alt=""  />
    
</figure></p>
<ul>
<li>如果寄存器的大小是 64位 则称为<strong>双字</strong>，32位 则是<strong>单字</strong>。</li>
<li>x<sub>0</sub> 被硬连接到 0
<ul>
<li><code>add x3, x4, x0</code> =&gt; <code>x3 = x4</code> (x0 is hard-wired to value 0)</li>
</ul>
</li>
</ul>
<h2 id="汇编指令">汇编指令</h2>
<p><figure id="a-/images/Pasted%20image%2020221210211545.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211545.png" alt=""  />
    
</figure><figure id="a-/images/Pasted%20image%2020221210211603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210211603.png" alt=""  />
    
</figure></p>
<h2 id="存储操作数">存储操作数</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 将数据从内存复制到寄存器的数据传输指令称为 <em>载入指令(<code>load</code>)</em>。在 RISC-V 中指令是 <strong>ld</strong>,表示取双字。 </p>
</div>








<h3 id="一个从数组中取值的c程序写出汇编代码">一个从数组中取值的C程序，写出汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或<em>基址</em>位于 x22 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ld</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span> <span class="c1">// x9 = A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">add</span> <span class="no">x21</span><span class="p">,</span> <span class="no">x20</span><span class="p">,</span> <span class="no">x9</span><span class="c1">; // x21 = x20 + x9
</span></span></span></code></pre></div><p>存放基址的寄存器(x22)被称为<em>基址寄存器</em>, 数据传输指令中的 8 称为<em>偏移量</em>。</p>
<p><figure id="a-/images/Pasted%20image%2020221212130603.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212130603.png" alt="实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数"  />
    
    <figcaption>
       实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数
    </figcaption>
    
</figure></p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        大端与小端编址
        
    </p>
    <p> <p>计算机分为两种，一种使用最左边或“大端”字节的地址作为双字地址，另一种使用最右端或“小端”字节的地址作为双字地址。</p>
<p>RISC-V 使用小端  。由于仅在以双字形式和 8 个单独字节访问相同数据时，字节顺序才有影响，因此大多情况不需要关系“大小端”。</p>
 </p>
</div>








<p>所以为了上面的代码获得正确的字节地址加到 x22 这个寄存器的偏移量为 64（8x8）。</p>
<p>与载入指令相反的指令通常被成为<em>存储指令(store)</em>,从寄存器复制数据到内存。指令是<code>sd</code>,表示存储双字。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 在一些体系结构中，字的起始地址必须是 4 的倍数，双字的起始地址必须是 8 的倍数。该要求成为<em>对齐限制</em> </p>
</div>








<p>RISC-V 和 Intel x86 没有对齐限制，但 MIPS 有这个限制。</p>
<p><figure id="a-/images/Pasted%20image%2020221212152022.png" class="align-center">
    <img src="/images/Pasted%20image%2020221212152022.png" alt=""  />
    
</figure></p>
<h3 id="使用-load-和-store-编译生成指令">使用 load 和 store 编译生成指令</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span></code></pre></div><p>h 存放在 x21 中，A 的基址存放在 x22 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ld</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span>  <span class="c1">// x9 = A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">add</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x21</span><span class="p">,</span> <span class="no">x9</span> <span class="c1">// x9 = h + A[8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">sd</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">96</span><span class="p">(</span><span class="no">x22</span><span class="p">)</span>  <span class="c1">// A[12] = x9
</span></span></span></code></pre></div><h3 id="将字符串复制程序编译为汇编">将字符串复制程序编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">[],</span><span class="kt">char</span> <span class="n">y</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>x, y 的基址存放在 x10 和 x11 中， i 存放在 x19 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">strcpy:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>  <span class="c1">// 调整栈指针，以存放一个item(x19)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sd</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    <span class="c1">// x19 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>  <span class="c1">// x19 = 0 + 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L1:</span> <span class="nf">add</span> <span class="no">x5</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x11</span> <span class="c1">// x5 = x19 + x11 =&gt; address of y[i] in x5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lbu</span> <span class="no">x6</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x5</span><span class="p">)</span>    <span class="c1">// temp: x6 = y[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x7</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x10</span> <span class="c1">// x5 = x19 + x11 =&gt; address of x[i] in x7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sd</span>  <span class="no">x6</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x7</span><span class="p">)</span>    <span class="c1">// x[i] = y[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">beq</span> <span class="no">x6</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">L2</span>   <span class="c1">// if x6 ==0 then go to L2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x19</span><span class="p">,</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">// i = i  + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">jal</span> <span class="no">x0</span><span class="p">,</span> <span class="no">L1</span>       <span class="c1">// go to L1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L2:</span> <span class="nf">ld</span> <span class="no">x19</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    <span class="c1">// 恢复 x19 以及栈指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span> 
</span></span><span class="line"><span class="cl">	<span class="no">jalr</span> <span class="no">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x1</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="一段循环代码编译为汇编">一段循环代码编译为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span>  <span class="mi">3</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>RISC-V 汇编（32 bit)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">	<span class="nf">add</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x8</span><span class="p">,</span> <span class="no">x0</span>     <span class="c1"># x9 = &amp;A[0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>    <span class="c1"># sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span>    <span class="c1"># i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x13</span><span class="p">,</span><span class="no">x0</span><span class="p">,</span> <span class="mi">20</span>    <span class="c1"># 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">Loop:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">bge</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x13</span><span class="p">,</span> <span class="no">Done</span> <span class="c1"># if x11 &gt; x13 go to Down(end loop)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">x12</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x9</span><span class="p">)</span>      <span class="c1"># x12 = A[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x10</span><span class="p">,</span> <span class="no">x12</span>  <span class="c1"># sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x9</span><span class="p">,</span> <span class="no">x9</span><span class="p">,</span> <span class="mi">4</span>     <span class="c1"># x9 = &amp;A[i+1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">x11</span><span class="p">,</span> <span class="no">x11</span><span class="p">,</span> <span class="mi">1</span>   <span class="c1"># i++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">j</span> <span class="no">loop</span>
</span></span><span class="line"><span class="cl"><span class="nl">Done:</span>
</span></span></code></pre></div><h2 id="逻辑操作">逻辑操作</h2>
<ul>
<li><code>and</code> <code>andi</code>
<ul>
<li><code>and x5, x6, x9</code> =&gt; x5 = x6 &amp; x9</li>
<li><code>addi x5, x6, 3</code> =&gt; x5 = x6 &amp; 3</li>
</ul>
</li>
<li><code>sll</code> <code>ssli</code> , 左移(扩大)
<ul>
<li><code>slli x11, x23, 2</code> =&gt; x11 = x23 &laquo; 2</li>
<li>0000 0010  =&gt; 2</li>
<li>0000 1000 =&gt; 8</li>
</ul>
</li>
<li><code>srl</code> <code>srli</code> , 右移（缩小)
<ul>
<li><code>srli x23, x11, 2</code> = &gt; x23 = x11 &raquo; 2</li>
<li>0000 1000 =&gt; 8</li>
<li>0000 0010 =&gt; 2</li>
</ul>
</li>
<li><code>sra</code> <code>srai</code>, 算数右移
<ul>
<li>1111 1111 1111 1111 1111 1111 1110 0111 = -25</li>
<li><code>srai x10, x10, 4</code></li>
<li>1111 1111 1111 1111 1111 1111 1111 1110 = -2</li>
</ul>
</li>
</ul>
<h2 id="helpful-risc-v-assmebler-features">Helpful RISC-V Assmebler Features</h2>
<ol>
<li>a0 - a7 是参数寄存器(x10 - x17，用于函数调用。</li>
<li>zero 代表 x0</li>
<li><code>mv rd, rs = addi rd, rs, 0</code></li>
<li><code>li rd, 13 = addi rd, x0, 13</code></li>
<li><code>nop = addi x0, x0</code></li>
<li><code>la a1 Lable</code> 将 Label 的 地址 加载到 a1</li>
<li>a0 - a7(x10 - x17): 8 个寄存器用于参数传递以及两个返回值(a0 - a1)</li>
<li>ra（x1）: 一个返回 address 的寄存器，用于返回原点（调用的位置）</li>
<li>s0 - s1(x8 - x9) and s2 - s11 (s18 - x27): 保存的寄存器</li>
</ol>
<h2 id="risc-v-函数调用的转换">RISC-V 函数调用的转换</h2>
<ol>
<li>寄存器比内存快，所以使用它们</li>
<li><code>jal rd, Label</code> 跳转和链接
<ol>
<li><code>jal x1, 100</code></li>
</ol>
</li>
<li><code>jalr rd, rs, imm</code> 跳转和链接寄存器
<ol>
<li><code>jalr x1, 100(x5)</code></li>
</ol>
</li>
<li><code>jal Lable</code> =&gt; <code>jal ra, Lable</code> 调用函数</li>
<li><code>jalr s1</code> 当 s1 是方法指针时，这就是一个函数调用</li>
</ol>
<h3 id="一段函数调用转换为汇编">一段函数调用转换为汇编</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="err">1000</span> <span class="nf">mv</span> <span class="no">a0</span><span class="p">,</span> <span class="no">s0</span>              <span class="c1"># x = a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1004</span> <span class="nf">mv</span> <span class="no">a1</span><span class="p">,</span> <span class="no">s1</span>              <span class="c1"># y= b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1008</span> <span class="nf">addi</span> <span class="no">ra</span><span class="p">,</span> <span class="no">zero</span><span class="p">,</span> <span class="mi">1016</span>    <span class="c1"># 1016 is sum function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1012</span> <span class="nf">j</span>                      <span class="c1"># jump to sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">1016</span> <span class="na">...</span> 
</span></span><span class="line"><span class="cl"><span class="no">...</span>
</span></span><span class="line"><span class="cl"><span class="err">2000</span> <span class="nl">sum:</span> <span class="nf">add</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>
</span></span><span class="line"><span class="cl"><span class="err">2004</span> <span class="nf">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><p>1008 ~ 1012 可以使用 <code>jal sum</code> 来替代、</p>
<h3 id="调用函数的基本步骤">调用函数的基本步骤</h3>
<ol>
<li>把需要的参数放到方法可以访问的地方（寄存器）</li>
<li>转移控制权给函数,使用(<code>jal</code>)
<ol>
<li>保持地址，并跳转到函数的地址</li>
</ol>
</li>
<li>获取函数执行所需的(local)存储资源</li>
<li>执行预期的函数</li>
<li>将返回值放在调用代码可以访问的地方，并恢复我们使用到的寄存器，释放本地存储</li>
<li>将控制器返回给主处理器（<code>ret</code>), 使用存储在寄存器中的地址，返回到调用它的地方</li>
</ol>
<h3 id="方法调用示例">方法调用示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">retrun</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>g,h,i,j in a0,a1,a2,a3</li>
<li>f in s0</li>
<li>temp is s1</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">leaf:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># prologue start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>   <span class="c1"># 腾出 8byte 来存放的2个整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>      <span class="c1"># 保存 s1, s0 到 sp 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">s0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># prologue end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">s0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>    <span class="c1"># f = g + h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">s1</span><span class="p">,</span> <span class="no">a2</span><span class="p">,</span> <span class="no">a3</span>    <span class="c1"># temp = i + j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sub</span> <span class="no">a0</span><span class="p">,</span> <span class="no">s0</span><span class="p">,</span> <span class="no">s1</span>    <span class="c1"># a0 = （g + h) - (i + j) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1"># epilogue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">s0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>      <span class="c1"># 恢复 s1, s0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>    
</span></span><span class="line"><span class="cl">	<span class="no">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span> <span class="mi">8</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="no">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="sp">sp</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>sp 是栈指针，从内存空间 的最顶部开始向下增长，在 RISC-V 中使用 x2 这个寄存器。</p>
<ol>
<li>push 是减少 sp 的指针地址</li>
<li>pop 是增加</li>
</ol>
 </p>
</div>








<p>每个函数都有一组存放在栈上的数据，它们是<strong>栈帧</strong>（stack frame ），栈帧通常包含：</p>
<ol>
<li>返回地址</li>
<li>参数</li>
<li>使用的局部变量的空间</li>
</ol>
<h2 id="嵌套函数调用">嵌套函数调用</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sumSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 ra 中有一个 sumSquare 想要跳回的值，但是这个值会被调用 mult 覆盖。</p>
<ol>
<li>caller: 调用函数的人</li>
<li>calle： 被调用的函数</li>
<li>当被调用者从执行中返回时，调用者需要知道哪些寄存器可能发生了变化，哪些寄存器被保证是不变的。</li>
<li>寄存器规定： 即哪些寄存器在程序调用(<code>jal</code>) 后将被取消缓存 ，哪些可以被改变。
<ol>
<li>即有一些寄存器是易失的(temp),一些是要保存的（<strong>调用者需要恢复它们原来的值</strong>）。</li>
<li>这优化了每次进入栈帧的寄存器的数量</li>
</ol>
</li>
<li>分类:
<ol>
<li>跨函数调用保留:
<ol>
<li>sp, gp, tp</li>
<li>s0 - s11 (s0 is also fp)</li>
</ol>
</li>
<li>不保留:
<ol>
<li>参数寄存器以及返回寄存器： a0 - a7, ra</li>
<li>temp 寄存器: t0 - t6</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>上面代码的 RISC-V</p>
<p>x in a1, y in a1</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">sumSquare:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span> <span class="p">-</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sw</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// save retrun address to sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sw</span> <span class="no">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// save s1 to y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mv</span> <span class="no">a1</span><span class="p">,</span> <span class="no">a0</span>                <span class="c1">// y = x =&gt; mult(x,x)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">jal</span> <span class="no">mult</span>                 <span class="c1">// call mult
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// get y from sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">add</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>           <span class="c1">// mult() + y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lw</span> <span class="no">ra</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>             <span class="c1">// get retrun address from sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">addi</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jr</span> <span class="no">ra</span>
</span></span></code></pre></div><h2 id="risc-v-寄存器名称">RISC-V 寄存器名称</h2>
<p><figure id="a-/images/Pasted%20image%2020221213192858.png" class="align-center">
    <img src="/images/Pasted%20image%2020221213192858.png" alt=""  />
    
</figure></p>
<h2 id="risc-v-方法调用套路">RISC-V 方法调用套路</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">matmul:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 压栈，腾出空间保存我们要使用的几个 s 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addi</span> <span class="no">sp</span> <span class="no">sp</span> <span class="p">-</span><span class="mi">36</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">ra</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s0</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s1</span> <span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s2</span> <span class="mi">12</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s3</span> <span class="mi">16</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s4</span> <span class="mi">20</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s5</span> <span class="mi">24</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s6</span> <span class="mi">28</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">sw</span> <span class="no">s7</span> <span class="mi">32</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="no">body</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># xxx xxx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">end:</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># 恢复寄存器的值  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lw</span> <span class="no">ra</span> <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s0</span> <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s1</span> <span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s2</span> <span class="mi">12</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s3</span> <span class="mi">16</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s4</span> <span class="mi">20</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s5</span> <span class="mi">24</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s6</span> <span class="mi">28</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">lw</span> <span class="no">s7</span> <span class="mi">32</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="no">addi</span> <span class="no">sp</span> <span class="no">sp</span> <span class="mi">36</span>  
</span></span><span class="line"><span class="cl">    <span class="no">ret</span>  
</span></span></code></pre></div><h1 id="risc-v-指令二进制的表示">RISC-V 指令二进制的表示</h1>
<h2 id="r-格式布局">R 格式布局</h2>
<p>用于算术和逻辑运算的指令</p>
<p><figure id="a-/images/Pasted%20image%2020221224214056.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224214056.png" alt=""  />
    
</figure></p>
<ol>
<li>opcode，funct3, funct7 : 将告诉我们是否要执行加，减，左移，异或等操作。
<ol>
<li>R-format 的 opcode 固定为 0110011</li>
</ol>
</li>
<li>一个 add 操作： <code>add x18 x19 x10</code> =&gt; <code>x18 = x19 + x10</code></li>
<li><code>0000000 01010 10011 000 10010 0110011</code></li>
<li><code>rs2 = x19</code>, <code>rs1 = x10</code>, <code>rd = x18</code></li>
</ol>
<h2 id="i-格式布局">I 格式布局</h2>
<p>处理立即数，比如<code>addi rd rs1, imm</code> =&gt; <code>addi a0 a0 1</code></p>
<p><figure id="a-/images/Pasted%20image%2020221224220039.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224220039.png" alt=""  />
    
</figure></p>
<ol>
<li>imm 的范围是 -2084 ～ 2047</li>
</ol>
<p><figure id="a-/images/Pasted%20image%2020221224220349.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224220349.png" alt="addi x15 x1 -50"  />
    
    <figcaption>
       addi x15 x1 -50
    </figcaption>
    
</figure></p>
<h2 id="risc-v-loads">RISC-V Loads</h2>
<p>load 指令也是 I 类型的。</p>
<p><figure id="a-/images/Pasted%20image%2020221224221104.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224221104.png" alt="lw x14 8(x2)"  />
    
    <figcaption>
       lw x14 8(x2)
    </figcaption>
    
</figure></p>
<h2 id="s-格式布局">S 格式布局</h2>
<p><figure id="a-/images/Pasted%20image%2020221224221434.png" class="align-center">
    <img src="/images/Pasted%20image%2020221224221434.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>浮点数在计算机中的表示</title>
      <link>https://fzdwx.github.io/posts/2022-12-09-float-rep/</link>
      <pubDate>Fri, 09 Dec 2022 19:02:32 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-09-float-rep/</guid>
      <description>表示方法 $(-1)^{S}\times(1.xxx&amp;hellip;x_{2}\times2^{{yyy&amp;hellip;y}_{2}})$ 指数表示Y,尾数表示X 单精度的表示方法 双精度的表示方法 公式:
$(-1)^{S}\times{F}\times{2^{E}}$ F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。 移码表示法 TIP 最理想的表示法是将最小的负指数表示为 00&amp;hellip;002， 将最大的正指数表示为 11&amp;hellip;112。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 IEEE 754规定:
单精度的偏移值为 127 指数为 -1 表示 -1 + 12710 = 12610 = 011111102 +1 = 1 + 12710 = 12810 = 100000002 最大指数为127 最小为-126 双精度的指数偏移值为 1023 1023 -1022 带偏移值的指数意味着一个由浮点数表示的值实际上是:
$(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$ 表示 - 0.7510 分数表示为：
(-3/4)10 = (-3/22)10 二进制小数表示:
(-11/22)10 = -0.112 -11 右移 2 位 用科学计数法表示:</description>
      <content:encoded><![CDATA[<h2 id="表示方法">表示方法</h2>
<figure class="align-center">
    $(-1)^{S}\times(1.xxx&hellip;x_{2}\times2^{{yyy&hellip;y}_{2}})$

    
    <figcaption>
        指数表示Y,尾数表示X
    </figcaption>
    
</figure>
<p><figure id="a-/images/Pasted%20image%2020221209193439.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193439.png" alt="单精度的表示方法"  />
    
    <figcaption>
       单精度的表示方法
    </figcaption>
    
</figure></p>
<p><figure id="a-/images/Pasted%20image%2020221209193511.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193511.png" alt="双精度的表示方法"  />
    
    <figcaption>
       双精度的表示方法
    </figcaption>
    
</figure></p>
<p>公式:</p>
<figure class="align-center">
    $(-1)^{S}\times{F}\times{2^{E}}$

    
    <figcaption>
        F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。
    </figcaption>
    
</figure>
<h2 id="移码表示法">移码表示法</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 最理想的表示法是将最小的负指数表示为 00&hellip;00<sub>2</sub>， 将最大的正指数表示为 11&hellip;11<sub>2</sub>。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 </p>
</div>








<p>IEEE 754规定:</p>
<ol>
<li>单精度的偏移值为 127
<ol>
<li>指数为 -1 表示 -1 + 127<sub>10</sub> = 126<sub>10</sub> = 01111110<sub>2</sub></li>
<li>+1 = 1 + 127<sup>10</sup> = 128<sub>10</sub> = 10000000<sub>2</sub></li>
<li>最大指数为127</li>
<li>最小为-126</li>
</ol>
</li>
<li>双精度的指数偏移值为 1023
<ol>
<li>1023</li>
<li>-1022</li>
</ol>
</li>
</ol>
<p>带偏移值的指数意味着一个由浮点数表示的值实际上是:</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<h3 id="表示---075sub10sub">表示 - 0.75<sub>10</sub></h3>
<p>分数表示为：</p>
<figure class="align-center">
    (-3/4)<sub>10</sub> = (-3/2<sup>2</sup>)<sub>10</sub>

    
</figure>
<p>二进制小数表示:</p>
<figure class="align-center">
    (-11/2<sup>2</sup>)<sub>10</sub> = -0.11<sub>2</sub>

    
    <figcaption>
        -11 右移 2 位
    </figcaption>
    
</figure>
<p>用科学计数法表示:</p>
<figure class="align-center">
    -0.11<sub>2</sub> x 2<sup>0</sup>

    
</figure>
<p>用规格化的科学计数法表示:</p>
<figure class="align-center">
    -1.1<sub>2</sub> x 2<sup>-1</sup>

    
</figure>
<p>由上面的公式的到：</p>
<figure class="align-center">
    $(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$

    
</figure>
<ul>
<li>有效位数: 0.1<sub>2</sub></li>
<li>
<ul>
<li>1 = (- 1)<sup>S</sup> =&gt; S = 1<sub>2</sub></li>
</ul>
</li>
<li>指数 - 127 = -1 =&gt; 指数 = 126<sub>10</sub></li>
</ul>
<p>单精度可以表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210142957.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210142957.png" alt=""  />
    
</figure></p>
<p>双精度表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210143322.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143322.png" alt=""  />
    
</figure></p>
<h3 id="表示二进制浮点数为十进制浮点数">表示二进制浮点数为十进制浮点数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210143423.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143423.png" alt=""  />
    
</figure></p>
<ul>
<li>S = 1</li>
<li>有效位数: 0.01<sub>2</sub> =&gt; 1 x 2<sup>-2</sup>（右移两位） = 0.25</li>
<li>指数: 129</li>
</ul>
<p>根据公式:</p>
<p>$(-1)^{1}\times{(1 + 0.25)}\times{2^{129 - 127}}$</p>
<p>= $-1\times1.25\times2^2$</p>
<p>= $-1.25\times4$</p>
<p>= $-5$</p>
<blockquote>
<p>浮点加法与浮点乘法可以看 P&amp;H 3.5.4~3.5.5 &nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf</a>
</p>
</blockquote>
<h2 id="risc-v-中的浮点指令">RISC-V 中的浮点指令</h2>
<ul>
<li>算术
<ul>
<li>加法: <code>fadd.s</code> <code>fadd.d</code>
<ul>
<li><code>fadd.s f0, f1, f2</code> =&gt; <code>f0 = f1 + f2</code></li>
</ul>
</li>
<li>减法：<code>fsub</code> <code>fsub</code>
<ul>
<li><code>fsub.s f0, f1, f2</code> =&gt; <code>f0 = f1 - f2</code></li>
</ul>
</li>
<li>乘法: <code>fmul</code>
<ul>
<li><code>fmul.s f0, f1, f2</code> =&gt; <code>f0 = f1 * f2</code></li>
</ul>
</li>
<li>除法: <code>fdiv</code>
<ul>
<li><code>fdivs f0, f1, f2</code> =&gt; <code>f0 = f1 / f2</code></li>
</ul>
</li>
<li>平方根: <code>fsqrt</code>
<ul>
<li><code>fsqrt.s f0, f1</code> =&gt; <code>$f0 = \sqrt{f1}$</code></li>
</ul>
</li>
</ul>
</li>
<li>比较
<ul>
<li>相等: <code>feq</code>
<ul>
<li><code>feq.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 == f1, else 0</code></li>
</ul>
</li>
<li>小于: <code>flt</code>
<ul>
<li><code>flt.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt; f1, else 0</code></li>
</ul>
</li>
<li>小于或等于: <code>fle</code>
<ul>
<li><code>fle.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt;= f1, else 0</code></li>
</ul>
</li>
<li>如果比较结果为 真，则将整点寄存器设置 1,否则为 0</li>
<li>所以可以使用整数分支指令 <code>beq</code> 和 <code>bne</code> 来比较结果并进行分支</li>
</ul>
</li>
<li>取存指令:
<ul>
<li>双：<code>fld</code> <code>fsd</code>
<ul>
<li><code>fld f0, 8(x5)</code> =&gt; <code>f0 = Memory[x5 + 8]</code></li>
<li><code>fsd f0, 8(x5)</code> =&gt; <code>Memory[x5 +8] = f0</code></li>
</ul>
</li>
<li>单:<code>flw</code> <code>fsw</code></li>
<li>浮点数据传输指令的基址寄存器仍为整点寄存器</li>
<li>在 RISC-V中有独立的浮点寄存器: f0 ~ f31</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述指令都有单双精度版本，单精度以 <code>.s</code> 结尾，双精度以 <code>.d</code> 结尾</p>
</blockquote>
<p>一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中</p>
<pre tabindex="0"><code class="language-ricv-v" data-lang="ricv-v">flw    f0, 0(x10)     // 加载一个 32bit 的数到 f0
flw    f1, 4(x10)     // 加载一个 32bit 的数到 f1
fadd.s f2, f0, f1     // f2 = f0 + f1
fsw    f2, 8(x10)     // 保存来自 f2 的 32bit 的数
</code></pre>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。</p>
<p>例如一些寄存器中所有类型的操作数转换为单一的内部格式。</p>
 </p>
</div>








<h3 id="将一段-c-代码转换成-risc-v-的的汇编代码">将一段 C 代码转换成 RISC-V 的的汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">f2c</span><span class="p">(</span><span class="kt">float</span> <span class="n">qwe</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">retrun</span> <span class="p">((</span><span class="mf">5.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qwe</span> <span class="o">-</span> <span class="mf">32.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设参数 <code>qwe</code> 传入到寄存器 <code>f10</code> 中，且结果也存入 <code>f10</code>中:</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">f2c:
	flw    f0, const5(x3)  // f0 = 5.0f
	flw    f1, const9(x3)  // f1 = 9.0f
	fdiv.s f0, f0, f1      // f0 = 5.0f / 9.0f
	flw    f1, const32(x3) // f1 = 32.0f
	fsub.s f10, f10, f1    // f10 = qwe - 32.0f
	fmul.s f10, f0,  f10   // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); 
	jalr   x0, 0(x1)       // retrun
</code></pre><p>假设通过 <code>x3</code> 访问上面3个常量浮点数</p>
<h3 id="将二维矩阵的c代码转换为risc-v的汇编代码">将二维矩阵的C代码转换为RISC-V的汇编代码</h3>
<figure class="align-center">
    $C=C+A\times{B}$

    
</figure>
<p>假设A, B, C都是 32 x 32 的二维矩阵</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mm</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[][]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	mm:...
		li x28, 32        // x28 = 32
		li x5, 0          // i = 0;
L1:		li x6, 0          // j = 0;
L2:		li x7, 0          // k = 0;
		slli x30, x5, 5   // x30 = i * 2 ^ 5(size of row of c)
		add x30, x30, x6  // x30 = i * size(row) + j
		slli x30, x30, 3  // x30 = byte offset of [i][j] 8个字节,左移3位
		add x30, x10, x30 // x30 = byte address of c[i][j]
		fld f0, 0(x30)    // f0 = 8 bytes of c[i][j]
L3:     slli x29, x7, 5   // x29 = k * 2 ^ 5
		add x29, x29, x6  
		slli x29, x29, 3
		add x29, x12, x29
		fld f1, 0(x29)     // f1 = 8 bytes of b[k][j]
		slli x29,x5 5      // x29 = i * 2 ^ 5
		add x29, x29, x7
		slli x29, x29, 3
		add x29, x11, x29
		fld f2, 0(x29)     // f2 = a[i][k]
		fmul.d f1, f2, f1  // f1 = a[i][k] * b[k][j]
		fadd.d f0, f0 ,f1  // f0 = c[i][j] + a[i][k] * b[k][j]
		addi x7, x7, 1     // k = k + 1
		bltu x7, x28, L3   // if (k &lt; 32) go to L3
		fsd f0, 0(x30)     // c[i][j] = f0
		addi x6, x6, 1     // j = j + 1
		bltu x6, x28, L2   // if (j &lt; 32) go to L2
		addi x5, x5, 1     // i = i + 1
		bltu x5, x28, 1    // if (i &lt; 32) go to L1
</code></pre><h2 id="一些c语言和java的数据类型数据传输指令">一些C语言和Java的数据类型、数据传输指令：</h2>
<p><figure id="a-/images/Pasted%20image%2020221210170829.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210170829.png" alt=""  />
    
</figure></p>
<h3 id="二进制浮点数表示图">二进制浮点数表示图</h3>
<p><figure id="a-/images/Pasted%20image%2020221210194225.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210194225.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>隐写术</title>
      <link>https://fzdwx.github.io/posts/2022-12-07-steganography/</link>
      <pubDate>Wed, 07 Dec 2022 21:37:59 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-12-07-steganography/</guid>
      <description>最近在跟 cs61c，第一个 project 中介绍了隐写术，大意可以理解为一个文件的内容是&lt;code&gt;123&lt;/code&gt;,在经过特定的编码转换后成了&lt;code&gt;456&lt;/code&gt;。</description>
      <content:encoded><![CDATA[<p>在这个项目中是用的图片来作为案例的，首先通过介绍了一种图片的编码形式, ppm:</p>
<ul>
<li>第一行表示是什么格式的 ppm 文件</li>
<li>第二行表示宽和高</li>
<li>第三行表示颜色范围</li>
<li>后面的就是各个像素的RGB值</li>
</ul>
<pre tabindex="0"><code class="language-ppm" data-lang="ppm">P3
2 2
255
 29  83  36      45  64  57   
188 229 201     123 162 184   
</code></pre><p>他是这么介绍的:</p>
<blockquote>
<p>我们将探索一种隐藏消息的方法。虽然大多数图像的每个 RGB 通道都有 8 位数据，但人眼无法轻易看出后 4 位的差异。因此，我们可以将信息隐藏在图像的底部位中。我们通过修改每个像素 B 值的最低有效位, 如果最后一位是 0，则把整个像素转换为黑色(255,255,255),如果最后一位是 1,则转换为白色(0,0,0)。</p>
</blockquote>
<p>关键就是： <strong>每个 RGB 通道都有 8 位数据，但人眼无法轻易看出后 4 位的差异</strong>，所以这就给了我们操作的空间。</p>
<p><figure id="a-/images/14.png" class="align-center">
    <img src="/images/14.png" alt="项目的结果"  />
    
    <figcaption>
       项目的结果
    </figcaption>
    
</figure></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
