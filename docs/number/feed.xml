<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>number on fzdwx</title>
    <link>https://fzdwx.github.io/docs/number/</link>
    <description>Recent content in number on fzdwx</description>
    <image>
      <url>https://fzdwx.github.io/images/party_parrot.gif</url>
      <link>https://fzdwx.github.io/images/party_parrot.gif</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx)   since 2022</copyright>
    <lastBuildDate>Fri, 09 Dec 2022 19:02:32 +0800</lastBuildDate><atom:link href="https://fzdwx.github.io/docs/number/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浮点数在计算机中的表示</title>
      <link>https://fzdwx.github.io/document/2022-12-09-float-rep/</link>
      <pubDate>Fri, 09 Dec 2022 19:02:32 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/document/2022-12-09-float-rep/</guid>
      <description>简单介绍浮点数的几种表示方式以及 RISC-V 中相关的浮点寄存器</description>
      <content:encoded><![CDATA[<h2 id="表示方法">表示方法</h2>
<figure class="align-center">
    $$(-1)^{S}\times(1.xxx&hellip;x_{2}\times2^{{yyy&hellip;y}_{2}})$$

    
    <figcaption>
        指数表示Y,尾数表示X
    </figcaption>
    
</figure>
<p><figure id="a-/images/Pasted%20image%2020221209193439.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193439.png" alt="单精度的表示方法"  />
    
    <figcaption>
       单精度的表示方法
    </figcaption>
    
</figure></p>
<p><figure id="a-/images/Pasted%20image%2020221209193511.png" class="align-center">
    <img src="/images/Pasted%20image%2020221209193511.png" alt="双精度的表示方法"  />
    
    <figcaption>
       双精度的表示方法
    </figcaption>
    
</figure></p>
<p>公式:</p>
<figure class="align-center">
    $$(-1)^{S}\times{F}\times{2^{E}}$$

    
    <figcaption>
        F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。
    </figcaption>
    
</figure>
<h2 id="移码表示法">移码表示法</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 最理想的表示法是将最小的负指数表示为 00&hellip;00<sub>2</sub>， 将最大的正指数表示为 11&hellip;11<sub>2</sub>。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 </p>
</div>








<p>IEEE 754规定:</p>
<ol>
<li>单精度的偏移值为 127
<ol>
<li>指数为 -1 表示 -1 + 127<sub>10</sub> = 126<sub>10</sub> = 01111110<sub>2</sub></li>
<li>+1 = 1 + 127<sup>10</sup> = 128<sub>10</sub> = 10000000<sub>2</sub></li>
<li>最大指数为127</li>
<li>最小为-126</li>
</ol>
</li>
<li>双精度的指数偏移值为 1023
<ol>
<li>1023</li>
<li>-1022</li>
</ol>
</li>
</ol>
<p>带偏移值的指数意味着一个由浮点数表示的值实际上是:</p>
<figure class="align-center">
    $$(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$$

    
</figure>
<h3 id="表示---075sub10sub">表示 - 0.75<sub>10</sub></h3>
<p>分数表示为：</p>
<figure class="align-center">
    (-3/4)<sub>10</sub> = (-3/2<sup>2</sup>)<sub>10</sub>

    
</figure>
<p>二进制小数表示:</p>
<figure class="align-center">
    (-11/2<sup>2</sup>)<sub>10</sub> = -0.11<sub>2</sub>

    
    <figcaption>
        -11 右移 2 位
    </figcaption>
    
</figure>
<p>用科学计数法表示:</p>
<figure class="align-center">
    -0.11<sub>2</sub> x 2<sup>0</sup>

    
</figure>
<p>用规格化的科学计数法表示:</p>
<figure class="align-center">
    -1.1<sub>2</sub> x 2<sup>-1</sup>

    
</figure>
<p>由上面的公式的到：</p>
<figure class="align-center">
    $$(-1)^{S}\times{(1 + 有效位数)}\times{2^{指数 - 偏移值}}$$

    
</figure>
<ul>
<li>有效位数: 0.1<sub>2</sub></li>
<li>
<ul>
<li>1 = (- 1)<sup>S</sup> =&gt; S = 1<sub>2</sub></li>
</ul>
</li>
<li>指数 - 127 = -1 =&gt; 指数 = 126<sub>10</sub></li>
</ul>
<p>单精度可以表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210142957.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210142957.png" alt=""  />
    
</figure></p>
<p>双精度表示:</p>
<p><figure id="a-/images/Pasted%20image%2020221210143322.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143322.png" alt=""  />
    
</figure></p>
<h3 id="表示二进制浮点数为十进制浮点数">表示二进制浮点数为十进制浮点数</h3>
<p><figure id="a-/images/Pasted%20image%2020221210143423.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210143423.png" alt=""  />
    
</figure></p>
<ul>
<li>S = 1</li>
<li>有效位数: 0.01<sub>2</sub> =&gt; 1 x 2<sup>-2</sup>（右移两位） = 0.25</li>
<li>指数: 129</li>
</ul>
<p>根据公式:</p>
<p>$$(-1)^{1}\times{(1 + 0.25)}\times{2^{129 - 127}}$$</p>
<p>= $$-1\times1.25\times2^2$$</p>
<p>= $$-1.25\times4$$</p>
<p>= $$-5$$</p>
<blockquote>
<p>浮点加法与浮点乘法可以看 P&amp;H 3.5.4~3.5.5 &nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf" target="_blank" rel="noopener">https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf</a>
</p>
</blockquote>
<h2 id="risc-v-中的浮点指令">RISC-V 中的浮点指令</h2>
<ul>
<li>算术
<ul>
<li>加法: <code>fadd.s</code> <code>fadd.d</code>
<ul>
<li><code>fadd.s f0, f1, f2</code> =&gt; <code>f0 = f1 + f2</code></li>
</ul>
</li>
<li>减法：<code>fsub</code> <code>fsub</code>
<ul>
<li><code>fsub.s f0, f1, f2</code> =&gt; <code>f0 = f1 - f2</code></li>
</ul>
</li>
<li>乘法: <code>fmul</code>
<ul>
<li><code>fmul.s f0, f1, f2</code> =&gt; <code>f0 = f1 * f2</code></li>
</ul>
</li>
<li>除法: <code>fdiv</code>
<ul>
<li><code>fdivs f0, f1, f2</code> =&gt; <code>f0 = f1 / f2</code></li>
</ul>
</li>
<li>平方根: <code>fsqrt</code>
<ul>
<li><code>fsqrt.s f0, f1</code> =&gt; <code>$$f0 = \sqrt{f1}$$</code></li>
</ul>
</li>
</ul>
</li>
<li>比较
<ul>
<li>相等: <code>feq</code>
<ul>
<li><code>feq.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 == f1, else 0</code></li>
</ul>
</li>
<li>小于: <code>flt</code>
<ul>
<li><code>flt.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt; f1, else 0</code></li>
</ul>
</li>
<li>小于或等于: <code>fle</code>
<ul>
<li><code>fle.s x5, f0, f1</code> =&gt; <code>x5 = 1 if f0 &lt;= f1, else 0</code></li>
</ul>
</li>
<li>如果比较结果为 真，则将整点寄存器设置 1,否则为 0</li>
<li>所以可以使用整数分支指令 <code>beq</code> 和 <code>bne</code> 来比较结果并进行分支</li>
</ul>
</li>
<li>取存指令:
<ul>
<li>双：<code>fld</code> <code>fsd</code>
<ul>
<li><code>fld f0, 8(x5)</code> =&gt; <code>f0 = Memory[x5 + 8]</code></li>
<li><code>fsd f0, 8(x5)</code> =&gt; <code>Memory[x5 +8] = f0</code></li>
</ul>
</li>
<li>单:<code>flw</code> <code>fsw</code></li>
<li>浮点数据传输指令的基址寄存器仍为整点寄存器</li>
<li>在 RISC-V中有独立的浮点寄存器: f0 ~ f31</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述指令都有单双精度版本，单精度以 <code>.s</code> 结尾，双精度以 <code>.d</code> 结尾</p>
</blockquote>
<p>一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中</p>
<pre tabindex="0"><code class="language-ricv-v" data-lang="ricv-v">flw    f0, 0(x10)     // 加载一个 32bit 的数到 f0
flw    f1, 4(x10)     // 加载一个 32bit 的数到 f1
fadd.s f2, f0, f1     // f2 = f0 + f1
fsw    f2, 8(x10)     // 保存来自 f2 的 32bit 的数
</code></pre>




<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> <p>独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。</p>
<p>例如一些寄存器中所有类型的操作数转换为单一的内部格式。</p>
 </p>
</div>








<h3 id="将一段-c-代码转换成-risc-v-的的汇编代码">将一段 C 代码转换成 RISC-V 的的汇编代码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">f2c</span><span class="p">(</span><span class="kt">float</span> <span class="n">qwe</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">retrun</span> <span class="p">((</span><span class="mf">5.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">qwe</span> <span class="o">-</span> <span class="mf">32.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设参数 <code>qwe</code> 传入到寄存器 <code>f10</code> 中，且结果也存入 <code>f10</code>中:</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">f2c:
	flw    f0, const5(x3)  // f0 = 5.0f
	flw    f1, const9(x3)  // f1 = 9.0f
	fdiv.s f0, f0, f1      // f0 = 5.0f / 9.0f
	flw    f1, const32(x3) // f1 = 32.0f
	fsub.s f10, f10, f1    // f10 = qwe - 32.0f
	fmul.s f10, f0,  f10   // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); 
	jalr   x0, 0(x1)       // retrun
</code></pre><p>假设通过 <code>x3</code> 访问上面3个常量浮点数</p>
<h3 id="将二维矩阵的c代码转换为risc-v的汇编代码">将二维矩阵的C代码转换为RISC-V的汇编代码</h3>
<figure class="align-center">
    $$C=C+A\times{B}$$

    
</figure>
<p>假设A, B, C都是 32 x 32 的二维矩阵</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mm</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[][]){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">	mm:...
		li x28, 32        // x28 = 32
		li x5, 0          // i = 0;
L1:		li x6, 0          // j = 0;
L2:		li x7, 0          // k = 0;
		slli x30, x5, 5   // x30 = i * 2 ^ 5(size of row of c)
		add x30, x30, x6  // x30 = i * size(row) + j
		slli x30, x30, 3  // x30 = byte offset of [i][j] 8个字节,左移3位
		add x30, x10, x30 // x30 = byte address of c[i][j]
		fld f0, 0(x30)    // f0 = 8 bytes of c[i][j]
L3:     slli x29, x7, 5   // x29 = k * 2 ^ 5
		add x29, x29, x6  
		slli x29, x29, 3
		add x29, x12, x29
		fld f1, 0(x29)     // f1 = 8 bytes of b[k][j]
		slli x29,x5 5      // x29 = i * 2 ^ 5
		add x29, x29, x7
		slli x29, x29, 3
		add x29, x11, x29
		fld f2, 0(x29)     // f2 = a[i][k]
		fmul.d f1, f2, f1  // f1 = a[i][k] * b[k][j]
		fadd.d f0, f0 ,f1  // f0 = c[i][j] + a[i][k] * b[k][j]
		addi x7, x7, 1     // k = k + 1
		bltu x7, x28, L3   // if (k &lt; 32) go to L3
		fsd f0, 0(x30)     // c[i][j] = f0
		addi x6, x6, 1     // j = j + 1
		bltu x6, x28, L2   // if (j &lt; 32) go to L2
		addi x5, x5, 1     // i = i + 1
		bltu x5, x28, 1    // if (i &lt; 32) go to L1
</code></pre><h2 id="一些c语言和java的数据类型数据传输指令">一些C语言和Java的数据类型、数据传输指令：</h2>
<p><figure id="a-/images/Pasted%20image%2020221210170829.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210170829.png" alt=""  />
    
</figure></p>
<h3 id="二进制浮点数表示图">二进制浮点数表示图</h3>
<p><figure id="a-/images/Pasted%20image%2020221210194225.png" class="align-center">
    <img src="/images/Pasted%20image%2020221210194225.png" alt=""  />
    
</figure></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Number Representation</title>
      <link>https://fzdwx.github.io/document/2022-11-22-number/</link>
      <pubDate>Tue, 22 Nov 2022 16:01:52 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/document/2022-11-22-number/</guid>
      <description>bit 可以表示任何事物
例如表示26个字符: 5 bits(2^5 = 32)
Binary,Decimal,Hex Decimal 十进制简单的介绍以及组成 Binary (to Decimal) 二进制的介绍以及转换到十进制 Hexadecimal (to Decimal) 十六至进制的介绍以及转换到十进制 Convert 进制转换
Convert from Decimal to Binary 13转换到二进制 Convert from Decimal to Hexadecimal 165转换到十六进制 Convert Binary &amp;lt;&amp;ndash;&amp;gt; Hexadecimal 一张非常有用的对照图 Binary -&amp;gt; Hex 向左填充完整的4位数: 0b11110 -&amp;gt; ob00011110
然后根据上图进行转换最后得到 1E Hex -&amp;gt; Binary 转换0xA87 -&amp;gt; 0b101010000111
Number Representation Overflow TIP 比如 add(or -,*,/)的结果不能由已经固定的 bit 表示则称为 overflow. 例如0b1010(10) + 0b0111(7) = 0b10001(17),这个结果就超过了 4 位数</description>
      <content:encoded><![CDATA[<blockquote>
<p>bit 可以表示任何事物</p>
</blockquote>
<p>例如表示26个字符: 5 bits(2^5 = 32)</p>
<h1 id="binarydecimalhex">Binary,Decimal,Hex</h1>
<h2 id="decimal">Decimal</h2>
<p><figure id="a-/images/img_1.png" class="align-center">
    <img src="/images/img_1.png" alt="十进制简单的介绍以及组成"  />
    
    <figcaption>
       十进制简单的介绍以及组成
    </figcaption>
    
</figure></p>
<h2 id="binary-to-decimal">Binary (to Decimal)</h2>
<p><figure id="a-/images/img.png" class="align-center">
    <img src="/images/img.png" alt="二进制的介绍以及转换到十进制"  />
    
    <figcaption>
       二进制的介绍以及转换到十进制
    </figcaption>
    
</figure></p>
<h2 id="hexadecimal-to-decimal">Hexadecimal (to Decimal)</h2>
<p><figure id="a-/images/img_2.png" class="align-center">
    <img src="/images/img_2.png" alt="十六至进制的介绍以及转换到十进制"  />
    
    <figcaption>
       十六至进制的介绍以及转换到十进制
    </figcaption>
    
</figure></p>
<h1 id="convert">Convert</h1>
<p>进制转换</p>
<h2 id="convert-from-decimal-to-binary">Convert from Decimal to Binary</h2>
<p><figure id="a-/images/img_3.png" class="align-center">
    <img src="/images/img_3.png" alt="13转换到二进制"  />
    
    <figcaption>
       13转换到二进制
    </figcaption>
    
</figure></p>
<h2 id="convert-from-decimal-to-hexadecimal">Convert from Decimal to Hexadecimal</h2>
<p><figure id="a-/images/img_4.png" class="align-center">
    <img src="/images/img_4.png" alt="165转换到十六进制"  />
    
    <figcaption>
       165转换到十六进制
    </figcaption>
    
</figure></p>
<h2 id="convert-binary----hexadecimal">Convert Binary &lt;&ndash;&gt; Hexadecimal</h2>
<p><figure id="a-/images/img_5.png" class="align-center">
    <img src="/images/img_5.png" alt="一张非常有用的对照图"  />
    
    <figcaption>
       一张非常有用的对照图
    </figcaption>
    
</figure></p>
<h3 id="binary---hex">Binary -&gt; Hex</h3>
<p>向左填充完整的4位数: <code>0b11110</code> -&gt; <code>ob00011110</code></p>
<p><figure id="a-/images/img_6.png" class="align-center">
    <img src="/images/img_6.png" alt="然后根据上图进行转换最后得到 1E"  />
    
    <figcaption>
       然后根据上图进行转换最后得到 1E
    </figcaption>
    
</figure></p>
<h3 id="hex---binary">Hex -&gt; Binary</h3>
<p>转换<code>0xA87</code> -&gt; <code>0b101010000111</code></p>
<h1 id="number-representation">Number Representation</h1>
<h2 id="overflow">Overflow</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 比如 add(or -,*,/)的结果不能由已经固定的 bit 表示则称为 overflow. </p>
</div>








<p>例如<code>0b1010</code>(10) + <code>0b0111</code>(7) = <code>0b10001</code>(17),这个结果就超过了 4 位数</p>
<p><figure id="a-/images/img_7.png" class="align-center">
    <img src="/images/img_7.png" alt="5 bits的无符号的 overflow 示意图，如果11111在加1就回到了00000，同样如果00000减去1回到11111，这两种情况都是overflow"  />
    
    <figcaption>
       5 bits的无符号的 overflow 示意图，如果11111在加1就回到了00000，同样如果00000减去1回到11111，这两种情况都是overflow
    </figcaption>
    
</figure></p>
<h2 id="negative-number">Negative Number</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
        TIP
        
    </p>
    <p> 正数前导为0,负数前导为1. </p>
</div>








<ul>
<li>N = 5
<ul>
<li>2<sup>N-1</sup>非负数</li>
<li>2<sup>N-1</sup>负数</li>
<li>1个0</li>
</ul>
</li>
</ul>
<p><figure id="a-/images/img_8.png" class="align-center">
    <img src="/images/img_8.png" alt="1个符号位，4个有效的数字位"  />
    
    <figcaption>
       1个符号位，4个有效的数字位
    </figcaption>
    
</figure></p>
<h3 id="补码公式">补码公式</h3>
<ol>
<li>可以同位数乘以2的幂来表示正数和负数
<ul>
<li>d<sub>31</sub>x-(2<sup>31</sup>)+d<sub>30</sub>x-(2<sup>30</sup>)+..+d<sub>2</sub> x 2<sup>2</sup> + d<sub>1</sub>
x 2<sup>1</sup> + d<sub>0</sub> x 2<sup>0</sup></li>
<li>1101 -&gt; 1x-2^3+1x2^2+0x2^1+1x2^0=-8+4+0+1=-3</li>
</ul>
</li>
<li>可以先翻转 bit 然后加1
<ul>
<li>1101</li>
<li>0010</li>
<li>0011 -&gt; 1101</li>
<li>0011</li>
<li>1101</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
