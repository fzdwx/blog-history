<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>fzdwx</title>
    <link>https://fzdwx.github.io/</link>
    <description>Recent content on fzdwx</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright [fzdwx](https://github.com/fzdwx) since 2022</copyright>
    <lastBuildDate>Mon, 24 Oct 2022 07:43:57 +0000</lastBuildDate><atom:link href="https://fzdwx.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于 git 游离分支</title>
      <link>https://fzdwx.github.io/posts/2022-10-23-about-git-detached-head/</link>
      <pubDate>Sun, 23 Oct 2022 00:09:44 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-23-about-git-detached-head/</guid>
      <description>如何在切换了分支之后恢复游离分支提交的代码。</description>
      <content:encoded><![CDATA[<p>刚刚改&nbsp;<a href="https://github.com/fzdwx/nvim" target="_blank" rel="noopener">nvim</a>
配置时，不知道怎么回事，出现了游离分支(英文名称大概是 <em>detached head</em>)。主要症状就是
git提交不了，由于我用的 lazygit ，它的提示不明显，我以为提交了。然后后面打开 idea 看到底是什么。发现提示是游离分支，这个时候我也没在意。
最致命的操作来了: 我直接 checkout main 分支，然后今天晚上修改的记录全没了。</p>
<p>我的解决方案:</p>
<ol>
<li>查看 <code>git log</code>，只能显示当前分支的修改 commit 记录。 <strong>无效</strong></li>
<li>利用 idea 的 local history 功能，只能找到文件，文件里面的内容是空白的。 <strong>无效</strong></li>
<li>搜索 detached head 的解决方案，只能搜到没切换分支前的解决方案，不适用与我的现象。 <strong>无效</strong></li>
<li>最后搜索 git 查看所有 commit ，找到了: <code>git reflog</code>，它能显示可引用的历史版本记录，最后找到我要的那个 commit
之后直接<code>git rest --hard xxx</code>完美解决。</li>
</ol>
<p>说实话，有点慌也有点烦，如果找不回来我可能会弃坑 nvim 了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>写一个自己的github action</title>
      <link>https://fzdwx.github.io/posts/2022-10-15-about-github-action/</link>
      <pubDate>Sat, 15 Oct 2022 19:25:10 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-15-about-github-action/</guid>
      <description>起因是因为想要有一种可以不用编辑文件而作用到网站上的方式，然后就了解到了github action的形式。</description>
      <content:encoded><![CDATA[<p>主要原理就是通过github action的来监听issue的相关事件，然后读取issue中的内容创建文件提交到git上，最后直接部署。这样就能随时编辑并展示了。</p>
<p>具体可以看 &nbsp;<a href="https://github.com/fzdwx/add-event-to-myblog" target="_blank" rel="noopener">add event to myb log</a>
这个仓库，
以及&nbsp;<a href="https://github.com/fzdwx/fzdwx.github.io/blob/main/.github/workflows/add-event.yml" target="_blank" rel="noopener">使用方式</a>
。</p>
<p>接下来介绍如何开发一个github action</p>
<h3 id="1-克隆官方提供的template">1. 克隆官方提供的template</h3>
<p>官方主要对typescript的支持比较好，提供了一系列的&nbsp;<a href="https://github.com/actions/toolkit" target="_blank" rel="noopener">工具包</a>
，没办法只能同ts来进行开发，</p>
<p>&nbsp;<a href="https://github.com/actions/typescript-action" target="_blank" rel="noopener">https://github.com/actions/typescript-action</a>
</p>
<h3 id="2-定义想要在运行时用户输入的参数">2. 定义想要在运行时用户输入的参数</h3>
<p>通过编辑<code>action.yml</code>这个文件来定义想要在运行时定义的参数，比如说<code>GITHUB_TOKEN</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;add event to my blog&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;add event to my blog&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">author</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;fzdwx&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">branding</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;archive&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">color</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;white&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">inputs</span><span class="p">:</span><span class="w"> </span><span class="c"># 在这个key下面添加自定义参数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">token</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">required</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;the repo PAT or GITHUB_TOKEN&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">runs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">using</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;node16&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">main</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;dist/index.js&#39;</span><span class="w">
</span></span></span></code></pre></div><p>参数有三个属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">required</span><span class="p">:</span><span class="w"> </span><span class="l">是否必须</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l">描述</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">default</span><span class="p">:</span><span class="w"> </span><span class="l">默认值</span><span class="w">
</span></span></span></code></pre></div><h3 id="3-实现想要的功能">3. 实现想要的功能</h3>
<p>详细可以查看我的&nbsp;<a href="https://github.com/fzdwx/add-event-to-myblog/blob/v2.1/src/main.ts" target="_blank" rel="noopener">主要代码</a>
。我的里面主要做了:</p>
<ol>
<li>根据当前issue number&nbsp;<a href="https://github.com/fzdwx/add-event-to-myblog/blob/v2.1/src/main.ts#L16" target="_blank" rel="noopener">获取该issue的内容</a>
。</li>
<li>根据预定义的模板，&nbsp;<a href="https://github.com/fzdwx/add-event-to-myblog/blob/v2.1/src/main.ts#L18-L33" target="_blank" rel="noopener">创建文件内容</a>
。</li>
<li>提交到&nbsp;<a href="https://github.com/fzdwx/add-event-to-myblog/blob/v2.1/src/main.ts#L34-L38" target="_blank" rel="noopener">git</a>
上。</li>
</ol>
<h3 id="4-发布到marketplace">4. 发布到marketplace</h3>
<p>需要勾选<strong>Publish this Action to the GitHub Marketplace</strong>，可能需要2fa认证，找一个github支持就ok了。</p>
<p><figure id="a-/images/8.png" class="align-center">
    <img src="/images/8.png" alt="Figure 1"  />
    
    <figcaption>
       Figure 1
    </figcaption>
    
</figure></p>
<p>成功release后就能在别的项目中使用了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>在shell脚本中执行cd后改变main shell的路径</title>
      <link>https://fzdwx.github.io/posts/2022-10-11-about-source/</link>
      <pubDate>Tue, 11 Oct 2022 16:55:35 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-11-about-source/</guid>
      <description>起因 昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:
cd $(fd --type d | fzf) 这个命令也确实能完成任务，但是问题有两个:
如果直接退出的话会回到家目录，因为$(..)的执行结果为空 每次都要输入这么多会很麻烦 用alias 然后尝试用alias来试试，所以就往.zshrc里面添加:
alias cdf=&amp;#34;cd $(fd --type d | fzf)&amp;#34; 结果是直接不能运行，因为它直接识别了$(..)这一段，然后直接运行了，但是后面就不会运行。
用shell脚本 然后就写了这个文件:
#!/bin/sh path=$(fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules | fzf) if [ -z &amp;#34;$path&amp;#34; ]; then exit fi cd &amp;#34;$path&amp;#34; || exit 结果也是不行，后面我在最下面加了一行echo &amp;quot;$PWD&amp;quot;，我看到是执行了的，但是程序退出了就失效了。
解决 最后我搜索到可以使用source xxx或者. xxx来解决，最后是alias+shell脚本来完成这个操作的:
alias cdf=&amp;#34;source /path/to/cdf&amp;#34; 同时它也解决我上面提到的两个问题。
source为什么能解决？ 之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。
而source或者.就代表着在当前的shell环境中执行，所以就能成功。</description>
      <content:encoded><![CDATA[<h2 id="起因">起因</h2>
<p>昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> <span class="k">$(</span>fd --type d <span class="p">|</span> fzf<span class="k">)</span>
</span></span></code></pre></div><p>这个命令也确实能完成任务，但是问题有两个:</p>
<ol>
<li>如果直接退出的话会回到家目录，因为<code>$(..)</code>的执行结果为空</li>
<li>每次都要输入这么多会很麻烦</li>
</ol>
<h2 id="用alias">用alias</h2>
<p>然后尝试用alias来试试，所以就往<code>.zshrc</code>里面添加:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">cdf</span><span class="o">=</span><span class="s2">&#34;cd </span><span class="k">$(</span>fd --type d <span class="p">|</span> fzf<span class="k">)</span><span class="s2">&#34;</span>
</span></span></code></pre></div><p>结果是直接不能运行，因为它直接识别了<code>$(..)</code>这一段，然后直接运行了，但是后面就不会运行。</p>
<h2 id="用shell脚本">用shell脚本</h2>
<p>然后就写了这个文件:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/sh
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">path</span><span class="o">=</span><span class="k">$(</span>fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules <span class="p">|</span> fzf<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$path</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">    <span class="nb">exit</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> <span class="s2">&#34;</span><span class="nv">$path</span><span class="s2">&#34;</span> <span class="o">||</span> <span class="nb">exit</span>
</span></span></code></pre></div><p>结果也是不行，后面我在最下面加了一行<code>echo &quot;$PWD&quot;</code>，我看到是执行了的，但是程序退出了就失效了。</p>
<h2 id="解决">解决</h2>
<p>最后我搜索到可以使用<code>source xxx</code>或者<code>. xxx</code>来解决，最后是alias+shell脚本来完成这个操作的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">cdf</span><span class="o">=</span><span class="s2">&#34;source /path/to/cdf&#34;</span>
</span></span></code></pre></div><p>同时它也解决我上面提到的两个问题。</p>
<h2 id="source为什么能解决">source为什么能解决？</h2>
<p>之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。</p>
<p>而<code>source</code>或者<code>.</code>就代表着在当前的shell环境中执行，所以就能成功。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Code:alias</title>
      <link>https://fzdwx.github.io/posts/2022-10-10-code-alias/</link>
      <pubDate>Mon, 10 Oct 2022 22:43:27 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-10-code-alias/</guid>
      <description>idea 目前有一个想法，是在命令行下管理脚本的工具。
例如说我有一些常用的脚本:
cd $(find . -name &amp;#34;*&amp;#34; -type d | fzf) 然后通过命令行添加
cli load &amp;#34;cd $(find . -name &amp;#34;*&amp;#34; -type d | fzf)&amp;#34; -alias cdf 然后使用cdf进行运行
cli cdf 后续 2022-10-18 22:47
刚刚找到了一个跟我这个想法很契合的项目: &amp;nbsp;https://github.com/denisidoro/navi 。
今天一晚上都在调研技术的可行性，但是都达不到我想要的效果。还是这个例子，cd $(find . -name &amp;quot;*&amp;quot; -type d | fzf)， 主要有两种思路:
在运行程序的使用利用shell的tab键盘补全，直接替换成这段命令，然后运行。比如说程序叫qwe，在shell里面输入qwe cdf&amp;lt;TAB&amp;gt; ，然后就直接替换为上面的命令。我在go里面找到cobra这个包，它能动态补全命令，有点效果，但还不够，不能做到全部替换，遂搁置。 直接在程序里面运行这段命令，我试了之后还是不行，cd执行后没有生效，应该还是跟fork有关。 然后就到github里面找别人的实现，没想到找到了一个，但是试过之后还是不支持，但确实做的还不错。
想要做成我想要的效果就是实现:
在shell中补全能直接替换所有，而不是一段。 在程序中不用fork运行。 还需要在看看。</description>
      <content:encoded><![CDATA[<h2 id="idea">idea</h2>
<p>目前有一个想法，是在命令行下管理脚本的工具。</p>
<p>例如说我有一些常用的脚本:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">cd</span> <span class="k">$(</span>find . -name <span class="s2">&#34;*&#34;</span> -type d <span class="p">|</span> fzf<span class="k">)</span>
</span></span></code></pre></div><p>然后通过命令行添加</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">cli load <span class="s2">&#34;cd </span><span class="k">$(</span>find . -name <span class="s2">&#34;*&#34;</span> -type d <span class="p">|</span> fzf<span class="k">)</span><span class="s2">&#34;</span> -alias cdf
</span></span></code></pre></div><p>然后使用cdf进行运行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">cli cdf 
</span></span></code></pre></div><h2 id="后续">后续</h2>
<blockquote>
<p>2022-10-18 22:47</p>
</blockquote>
<p>刚刚找到了一个跟我这个想法很契合的项目: &nbsp;<a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a>
。</p>
<p>今天一晚上都在调研技术的可行性，但是都达不到我想要的效果。还是这个例子，<code>cd $(find . -name &quot;*&quot; -type d | fzf)</code>，
主要有两种思路:</p>
<ol>
<li>在运行程序的使用利用shell的tab键盘补全，直接替换成这段命令，然后运行。比如说程序叫<code>qwe</code>，在shell里面输入<code>qwe cdf&lt;TAB&gt;</code>
，然后就直接替换为上面的命令。我在go里面找到<code>cobra</code>这个包，它能动态补全命令，有点效果，但还不够，不能做到全部替换，遂搁置。</li>
<li>直接在程序里面运行这段命令，我试了之后还是不行，<code>cd</code>执行后没有生效，应该还是跟<code>fork</code>有关。</li>
</ol>
<p>然后就到github里面找别人的实现，没想到找到了一个，但是试过之后还是不支持，但确实做的还不错。</p>
<p>想要做成我想要的效果就是实现:</p>
<ol>
<li>在shell中补全能直接替换所有，而不是一段。</li>
<li>在程序中不用<code>fork</code>运行。</li>
</ol>
<p>还需要在看看。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Raft Kv</title>
      <link>https://fzdwx.github.io/posts/2022-10-10-raftkv/</link>
      <pubDate>Mon, 10 Oct 2022 22:26:55 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-10-raftkv/</guid>
      <description>Lab2文档翻译 由于我的英文不是很好，所以使用翻译软件进行翻译，然后人工进行校对进行理解。
原文地址: &amp;nbsp;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html Introduction 这是一系列实验中的第一个，我们将构建一个 fault-tolerant key/value storage system 。 在本实验中我们将实现 Raft (一种复制的状态机协议)。在下一个实验中，我们将在 Raft 上构建一个 key/value service 。 然后，您将在有多个副本的状态机上进行 shard(分片？根据 key 进行 hash 来决定路由到哪个副本上) 来提高性能。
复制(replication)通过在多个复制服务器上存储其状态(即数据)的完整副本来实现 fault tolerance 。 即使有一些服务器出现 failure (崩溃或网络断开和抖动) replication 也允许它们继续运行。 挑战在于 failures 可能导致副本存在不同的数据。
Raft 将客户端的请求组织成一个序列，被称为 log ，并且确保所有 replica servers 看到相同的 log 。 每个 replica 按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本(就是运行来自客户端的命令)。 由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。 如果一个服务器发生了 failure 但是后来又 recovery (恢复) 了，Raft 会负责将它的 log 更新到最新状态。只要至少大多数的服务器还活着，并且能够继续通信， 那么 Raft 将持续运行。如果没有到达这个数量，那么 Raft 将会停止运行，直到达到这个数量才会重新开始运行。
在本 lab 中，你将把 Raft 实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。 一组 Raft 实例通过 RPC 来维护 replicated logs。你的 Raft 实例将支持一连串不确定编号的 command， 也可以叫 log entries。 这些 entity 通过 index(索引)来进行编号。具有给定索引的 log entry 将被 commit， 此时，您的 Raft 应该将这条 log 发送到 larger service 上执行。</description>
      <content:encoded><![CDATA[<h1 id="lab2文档翻译">Lab2文档翻译</h1>
<p>由于我的英文不是很好，所以使用翻译软件进行翻译，然后人工进行校对进行理解。</p>
<p>原文地址: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a>
</p>
<h2 id="introduction">Introduction</h2>
<p>这是一系列实验中的第一个，我们将构建一个 <em>fault-tolerant key/value storage system</em> 。
在本实验中我们将实现 <em>Raft (一种复制的状态机协议)</em>。在下一个实验中，我们将在 Raft 上构建一个 key/value service 。
然后，您将在有多个副本的状态机上进行 shard(分片？根据 key 进行 hash 来决定路由到哪个副本上) 来提高性能。</p>
<p>复制(replication)通过在多个复制服务器上存储其状态(即数据)的完整副本来实现 <em>fault tolerance</em> 。
即使有一些服务器出现 failure (崩溃或网络断开和抖动) replication 也允许它们继续运行。 挑战在于 failures 可能导致副本存在不同的数据。</p>
<p>Raft 将客户端的请求组织成一个序列，被称为 log ，并且确保所有 replica servers 看到相同的 log 。
每个 replica 按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本(就是运行来自客户端的命令)。
由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。
如果一个服务器发生了 failure 但是后来又 recovery (恢复) 了，Raft 会负责将它的 log 更新到最新状态。只要至少大多数的服务器还活着，并且能够继续通信，
那么 Raft 将持续运行。如果没有到达这个数量，那么 Raft 将会停止运行，直到达到这个数量才会重新开始运行。</p>
<p>在本 lab 中，你将把 Raft 实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。
一组 Raft 实例通过 RPC 来维护 replicated logs。你的 Raft 实例将支持一连串不确定编号的 command，
也可以叫 log entries。 这些 entity 通过 index(索引)来进行编号。具有给定索引的 log entry 将被 commit，
此时，您的 Raft 应该将这条 log 发送到 larger service 上执行。</p>
<p>你应该遵循&nbsp;<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">extended Raft paper</a>
中设计，
特别是&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-2">图2</a>
.你将实现论文中的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。
你将不会实现集群成员的变化(Section 6)。</p>
<p>你可能会发现这个&nbsp;<a href="https://thesquareplanet.com/blog/students-guide-to-raft/" target="_blank" rel="noopener">指南</a>
很有用，
还有这个关于concurrency的&nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt" target="_blank" rel="noopener">锁</a>

和&nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt" target="_blank" rel="noopener">结构</a>
的建议，
如果需要更广泛的视角，可以看看 Paxos,Chubby,Paxos Made Live,Spanner,Zookeeper,Harp,Viewstamped Replication
和&nbsp;<a href="https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf" target="_blank" rel="noopener">Bolosky et al</a>
。</p>
<p>请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。
你可以参考&nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html" target="_blank" rel="noopener">指导页</a>
和这篇关于有效打印声明的&nbsp;<a href="https://blog.josejg.com/debugging-pretty/" target="_blank" rel="noopener">博文</a>
。</p>
<p>我们还提供了&nbsp;<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf" target="_blank" rel="noopener">Raft 交互图</a>
，
可以帮助阐明Raft代码如何与上层(使用者?)交互。</p>
<h2 id="the-code">The code</h2>
<p>通过向<code>raft/raft.go</code>添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。
你的实现必须支持以下接口，测试者和(最终)你的 key/value service 将使用该接口。你可以在<code>raft.go</code>的注释中找到更多细节。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
            TIP
        
    </p>
    <p> Raft 实例只能通过 rpc 进行通信且必须使用<code>labrpc</code>这个包(例如不能使用文件以及共享变量)。 </p>
</div>

<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// create a new Raft server instance:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rf</span> <span class="o">:=</span> <span class="nf">Make</span><span class="p">(</span><span class="nx">peers</span><span class="p">,</span> <span class="nx">me</span><span class="p">,</span> <span class="nx">persister</span><span class="p">,</span> <span class="nx">applyCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// start agreement on a new log entry:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rf</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">command</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">term</span><span class="p">,</span> <span class="nx">isleader</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ask a Raft for its current term, and whether it thinks it is leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetState</span><span class="p">()</span> <span class="p">(</span><span class="nx">term</span><span class="p">,</span> <span class="nx">isLeader</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// each time a new entry is committed to the log, each Raft peer
</span></span></span><span class="line"><span class="cl"><span class="c1">// should send an ApplyMsg to the service (or tester).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ApplyMsg</span>
</span></span></code></pre></div><h3 id="make">Make</h3>
<blockquote>
<p>Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg)</p>
</blockquote>
<p>用于创建 Raft server。</p>
<ol>
<li>所有的 raft server 的端口都在<code>peers[]</code>存放(包括当前的服务)，当前服务的端口可以通过<code>peers[me]</code>来获取。</li>
<li>所有的服务的<code>perrs[]</code>数组都具有相同的顺序。</li>
<li><code>presister</code>是一个用来存放<code>persistent state</code>的地方，并且在初始的时候会保存最具的状态，如果有。</li>
<li><code>applyCh</code>是 service 或 tester 发送消息给 raft 的通道。<code>Make()</code>
必须快速返回，所以它应该为一些长时间运行的任务启动<code>goruntines</code>。</li>
</ol>
<h3 id="start">Start</h3>
<p>使用 Raft 的服务（例如 kv 服务器）希望就下一个要附加到 Raft 日志的命令开始协议。如果此服务器不是领导者，则返回
false。否则启动协议并立即返回。无法保证此命令将永远提交到 Raft 日志，因为领导者可能会失败或失去选举。即使 Raft
实例被杀死，这个函数也应该优雅地返回。第一个返回值是该命令在提交时将出现的索引。第二个返回值是当前术语。如果此服务器认为它是领导者，则第三个返回值为
true。</p>
<blockquote>
<p>Start(command interface{}) (int, int, bool)</p>
</blockquote>
<p>使用 Raft 的服务(e.g k/v server)希望就下一个要追加到 Raft 日志的命令开始协议。
如果当前 Raft server 不是 leader 则返回<code>false</code>。否则启动协议并立即返回，无需等待日志追加完成。
所以无法保证此命令将一定会被提交到 Raft 日志中，因为 leader 可能会失败或者在输掉选举。
即使 Raft 实例被 kill 这个函数也应该 return gracefully(优雅返回)。</p>
<p>第一个返回值是该命令在 commit 时将被设置的 index。第二个返回值是当前的 term(任期)。如果此服务器认为自己是 leader
则第三个返回值是<code>true</code>。</p>
<p>每个新提交的<code>Raft log entity</code>都应该发送一个<code>AppliMsg</code>到<code>Make()</code>的<code>applyCh</code>中。</p>
<h2 id="2a">2A</h2>
<p>实现 Raft leader election 以及 heartbeats(<code>AppendEntries RPCs</code>中不附带 log entries)。</p>
<p>2A的目标是: 选出一个 leader，如果没有 failure，它仍然是 leader，如果 old leader 失败或者与 old leader 之间的数据包发生丢失则由
new
leader 接管。</p>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
            TIP
        
    </p>
    <p> 这个失败是 leader 出现故障的意思？就是说只要它没出现运行故障或者网络问题就永远是leader？ </p>
</div>

<p>要点:</p>
<ol>
<li>通过运行<code>go test -run 2A</code>来进行测试你的实现。</li>
<li>按照论文的&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-2">图2</a>
，主要关心发送和接收<code>RequestVote RPCs</code>
，与<code>the Rules for Servers that relate to elections</code>
以及<code>the State related to leader election</code>。</li>
<li>添加&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-2">图2</a>
中与 leader election 相关的状态到<code>Raft</code>这个结构体中，且还需要定义一个结构来保存每个日志的信息。</li>
<li>实现<code>RequestVote()</code>，这样 raft 服务们就能互相投票了。添加<code>RequestVOteArgs</code>和<code>RequestVoteReply</code>者两个结构体。修改<code>Make()</code>
，创建一个 goroutine，用于检查心跳消息，如果有一段时间没有收到 peer 的消息时将发送<code>RequestVote RPCs</code>来定期发起领导者选举。这样，如果有
leader 了，peer 将知道谁是 leader，或者自己成为 leader。</li>
<li>实现心跳，需要定义一个<code>AppendEntries RPC</code>结构(尽管你可能还不需要所有参数)，
并且让 leader 定期发送它。编写一个<code>AppendEntries RPC</code>的 handle method，用于重置选举超时，
这样当有一个人已经当选时，其他服务器不会又成为 leader。</li>
<li>确保不同 peer 的选举超时不在同一时间发生，否则所有peer将只为自己投票，这样就没有人会成为leader了。</li>
<li>在测试时，leader 每秒发送的RPC请求不能超过 10 次。</li>
<li>在测试时，要求 Raft 在 old leader 失败后5秒内选举 new leader(如果大多数节点仍然能继续通讯)。
但是请记住，如果出现<code>split vote</code>(如果数据包丢失或者候选人选择了相同的随机退避时间就有可能发生)，leader 选举可能需要多轮。
所以必须设置足够短的选举超时(也就是心跳间隔)，即使会选举多轮，也有可能在5秒内完成。</li>
<li>论文的&nbsp;<a href="/posts/2022-10-10-raftkv/#leader-election">Leader election</a>
这一节中提到的选举超时范围是150到300毫秒。
只有当 leader 发送心跳的频率大大高于150毫秒一次时，上面提到的范围才有意义。由于在测试时限制每秒10次心跳，
所以必须使用比论文中更大的选举超时时间，但是不能太大，因为可能会无法在5秒内完成选举。</li>
<li>如果您的代码无法通过测试，请再次阅读论文中的&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-2">图2</a>
，leader 选举的全部逻辑分布在图中多个部分。</li>
<li>不要忘记实现<code>GetState()</code>。</li>
<li>在测试时，如果要关闭一个raft实例，会调用<code>rf.kill()</code>。我们可以调用<code>rf.killed</code>来检查是否被调用了<code>kill()</code>。您可能希望在所有的循环中都这样
做，以避免死亡的Raft实例打印混乱的信息。</li>
<li><code>go RPC</code>只发送名称以大写字母开头的结构体字段。子结构体也必须拥有大写的字段名。</li>
</ol>
<h1 id="raft论文翻译">Raft论文翻译</h1>
<blockquote>
<p>选取一些重要的片段进行翻译</p>
</blockquote>
<p>原文地址: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a>
</p>
<h2 id="introduction-1">Introduction</h2>
<p>Raft 算法和已经存在的共识算法在某些地方很相似(主要是 Oki 以及 Liskov&rsquo;s Viewstamped Replication)，但是它有以下新特性:</p>



<details class="details custom-block">
    <summary> 原文</summary>
    raft is similar in many ways to existing consensus algorithms (most notably, Oki and Liskov’s Viewstamped
Replication), but it has several novel features:
</details>



<ul>
<li>强领导者: Raft 使用一种比其他共识算法更强的领导形式。例如，日志只从 leader 发送给其他服务器。这简化了对复制日志的管理，使的
Raft 更容易理解。</li>
<li>领导选举: Raft 使用随机的计时器来选取 leader。这种方式仅仅是在所有共识算法都需要改进的心跳机制上有些许改进，然而这使得
Raft 在解决冲突时更简单和快速。</li>
<li>成员调整: 集群中更改 server 时，Raft 使用了新的联合共识(join consensus)算法，
两种不同的配置的majorities在变更期间重叠(overlap)， 允许集群在配置变更的时候，持续正常运行。</li>
</ul>



<details class="details custom-block">
    <summary> 原文</summary>
    <ul>
<li>Strong leader: Raft uses a stronger form of leadership than other consensus algorithms. For example,log entries
only flow from the leader to other servers. This simplifies the management of the replicated log and makes Raft
easier to understand.</li>
<li>Leader election: Raft uses randomized timers to elect leaders. This adds only a small amount of mechanism to the
heartbeats already required for any consensus algorithm, while resolving conflicts simply and rapidly.</li>
<li>Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus
approach where the majorities of two different configurations overlap during transitions. This allows the cluster
to continue operating normally during configuration changes.</li>
</ul>

</details>



<h2 id="replicated-state-machine">Replicated State Machine</h2>
<p><code>复制状态机(Replicated State Machine)</code>在分布式系统中被用于解决各种容错问题。例如GFS,HDFS,RAMCloud等单leader的大型集群系统，通常使用独立
的复制状态机来管理领导选举和存储配置信息来保证在leader崩溃会存活下来，复制状态机的例子包括Chubby以及Zookeeper。</p>
<p><figure id="a-/images/7.png" class="align-center">
    <img src="/images/7.png" alt="Figure 1: 复制状态机架构。共识算法管理来自客户端的包含状态机命令的复制日志，状态机按照相同的顺序来处理它们，所以它们产生相同的输出。"  />
    
    <figcaption>
       Figure 1: 复制状态机架构。共识算法管理来自客户端的包含状态机命令的复制日志，状态机按照相同的顺序来处理它们，所以它们产生相同的输出。
    </figcaption>
    
</figure></p>
<p>共识算法通常出现在复制状态机的上下文中，在这种方法中，在一组server上的状态机对同一个的状态会计算出相同的副本，即使一些server宕机也可以继续运行。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Replicated state machines are used to solve a variety of fault tolerance problems in distributed systems. For example,
large-scale systems that have a single cluster leader, such as GFS, HDFS, and RAMCloud, typically use a separate
replicated state machine to manage leader election and store configuration information that must survive leader
crashes. Examples of replicated state machines include Chubby and ZooKeeper. Consensus algorithms typically arise in
the context of replicated state machines.In this approach, state machines on a collection of servers compute identical
copies of the same state and can continue operating even if some of the servers are down.
</details>



<p>复制状态机通过<strong>复制日志实现</strong>，如图一所示。每个服务保存包含一系列命令的日志，其状态机按照顺序来执行它们。
每个<strong>日志包含相同顺序的相同命令</strong>，所以每个状态机处理相同的命令序列。因为<strong>状态机是确定的</strong>，
所以每个状态机<strong>会计算出相同的状态</strong>和<strong>相同顺序的输出</strong>。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a
log containing a series of commands, which its state machine executes in order. Each log contains the same commands in
the same order, so each state machine processes the same sequence of commands. Since the state machines are
deterministic, each computes the same state and the same sequence of outputs.
</details>



<p>共识算法的任务是<strong>保证复制日志的一致性</strong>。服务器上的共识模块接收来自客户端的命令并把它们添加到日志中，
并与其他服务器上的共识模块进行通讯以确保它们的每一条日志最终都相同(相同的请求有相同的顺序)， 即使有一些服务失败了。一旦命令被正确的复制，
每一个服务的状态机会按照日志的顺序去处理它们，然后将结果返回给客户端。</p>
<p>因此，这些服务似乎成为了一个单一的，高度可靠的状态机。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Keeping the replicated log consistent is the job of the consensus algorithm. The consensus module on a server receives
commands from clients and adds them to its log. It communicates with the consensus modules on other servers to ensure
that every log eventually contains the same requests in the same order, even if some servers fail. Once commands are
properly replicated, each server’s state machine processes them in log order, and the outputs are returned to clients.
As a result, the servers appear to form a single, highly reliable state machine.
</details>



<p>在实际的共识算法通常有以下属性:</p>
<ul>
<li>确保非拜占庭(non-Byzantine)条件下的<em>安全性</em>(永远不返回错误的结果)，包括网络延迟，分区以及网络数据包丢失、冗余、乱序。</li>
<li>只要大多数的服务都在运行并能相互通信且和客户端通信，它们就能发挥出全部的功能(<em>可用性</em>)。因此，一个5台服务的集群能容忍2台服务出现故障。
假定服务应为停机而出现故障，它们可能稍后会从stable storage`中恢复状态并从新加入集群。</li>
<li>不依赖与timing来保证日志的一致性: 错误的时钟和极端的信息延迟延迟在最坏的情况下会导致可用性问题。</li>
<li>在一般情况下，一个命令的完成在于集群中的大多数对单轮远程调用作出响应，少数低水平的服务不会影响系统的整体性能。</li>
</ul>



<details class="details custom-block">
    <summary> 原文</summary>
    <p>Consensus algorithms for practical systems typically have the following properties:</p>
<ul>
<li>They ensure <em>safety</em> (never returning an incorrect result) under all non-Byzantine conditions,
including network delays, partitions, and packet loss, duplication, and reordering.</li>
<li>They are fully functional (<em>available</em>) as long as any
majority of the servers are operational and can communicate with each other and with clients. Thus, a
typical cluster of five servers can tolerate the failure of any two servers. Servers are assumed to fail by
stopping; they may later recover from state on stable storage and rejoin the cluster.</li>
<li>They do not depend on timing to ensure the consistency of the logs: faulty clocks and extreme message
delays can, at worst, cause availability problems.</li>
<li>In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of
remote procedure calls; a minority of low servers need not impact overall system performance.</li>
</ul>

</details>



<h2 id="the-raft-consensus-algorithm">The Raft consensus algorithm</h2>
<p>Raft就是用于管理上一解描述的复制日志的算法。&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-2">图2</a>

是对该算法的精简型式的总结，&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
列出来该算法的关键属性，接下来对这些部分进行逐一讨论。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft is an algorithm for managing a replicated log of the form described in Section 2. Figure 2 summarizes the
algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm; the elements of these
figures are discussed piecewise over the rest of this section.
</details>



<p>Raft首先通过选举出一位 <em>leader</em> 来实现共识，然后由leader完全管理日志复制。leader接收来自客户端的日志，然后复制给其他服务，并且通知在何时
它们可以安全的消费(作用到状态机上)这些日志。leader简化了日志复制的管理。例如: leader可以自主确定新日志存放在哪个位置而不用询问其他服务，
数据以一种简单的方式从leader流向其他服务。leader可以失败以及断开连接，这个时候需要重新选举leader。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for
managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells
servers when it is safe to apply log entries to their state machines. Having a leader simplifies the management of the
replicated log. For example, the leader can decide where to place new entries in the log without consulting other
servers, and data flows in a simple fashion from the leader to other servers. A leader can fail or become disconnected
from the other servers, in which case a new leader is elected.
</details>



<p>基于leader的方法，Raft将一致性问题为了三个子过程来解决:</p>
<ul>
<li>leader选举: 当leader失败(宕机)时需要选举新leader</li>
<li>日志复制: leader接收来自客户端的日志，并复制给集群中的其他机器，强制其他服务器与自己的一致</li>
<li>安全: Raft的安全就在于&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
中的安全属性: 如果任何服务器消费了一个日志，那么其他任何服务器就不
能在相同的日志索引消费不同的日志</li>
</ul>



<details class="details custom-block">
    <summary> 原文</summary>
    <p>Given the leader approach, Raft decomposes the consensus problem into three relatively independent subproblems, which
are discussed in the subsections that follow:</p>
<ul>
<li>Leader election: a new leader must be chosen when an existing leader fails</li>
<li>Log replication: the leader must accept log entries from clients and replicate them across the cluster,
forcing the other logs to agree with its own</li>
<li>Safety: the key safety property for Raft is the State Machine Safety Property in Figure 3: if any server has applied
a particular log entry to its state machine, then no other server may apply a different command for the same log
index. Section 5.4 describes how Raft ensures this property; the solution involves an additional restriction on the
election mechanism described in Section 5.2.</li>
</ul>

</details>



<h3 id="figure-2">Figure 2</h3>
<p><figure id="a-/images/raftp2.png" class="align-center">
    <img src="/images/raftp2.png" alt="Figure 2: Raft共识算法的精简摘要(不包括成员更改以及日志压缩)。左上角的服务器行为被描述为一组独立且重复触发的规则。"  />
    
    <figcaption>
       Figure 2: Raft共识算法的精简摘要(不包括成员更改以及日志压缩)。左上角的服务器行为被描述为一组独立且重复触发的规则。
    </figcaption>
    
</figure></p>
<p><strong>state</strong>:</p>
<ul>
<li>在所有服务器上持久化(在响应RPCs之前进行更新)
<ul>
<li><code>currentTerm</code>: 服务器知道的最后的任期号(初始0，单调递增)</li>
<li><code>votedFor</code>: 当前服务器投给哪个服务器？</li>
<li><code>log[]</code>: 日志，包含要执行的命令以及收到该日志的时间。</li>
</ul>
</li>
<li>在所有服务器上不稳定存在
<ul>
<li><code>commitIndex</code>: 已知的提交的日志中的最大索引(初始0，单调递增)</li>
<li><code>lastApplied</code>: 状态机执行的日志中的最大索引(初始0，单调递增)</li>
</ul>
</li>
<li>在leader上不稳定存在(在每次重新选举后初始化)
<ul>
<li><code>nextIndex[]</code>: 对于每一个服务器，记录需要发给它的下一个日志条目的索引(初始为leader的最后一条日志索引+1)</li>
<li><code>matchIndex[]</code>: 对于每一个服务器，记录已经复制到该服务器的日志的最高索引值(初始0，单调递增)</li>
</ul>
</li>
</ul>
<p><strong>AppendEntries RPC</strong></p>
<blockquote>
<p>由leader发起调用来复制日志，同时也用于心跳检测</p>
</blockquote>
<ul>
<li>Arguments:
<ul>
<li><code>term</code>: leader的任期</li>
<li><code>leaderId</code>: 用于follower找到leader</li>
<li><code>prevLogIndex</code>: 前一个日志的索引</li>
<li><code>prevLogTerm</code>: 前一个日志的<code>term</code></li>
<li><code>entries[]</code>: 用于存放日志(为空时是心跳检测，可能一次会发送多条来提升效率)</li>
<li><code>leaderCommit</code>: leader的<code>commitIndex</code></li>
</ul>
</li>
<li>Results:
<ul>
<li><code>term</code>: <code>currentTerm</code>，用于leader更新自己的<code>term</code></li>
<li><code>success</code>: 如果follower的<code>pervLogIndex</code>以及<code>prevLogTerm</code>能够匹配上则为true</li>
</ul>
</li>
<li>Receiver implementation:
<ul>
<li><code>if term &lt; currentTerm then return false</code>(如果 term &lt; currentTerm返回 false)</li>
<li><code>if log[prevLogIndex].term != prevLogTerm then return false</code>(如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回
false)</li>
<li><code>if log[oldIndex].term != log[newIndex].term then remove log[oldIndex,lastIndex]</code>(
如果一个已经存在的日志与新的日志冲突(<em><code>index</code>相同但是<code>term</code>不同</em>)，则删除该索引处以及之后的所有日志)</li>
<li>添加在日志列表中不存在的新日志</li>
<li><code>if leaderCommit &gt; commitIndex then commitIndex = min(leaderCommit,log[].last.commitIndex)</code>(如果leaderCommit &gt;
commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个)</li>
</ul>
</li>
</ul>
<p><strong>RequestVote RPC</strong></p>
<blockquote>
<p>候选人调用，收集选票</p>
</blockquote>
<ul>
<li>Arguments:
<ul>
<li><code>term</code>: candidate的任期号</li>
<li><code>candidateId</code>: 发起请求的candidate的id</li>
<li><code>lastLogIndex</code>: candidate的最后一条日志的索引</li>
<li><code>lastLogTerm</code>: candidate最后一条日志对应的任期号</li>
</ul>
</li>
<li>Results:
<ul>
<li>term: <code>currentTerm</code>，用于candidate更新自己的<code>term</code></li>
<li>voteGranted: true表示候选人获得了选票</li>
</ul>
</li>
<li>Receiver implementation:
<ul>
<li><code>if term &lt; currentTerm then return false</code>(如果term &lt; currentTerm返回 false)</li>
<li><code>if (votedFor is null or votedFor == candidateId) and (lastLogIndex,lastLogTerm) == log[].last then return true</code>
(如果votedFor为空或者与candidateId相同，并且候选人的日志和自己的日志一样新，则给该候选人投票)</li>
</ul>
</li>
</ul>
<p><strong>Rules for Servers</strong></p>
<ul>
<li>All Servers:
<ul>
<li><code>if commitIndex &gt; lastApplied then incr lastApplied and exec log[lastApplied]</code>（如果commitIndex &gt;
lastApplied，lastApplied自增，将log[lastApplied]应用到状态机）</li>
<li><code>if appendEntries.logs exist (log.term &gt; currentTerm) then currentTerm = log.term and set status = follower</code>(如果
RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则currentTerm赋值为 T，并切换状态为追随者follower)</li>
</ul>
</li>
<li>Followers:
<ul>
<li>不会发出任何请求，只会对来自candidates以及leader的请求做出响应</li>
<li>选举超时后，如果未收到当前leader的<code>AppendEntries RPC</code>或没有收到其他candidates的投票请求:则转换为candidate</li>
</ul>
</li>
<li>Candidates:
<ul>
<li>转换成candidate之后开始选举
<ul>
<li>incr <code>currentTerm</code></li>
<li>投票给自己</li>
<li>reset election timer</li>
<li>发送<code>RequestVote RPC</code>给其他所有服务器</li>
</ul>
</li>
<li>如果收到了多数的选票则成为leader</li>
<li>如果收到 new leader 的<code>AppendEntries RPC</code>则成为 follower</li>
<li>如果选举超时则开始新一轮的选举</li>
</ul>
</li>
<li>Leaders:
<ul>
<li>选举时: 向其他服务器发送空的<code>AppendEntries RPC</code>，在空闲时重复发送以防止选举超时</li>
<li>如果收到来自客户端的命令: 添加到本地日志，在执行并作用到状态机后作出响应</li>
<li>对于follower<code>if last log index  &gt;= nextIndex</code>(如果上一次收到的日志的索引大于这次要发送给它的日志的索引(
nextIndex)):
则通过<code>AppendEntries RPC</code>将nextIndex之后的所有日志都发送发送出去
<ul>
<li>如果成功: 将该follower的<code>nextIndex</code>以及<code>matchIndex</code>更新</li>
<li>如果因为日志不一致导致失败: <code>nextIndex</code>递减并重新发送</li>
</ul>
</li>
<li>如果存在一个数N，满足<code>N &gt; commitIndex</code>，大多数的<code>matchIndex[i] &gt;= N</code>
以及<code>log[N].term == currentTerm</code>: <code>set commitIndex = N</code></li>
</ul>
</li>
</ul>
<h3 id="figure-3">Figure 3</h3>
<p><figure id="a-/images/f3.png" class="align-center">
    <img src="/images/f3.png" alt="Figure 3: Raft保证这些属性在在任何时候都上正确的。"  />
    
    <figcaption>
       Figure 3: Raft保证这些属性在在任何时候都上正确的。
    </figcaption>
    
</figure></p>
<ul>
<li><strong>Election Safety:</strong> 在给定term内只能选出一个leader</li>
<li><strong>Leader Append-Only</strong>: leader永远不覆盖或删除日志，只会添加</li>
<li><strong>Log Matching</strong>: 如果两个日志在包含相同的index以及term，那么就认定它们完全相同</li>
<li><strong>Leader Completeness</strong>: 如果一条日志在给定的term内提交，那么它一定会出现在term更大的leader的日志中</li>
<li><strong>State Machine Safety:</strong> 如果一个服务器已经将给定索引位置的日志条目应用到状态机之中，则其他所有服务器不会在相同索引处出现不同的日志</li>
</ul>
<h3 id="raft-basics">Raft basics</h3>
<p>一个 Raft 集群可以包含多个服务器；5是一个典型的数量，它允许系统容忍2次故障(有两台服务宕机)。
在给定的时间中每个服务都处在以下三种状态之一:
<em>leader</em>, <em>follower</em>, <em>candidate</em>。 正常情况下，恰好只有一个leader，所有其他服务器都是 follower。</p>
<ul>
<li>follower 是被动的: 它们不会自己发出请求，而只是响应来自 leader 和 candidate 的请求。</li>
<li>leader 处理所有 client 的请求（如果 client 联系到 follower，则 follower 重定向到 leader)。</li>
<li>candidate 用于选举出一个新的 leader(可以看&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-4">图4</a>
)。</li>
</ul>
<h4 id="figure-4">Figure 4</h4>
<p><figure id="a-/images/9.png" class="align-center">
    <img src="/images/9.png" alt="Figure 4: Server states。follow 之响应其他服务的请求，如果 follow 没有手段任何通信，就会变成 candidate 并发起选举。获得整个集群
中大多数人投票的 candidate 成为候选人。leader 通常运行到它们失败为止。"  />
    
    <figcaption>
       Figure 4: Server states。follow 之响应其他服务的请求，如果 follow 没有手段任何通信，就会变成 candidate 并发起选举。获得整个集群
中大多数人投票的 candidate 成为候选人。leader 通常运行到它们失败为止。
    </figcaption>
    
</figure></p>



<details class="details custom-block">
    <summary> 原文</summary>
    A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures.
At any given time each server is in one of three states: leader, follower, or candidate. In normal operation there is
exactly one leader and all of the other servers are followers. Followers are passive: they issue no requests on their
own but simply respond to requests from leaders and candidates. The leader handles all client requests (if a client
contacts a follower, the follower redirects it to the leader). The third state, candidate, is used to elect a new
leader as described in Section 5.2. Figure 4 shows the states and their transitions; the transitions are discussed
below.
</details>



<p>如图5所示: Raft将时间分为任意长度的 <em>terms</em>。terms 的编号是连续的整数。每一个 term 开始于 <em>election</em>，一个或多个 candidate
尝试成为 leader。如果一个 candidate 赢得了选举，那么它将在剩下的 term 内担任 leader。</p>
<p>在某些特殊情况下选举的结果是 split vote。在这种情况下，term 将会结束并且没有 leader。一个新的 term(伴随新一轮的选举)将很快开始。
Raft保证在给定的 term 内最多只有一个 leader。</p>
<h4 id="figure-5">Figure 5</h4>
<p><figure id="a-/images/10.png" class="align-center">
    <img src="/images/10.png" alt="Figure 5: 将时间划分为 terms，每个 term 都以选举开始。选举成功后，一个 leader管理集群直到 term 结束。在一些选举失败的情况下，
任期结束时都不会选择 leader。可以在不同的服务器上，可以在不同的时间观察到 term 之间的过渡情况。"  />
    
    <figcaption>
       Figure 5: 将时间划分为 terms，每个 term 都以选举开始。选举成功后，一个 leader管理集群直到 term 结束。在一些选举失败的情况下，
任期结束时都不会选择 leader。可以在不同的服务器上，可以在不同的时间观察到 term 之间的过渡情况。
    </figcaption>
    
</figure></p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft divides time into terms of arbitrary length, as shown in Figure 5. Terms are numbered with consecutive integers.
Each term begins with an election, in which one or more candidates attempt to become leader as described in Section
5.2. If a candidate wins the election, then it serves as leader for the rest of the term.
In some situations an election will result in a split vote.
In this case the term will end with no leader; a new term (with a new election) will begin
shortly. Raft ensures that there is at most one leader in a given term.
</details>



<p>不同的服务器可能会在不同的时间观察到 terms 之间的转换，在某些情况下，一个服务器可能不会观察到选举甚至整个 terms。
terms 在 Raft 中充当了逻辑时钟， 它们允许服务器检测过时的信息，如过时的 leader。</p>
<p>每个服务器都存储一个当前的 term 编号，该编号随时间单调地增加。每当服务器进行通信时，就会交换当前 term；
如果一个服务器的当前 term 比另一个服务器的小，那么它就会将其当前 term 更新为较大的值。</p>
<p>如果一个 candidate 或 leader 发现它的 term 已经过时，它将立即恢复到 follower 的状态。</p>
<p>如果一个服务器收到的请求是一个过时的 term 编号，它将拒绝该请求。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Different servers may observe the transitions between terms at different times, and in some situations a server may
not observe an election or even entire terms. Terms act as a logical clock [14] in Raft, and they allow servers to
detect obsolete information such as stale leaders. Each server stores a current term number, which increases
monotonically over time. Current terms are exchanged whenever servers communicate; if one server’s current term is
smaller than the other’s, then it updates its current term to the larger value. If a candidate or leader discovers
that its term is out of date, it immediately reverts to follower state. If a server receives a request with a stale term
number, it rejects the request.
</details>



<p>Raft 服务器使用 RPC 进行通信，而基本的共识算法只需要两种类型的RPC。<code>RequestVote RPCs</code> 由 candidate 在选举期间发起；
<code>AppendEntries RPCs</code>由 leader 发起，用于复制日志条目并提供一种心跳形式。在下面的章节还增加了第三个RPC，用于在服务器之间传输快照。
如果服务器没有及时收到响应，它们会重试 RPC，并且为了获得最佳性能，它们会并行地发出 RPC。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft servers communicate using remote procedure calls (RPCs), and the basic consensus algorithm requires only two
types of RPCs. RequestVote RPCs are initiated by candidates during elections (Section 5.2), and AppendEntries RPCs are
initiated by leaders to replicate log entries and to provide a form of heartbeat (Section 5.3). Section 7 adds a third
RPC for transferring snapshots between servers. Servers retry RPCs if they do not receive a response in a timely
manner, and they issue RPCs in parallel for best performance.
</details>



<h3 id="leader-election">Leader election</h3>
<p>Raft 使用心跳机制来触发 leader 选举。当服务器启动时，初始状态都是 follower 。只要服务器收到来自 leader 或 candidate 的有效RPC，
它就一直处于 follower 状态。 leader 定期向所有 follower 发送心跳（<code>AppendEntries RPCs</code>，不携带日志条目），以保持他们的权威。
如果 follower 在一段时间内没有收到任何通信(<em>election timeout</em>)，那么它就认为没有可行的 leader ，
并开始选举以选择一个新的 leader。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers. A server
remains in follower state as long as it receives validRPCs from a leader or candidate. Leaders send periodic
heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority. If a
follower receives no communication over a period of time called the election timeout, then it assumes there is no
viable
leader and begins an election to choose a new leader.
</details>



<p>为了开始选举，follower 增加它的当前 term 并过转换到 candidate 状态。
然后，它为自己投票，并行的向集群中的每个其他服务器发出<code>RequestVote RPCs</code>。
candidate 将一直处于这种状态，直到发生以下三种情况之一:</p>
<ol>
<li>它赢得了选举</li>
<li>另一个服务器确立了自己的领导地位</li>
<li>一段时间内没有赢家。</li>
</ol>
<p>接下来就对这些结果进行讨论:</p>



<details class="details custom-block">
    <summary> 原文</summary>
    To begin an election, a follower increments its current term and transitions to candidate state. It then votes for
itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster. A candidate continues in
this state until one of three things happens: (a) it wins the election, (b) another server establishes itself as leader,
or (c) a period of time goes by with no winner. These outcomes are discussed separately in the paragraphs below
</details>



<blockquote>
<p>它赢得了选举</p>
</blockquote>
<p>如果一个 candidate 在同一任期( term )内获得了整个集群中大多数服务器的投票，那么它就赢得了选举。
每台服务器在给定的 term 内最多为一名 candidate 投票，以先来后到为原则。</p>
<p>少数服从多数的原则保证了最多只有一名 candidate能够在某一 term 内赢得选举
(&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
中的选举 Safety 属性)。
一旦一个 candidate 在选举中获胜，它就成为 leader。然后，它向所有其他服务器发送心跳信息(不携带日志的<code>AppendEntries RPC</code>)，
以建立其权威并防止新的选举。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term.
Each server will vote for at most one candidate in a given term, on a first-come-first-served basis (note: Section 5.4
adds an additional restriction on votes). The majority rule ensures that at most one candidate can win the election for
a particular term (the Election Safety Property in Figure 3). Once a candidate wins an election, it becomes leader. It
then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.
</details>



<blockquote>
<p>另一个服务器确立了自己的领导地位</p>
</blockquote>
<p>在等待投票的过程中，candidate 可能会收到另一个服务器的<code>AppendEntries RPC</code>，声称自己是领导者。
如果这个 leader 的term(会携带在 RPC 中)至少与 candidate 的当前 term 一样大，
那么 candidate 就会承认 leader 是合法的并返回到 follower 状态。
如果 RPC 中的 term 比 candidate 当前的 term 小，那么候选者拒绝 RPC，继续处于 candidate 状态。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader. If the
leader’s term (included in its RPC) is at least as large as the candidate’s current term, then the candidate recognizes
the leader as legitimate and returns to follower state. If the term in the RPC is smaller than the candidate’s current
term, then the candidate rejects the RPC and continues in candidate state.
</details>



<blockquote>
<p>一段时间内没有赢家</p>
</blockquote>
<p>第三个可能的结果是，一个候选人既没有赢得选举，也没有输掉选举: 如果许多 follower 同时成为 candidate，票数可能被分割，
因此没有 candidate 获得足够的投票。
当这种情况发生时，每个 candidate 都会超时，并通过增加其 term 和启动新一轮的<code>RequestVote RPC</code>来开始新的选举。
然而，如果没有额外的措施，<code>split vote</code> 可能会无限期地重复。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    The third possible outcome is that a candidate neither wins nor loses the election: if many followers become candidates
at the same time, votes could be split so that no candidate obtains a majority. When this happens, each candidate will
time out and start a new election by incrementing its term and initiating another round of RequestVote RPCs. However,
without extra measures split votes could repeat indefinitely.
</details>



<p>Raft使用随机的选举超时时间，以确保 split vote 很少发生，并能迅速解决。为了从一开始就防止 split vote，
选举超时时间是从一个固定的时间间隔中随机选择的(例如150-300ms)。这样每个服务器的选举超时时间就不同了，所以在大多数情况下，只有一个服务器会超时。</p>
<p>如果一个服务赢得了选举，就在其他服务超时之前发送心跳，split vote 也使用同样的机制来处理。
每个候选人在选举开始时重新启动其随机选举超时(重新计时？)，并等待超时过后再开始下一次选举；这减少了在新的选举中再次出现分裂票的可能性。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly. To
prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150–300ms).
This spreads out the servers so that in most cases only a single server will time out; it wins the election and sends
heartbeats before any other servers time out. The same mechanism is used to handle split votes. Each candidate restarts
its randomized election timeout at the start of an election, and it waits for that timeout to elapse before starting the
next election; this reduces the likelihood of another split vote in the new election. Section 9.3 shows that this
approach elects a leader rapidly
</details>



<p>选举是一个用于说明可理解性是如何指导我们在设计方案做权衡的例子。
最初我们计划使用一个排名系统: 每个 candidate 被分配一个唯一的排名，
用来在竞争的 candidate 之间进行选择。如果一个候选人发现了另一个排名更高的候选人，
它就会回到 follower 的状态，这样排名更高的候选人就能更容易地赢得下一次选举。
我们发现这种方法在可用性方面产生了一些微妙的问题(如果一个排名较高的服务失败了，一个排名较低的服务器可能需超时并再次成为
candidate ，但如果它过早地这样做，它可能会重置选举 leader 的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的角落案例。
最终我们得出结论，随机重试的方法更明显，更容易理解。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Elections are an example of how understandability guided our choice between design alternatives.
Initially we planned to use a ranking system: each candidate was assigned a unique rank,
which was used to select between competing candidates. If a candidate discovered another candidate with higher rank,
it would return to follower state so that the higher ranking candidate could more easily win the next election.
We found that this approach created subtle issues around availability (a lower-ranked server might need to time out and
become a candidate again if a higher-ranked server fails, but if it does so too soon, it can reset progress towards
electing a leader). We made adjustments to the algorithm several times, but after each adjustment new corner cases
appeared. Eventually we concluded that the randomized retry approach is more obvious and understandable.
</details>



<h3 id="log-replication">Log replication</h3>
<p>一旦一个领导者被选出，它就开始为 client 的请求提供服务。每个 client request 都包含一个要由复制的状态机执行的 command。
leader 将该 command 作为一个新的条目附加到它的日志中，然后并行地将<code>AppendEntries RPCs</code>发送给其他每个服务器以复制该条目。
当条目被安全复制后(如下所述)，leader 将条目应用于其状态机，并将执行结果返回给 client 。
如果 follower 崩溃或运行缓慢，或者网络数据包丢失，领导者会无限期地重试<code>AppendEntries RPCs</code>(甚至在它回应了客户端之后)，
直到所有 follower 最终存储所有日志条目。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Once a leader has been elected, it begins servicing client requests. Each client request contains a command to be
executed by the replicated state machines. The leader appends the command to its log as a new entry, then is- sues
AppendEntries RPCs in parallel to each of the other servers to replicate the entry. When the entry has been safely
replicated (as described below), the leader applies the entry to its state machine and returns the result of that
execution to the client. If followers crash or run slowly, or if network packets are lost, the leader retries Append-
Entries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log en-
tries.
</details>



<p><figure id="a-/images/f6.png" class="align-center">
    <img src="/images/f6.png" alt="Figure 6: 日志是由条目组成的，这些条目按顺序编号。每个条目都包含创建它的 term(每个框中的数字)和状态机的命令。如果一个条目可以安全地应用于状态机，那么该条目就被认为是 committed 的"  />
    
    <figcaption>
       Figure 6: 日志是由条目组成的，这些条目按顺序编号。每个条目都包含创建它的 term(每个框中的数字)和状态机的命令。如果一个条目可以安全地应用于状态机，那么该条目就被认为是 committed 的
    </figcaption>
    
</figure></p>
<p>日志的组织方式如&nbsp;<a href="/posts/2022-10-10-raftkv/#a-/images/f6.png">图6</a>
所示。每个日志条目都存储了一个状态机命令，
以及 leader 收到该条目时的 term 编号。日志条目中的 term 编号被用来检测日志之间的不一致，
并确保&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
中的一些属性。每个日志条目也有一个整数的索引来标识它在日志中的位置。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    Logs are organized as shown in Figure 6. Each log entry stores a state machine command along with the term number when
the entry was received by the leader. The term numbers in log entries are used to detect inconsistencies between logs
and to ensure some of the properties in Figure 3. Each log entry also has an integer index identifying its position in
the log.
</details>



<p>leader 决定何时将日志条目应用于状态机是安全的,这样的条目被称为 <em>committed</em> 。
Raft 保证所提交的条目是持久的，最终会被所有可用的状态机执行。一旦创建该条目的 leader 将其复制到大多数服务器上，
该日志条目就会被提交(例如，图6中的条目7)。这也会提交 leader 日志中所有之前的条目，包括之前领导者创建的条目。
第5.4节讨论了在 leader 变更后应用这一规则时的一些微妙之处，它还表明这种承诺的定义是安全的。
leader 会跟踪它所知道的已承诺的最高索引，并且它在未来的<code>AppendEntries RPC</code>(包括心跳)中包括该索引，以便其他服务器最终发现。
一旦 follower 得知一个日志条目被提交，它就会将该条目应用于其本地状态机(按日志顺序)。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed.
Raft guarantees that committed entries are durable and will eventually be executed by all of the available state
machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the
servers (e.g., entry 7 in Figure 6). This also commits all preceding entries in the leader’s log, including entries
created by previous leaders. Section 5.4 discusses some subtleties when applying this rule after leader changes, and it
also shows that this definition of commitment is safe. The leader keeps track of the highest index it knows to be
committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers
eventually find out. Once a follower learns that a log entry is committed, it applies the entry to its local state
machine (in log order)
</details>



<p>我们设计的 Raft 日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。
Raft 维护了以下特性，它们共同构成了&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
中的 Log Matching 特性:</p>
<blockquote>
<p>如果不同的两个日志具有相同的 index 以及 term</p>
</blockquote>
<ul>
<li>那么就认为它们存储的是同一个 command</li>
<li>那么就认为它们之前的所有日志也是相同的</li>
</ul>



<details class="details custom-block">
    <summary> 原文</summary>
    <p>We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers. Not only
does this simplify the system’s behavior and make it more predictable, but it is an important component of ensuring
safety. Raft maintains the following properties, which together constitute the Log Matching Property in Figure 3:</p>
<ul>
<li>If two entries in different logs have the same index
and term, then they store the same command.</li>
<li>If two entries in different logs have the same index
and term, then the logs are identical in all preceding
entries</li>
</ul>

</details>



<p>第一个属性来自于这样一个事实，即一个 leader 在一个给定的 term 中最多创建一个具有给定的日志 index 的条目，
并且日志条目永远不会改变它们在日志中的位置。
第二个属性由<code>AppendEntries</code>执行的简单一致性检查来保证。当发送<code>AppendEntries RPC</code>时，
leader 会包含其日志中紧接新条目之前的条目的 index 和 term 。
如果 follower 在其日志中没有找到具有相同 index 和 term 的条目，那么它将拒绝新条目。
一致性检查作为一个归纳步骤: 日志的初始空状态满足了 Log Matching 属性，并且每当日志被扩展时，一致性检查都会保留 Log
Matching 属性。
因此，每当<code>AppendEntries</code>成功返回时，leader 知道 follower 的日志与自己的日志在新条目之前是相同的</p>



<details class="details custom-block">
    <summary> 原文</summary>
    The first property follows from the fact that a leader creates at most one entry with a given log index in a given term,
and log entries never change their position in the log.
The second property is guaranteed by a simple consistency check performed by AppendEntries.
When sending an AppendEntries RPC, the leader includes the index and term of the
entry in its log that immediately precedes the new entries. If the follower does not find an entry in its log with the
same index and term, then it refuses the new entries. The consistency check acts as an induction step: the initial empty
state of the logs satisfies the Log Matching Property, and the consistency check preserves the Log Matching Property
whenever logs are extended. As a result, whenever AppendEntries returns successfully, the leader knows that the
follower’s log is identical to its own log up through the new entries
</details>



<p>在正常运行期间，leader 和 follower 的日志保持一致，所以<code>AppendEntries</code>一致性检查不会失败。
然而，leader 崩溃会使日志不一致(old leader 可能没有完全复制其日志中的所有条目)。
这些不一致会在一系列 leader 和 follower 的崩溃中加剧。图7说明了 follower 的日志可能与new leader 的日志不同的方式。</p>
<ul>
<li>follower 可能会丢失 leader 的条目</li>
<li>follower 可能会有 leader 没有的额外条目</li>
<li>或者两者都有</li>
</ul>
<p>日志中缺失和多余的条目可能跨越多个 term 。</p>
<p><figure id="a-/images/f7.png" class="align-center">
    <img src="/images/f7.png" alt="Figure 7: 当顶端的 leader 掌权时，在 follower 的日志中可能会出现(a-f)中的任何一种情况。
每个盒子代表一个日志条目；盒子里的数字是其 term 。 一个 follower 可能缺少条目(a-b)，可能有额外的未承诺的条目(c-d)，或者两者都有(e-f)。
例如，如果该服务器是第2期的 leader ，在其日志中增加了几个条目，然后在提交任何条目之前就崩溃了；它很快重新启动，成为第3期的 leader，
并在其日志中增加了几个条目；在第2期或第3期的任何条目被提交之前，该服务器又崩溃了，并持续了几个任期。"  />
    
    <figcaption>
       Figure 7: 当顶端的 leader 掌权时，在 follower 的日志中可能会出现(a-f)中的任何一种情况。
每个盒子代表一个日志条目；盒子里的数字是其 term 。 一个 follower 可能缺少条目(a-b)，可能有额外的未承诺的条目(c-d)，或者两者都有(e-f)。
例如，如果该服务器是第2期的 leader ，在其日志中增加了几个条目，然后在提交任何条目之前就崩溃了；它很快重新启动，成为第3期的 leader，
并在其日志中增加了几个条目；在第2期或第3期的任何条目被提交之前，该服务器又崩溃了，并持续了几个任期。
    </figcaption>
    
</figure></p>



<details class="details custom-block">
    <summary> 原文</summary>
    During normal operation, the logs of the leader and followers stay consistent, so the AppendEntries consistency check
never fails. However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all
of the entries in its log). These inconsistencies can compound over a series of leader and follower crashes. Figure 7
illustrates the ways in which followers’ logs may differ from that of a new leader. A follower may be missing entries
that are present on the leader, it may have extra entries that are not present on the leader, or both. Missing and
extraneous entries in a log may span multiple terms.
</details>



<p>在 Raft 中，leader 通过强迫 follower 的日志重复自己的日志来处理不一致的情况。这意味着 follower 日志中的冲突条目将被 leader
日志中的条目覆盖。在下一节将表明，如果再加上一个限制，这就是安全的。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    In Raft, the leader handles inconsistencies by forcing the followers’ logs to duplicate its own. This means that
conflicting entries in follower logs will be overwritten with entries from the leader’s log. Section 5.4 will show that
this is safe when coupled with one more restriction.
</details>



<p>为了使 follower 的日志与自己的日志保持一致，leader 必须找到两个日志一致的最新日志条目，删除该点之后 follower 日志中的所有条目，
并将该点之后的所有 leader 条目发送给 follower。所有这些操作都是为了响应<code>AppendEntries RPC</code>执行的一致性检查而发生的。
leader 为每个 follower 维护一个 nextIndex ，这是 leader 将发送给该 follower 的下一个日志条目的 index 。
当 leader 首次上台时，它会将所有 nextIndex 值初始化为其日志中最后一个值之后的索引(图 7 中的 11)。
如果 follower 的日志与 leader 的日志不一致，则<code>AppendEntries</code>一致性检查将在下一个<code>AppendEntries RPC</code>中失败。
拒绝后，leader 减少 nextIndex 并重试<code>AppendEntries RPC</code>。最终<code>nextIndex</code>将达到 leader 和 follower 日志匹配的点。
发生这种情况时，<code>AppendEntries</code>将成功，这将删除 follower 日志中的任何冲突条目，并从 leader 日志中添加条目(如果有)。
一旦<code>AppendEntries</code>成功，follower 的 log 就会和 leader 的一致，并且在接下来的任期内保持这种状态。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs
agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries
after that point. All of these actions happen in response to the consistency check performed by AppendEntries RPCs. The
leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that
follower. When a leader first comes to power, it initializes all nextIndex values to the index just after the last one
in its log (11 in Figure 7). If a follower’s log is inconsistent with the leader’s, the AppendEntries consis- tency
check will fail in the next AppendEntries RPC. Af- ter a rejection, the leader decrements nextIndex and retries the
AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match. When this happens,
AppendEntries will succeed, which removes any conflicting entries in the follower’s log and appends entries from the
leader’s log (if any). Once AppendEntries succeeds, the follower’s log is consistent with the leader’s, and it will
remain that way for the rest of the term
</details>



<blockquote>
<p>如果需要，可以优化协议以减少被拒绝的<code>AppendEntries RPC</code>的数量。例如，当拒绝<code>AppendEntries</code>请求时，
follower 可以包含冲突条目的 term 以它在 term 中存储的第一个索引。
有了这些信息，leader 可以减少 nextIndex 以绕过该 term 中的所有冲突条目；
每个有日志冲突的 term 都只需要一个<code>AppendEntries RPC</code>，而不是每个日志条目一个 RPC。
在实践中，我们怀疑这种优化是否必要，因为失败很少发生，而且不太可能有很多不一致的条目。</p>
</blockquote>



<details class="details custom-block">
    <summary> 原文</summary>
    If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs. For example, when
rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first index it
stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conflicting
entries in that term; one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC
per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently and it is unlikely
that there will be many inconsistent en- tries
</details>



<p>通过这种机制，leader 在上台时无需采取任何特殊措施来恢复日志一致性。它刚刚开始正常运行，
并且日志会自动收敛以响应<code>AppendEntries</code>一致性检查的失败。
leader 永远不会覆盖或删除自己日志中的条目(&nbsp;<a href="/posts/2022-10-10-raftkv/#figure-3">图3</a>
中的 Leader Append-Only )。</p>



<details class="details custom-block">
    <summary> 原文</summary>
    With this mechanism, a leader does not need to take any special actions to restore log consistency when it comes to
power. It just begins normal operation, and the logs automatically converge in response to failures of the Append-
Entries consistency check. A leader never overwrites or deletes entries in its own log (the Leader Append-Only Property
in Figure 3).
</details>



<p>理想的 Raft:</p>
<ul>
<li>只要大多数服务器启动，Raft 就可以接受、复制和应用新的日志条目</li>
<li>可以通过单轮 RPC 将新条目复制到集群的大部分；</li>
<li>并且单个慢速 follower 不会影响性能。</li>
</ul>



<details class="details custom-block">
    <summary> 原文</summary>
    This log replication mechanism exhibits the desirable consensus properties described in Section 2: Raft can ac- cept,
replicate, and apply new log entries as long as a ma- jority of the servers are up; in the normal case a new entry can
be replicated with a single round of RPCs to a ma- jority of the cluster; and a single slow follower will not impact
performance.
</details>



<h3 id="safety">Safety</h3>
<h1 id="代码实现思路">代码实现思路</h1>
<h2 id="2a-1">2A</h2>
<ol>
<li>根据图2中的 state 这一节添加对应的属性</li>
<li>添加<code>RaftRole</code>属性，代表当前的角色: leader，candidate，follower</li>
<li>实现<code>ticker</code>这个函数:
<ul>
<li>判断是否很久没有收到心跳，来发起选举</li>
<li>判断是否需要发送心跳，来维持自己的权威</li>
</ul>
</li>
</ol>
<h1 id="links">Links</h1>
<ol>
<li>项目地址: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a>
</li>
<li>GFS 相关资料: &nbsp;<a href="https://fzdwx.github.io/posts/2022-10-07-gfs/#links" target="_blank" rel="noopener">https://fzdwx.github.io/posts/2022-10-07-gfs/#links</a>
</li>
<li>Raft paper: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a>
</li>
<li>Diagram of Raft interactions： &nbsp;<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf</a>
</li>
<li>Students guid to Raft: &nbsp;<a href="https://thesquareplanet.com/blog/students-guide-to-raft/" target="_blank" rel="noopener">https://thesquareplanet.com/blog/students-guide-to-raft/</a>
</li>
<li>Raft locking: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt</a>
</li>
<li>Raft structure: &nbsp;<a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt</a>
</li>
<li>Paxos Replicated State Machines as the Basis of a High-Performance Data
Store &nbsp;<a href="https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf" target="_blank" rel="noopener">https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf</a>
</li>
<li>TiKV 对于 Raft 优化 &nbsp;<a href="https://cn.pingcap.com/blog/optimizing-raft-in-tikv" target="_blank" rel="noopener">https://cn.pingcap.com/blog/optimizing-raft-in-tikv</a>
</li>
<li>&nbsp;<a href="https://www.cnblogs.com/niejunlei/p/9719557.html" target="_blank" rel="noopener">https://www.cnblogs.com/niejunlei/p/9719557.html</a>
</li>
<li>&nbsp;<a href="https://blog.csdn.net/viskaz/article/details/124232474" target="_blank" rel="noopener">https://blog.csdn.net/viskaz/article/details/124232474</a>
</li>
<li>&nbsp;<a href="https://www.cnblogs.com/brianleelxt/p/13251540.html" target="_blank" rel="noopener">https://www.cnblogs.com/brianleelxt/p/13251540.html</a>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>在Abstract Machine上玩超级马里奥</title>
      <link>https://fzdwx.github.io/posts/2022-10-09-mario-nes/</link>
      <pubDate>Sun, 09 Oct 2022 19:40:42 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-09-mario-nes/</guid>
      <description>最近在学习 jyy 的&amp;nbsp; 计算机系统基础习题课 ， 在做&amp;nbsp; pa1 的时候提 到一个运行红白机游戏的&amp;nbsp; 项目 运行起来的效果 遇到的坑:
1.SIGSTKSZ 参数找不到
SIGSTKSZ参数找不到 将SIGSTKSZ修改为一个固定的参数
//uint8_t sigstack[SIGSTKSZ]; uint8_t sigstack[8192]; 2.serial 不正确
serial不正确 修改nemu/src/device/serial.c#init_serial，每个人的不同，我的是 9。</description>
      <content:encoded><![CDATA[<p>最近在学习 jyy 的&nbsp;<a href="http://jyywiki.cn/ICS/2021/" target="_blank" rel="noopener"> 计算机系统基础习题课 </a>
，
在做&nbsp;<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/1.1.html#nemu%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener"> pa1 </a>
的时候提
到一个运行红白机游戏的&nbsp;<a href="https://github.com/NJU-ProjectN/fceux-am" target="_blank" rel="noopener"> 项目 </a>
</p>
<p><figure id="a-/images/4.png" class="align-center">
    <img src="/images/4.png" alt="运行起来的效果"  />
    
    <figcaption>
       运行起来的效果
    </figcaption>
    
</figure></p>
<p>遇到的坑:</p>
<p>1.SIGSTKSZ 参数找不到</p>
<p><figure id="a-/images/5.png" class="align-center">
    <img src="/images/5.png" alt="SIGSTKSZ参数找不到"  />
    
    <figcaption>
       SIGSTKSZ参数找不到
    </figcaption>
    
</figure></p>
<p>将<code>SIGSTKSZ</code>修改为一个固定的参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//uint8_t sigstack[SIGSTKSZ];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="n">sigstack</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span></span></code></pre></div><p>2.serial 不正确</p>
<p><figure id="a-/images/6.png" class="align-center">
    <img src="/images/6.png" alt="serial不正确"  />
    
    <figcaption>
       serial不正确
    </figcaption>
    
</figure></p>
<p>修改<code>nemu/src/device/serial.c#init_serial</code>，每个人的不同，我的是 9。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>C Compile</title>
      <link>https://fzdwx.github.io/posts/2022-10-09-c-compile/</link>
      <pubDate>Sun, 09 Oct 2022 14:10:36 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-09-c-compile/</guid>
      <description>宏定义与展开 宏展开: 通过 复制/粘贴 改变代码的形态
一个include的例子 a.c:
#include &amp;lt;stdio.h&amp;gt; int main(){ printf( #include &amp;lt;qwe&amp;gt; ); } qwe:
&amp;#34;hello world\n&amp;#34; 通过运行gcc a.c &amp;amp;&amp;amp; a.out得到
❯ gcc a.c &amp;amp;&amp;amp; a.out hello world 一个define的例子 a.c:
#define A &amp;#34;aaaaaaaaaaaa&amp;#34; #define TEN(A) A A A A A A A A A #define B TEN(A) #define C TEN(B) int main(int argc, char const *argv[]) { puts(C); return 0; } 可以通过gcc a.c -E来查看预编译的结
❯ gcc a.c -E # 0 &amp;#34;a.</description>
      <content:encoded><![CDATA[<h2 id="宏定义与展开">宏定义与展开</h2>
<p>宏展开: 通过 复制/粘贴 改变代码的形态</p>
<h3 id="一个include的例子">一个include的例子</h3>
<p>a.c:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#include</span> <span class="cpf">&lt;qwe&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>qwe:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#34;hello world\n&#34;
</span></span></code></pre></div><p>通过运行<code>gcc a.c &amp;&amp; a.out</code>得到</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">❯ gcc a.c &amp;&amp; a.out
</span></span><span class="line"><span class="cl">hello world
</span></span></code></pre></div><h3 id="一个define的例子">一个define的例子</h3>
<p>a.c:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define A &#34;aaaaaaaaaaaa&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TEN(A) A A A A A A A A A
</span></span></span><span class="line"><span class="cl"><span class="cp">#define B TEN(A)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define C TEN(B)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">puts</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以通过<code>gcc a.c -E</code>来查看预编译的结</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">❯ gcc a.c -E
</span></span><span class="line"><span class="cl"># 0 &#34;a.c&#34;
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;built-in&gt;&#34;
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;command-line&gt;&#34;
</span></span><span class="line"><span class="cl"># 1 &#34;/usr/include/stdc-predef.h&#34; 1 3 4
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;command-line&gt;&#34; 2
</span></span><span class="line"><span class="cl"># 1 &#34;a.c&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char const *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   puts(&#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34; &#34;aaaaaaaaaaaa&#34;);
</span></span><span class="line"><span class="cl">   return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="修改true定义的例子">修改true定义的例子</h3>
<p>它只在特定的行数时才会为true。</p>
<p>a.c:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define true (__LINE__ % 2 != 0)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;yes %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="定义一个宏的参数为函数">定义一个宏的参数为函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define NAMES(x) \
</span></span></span><span class="line"><span class="cl"><span class="cp">   x(Tom) x(Jerry) x(Tyke) x(Spike)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="cp">#define PRINT(x) puts(&#34;Hello,&#34; #x &#34;!&#34;);
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>   <span class="n">NAMES</span><span class="p">(</span><span class="n">PRINT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到，展开后是调用了4遍。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">❯ gcc -E a.c
</span></span><span class="line"><span class="cl"># 0 &#34;a.c&#34;
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;built-in&gt;&#34;
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;command-line&gt;&#34;
</span></span><span class="line"><span class="cl"># 1 &#34;/usr/include/stdc-predef.h&#34; 1 3 4
</span></span><span class="line"><span class="cl"># 0 &#34;&lt;command-line&gt;&#34; 2
</span></span><span class="line"><span class="cl"># 1 &#34;a.c&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char const *argv[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   puts(&#34;Hello,&#34; &#34;Tom&#34; &#34;!&#34;); puts(&#34;Hello,&#34; &#34;Jerry&#34; &#34;!&#34;); puts(&#34;Hello,&#34; &#34;Tyke&#34; &#34;!&#34;); puts(&#34;Hello,&#34; &#34;Spike&#34; &#34;!&#34;);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="c程序执行的两个视角">C程序执行的两个视角</h2>
<p>静态: C代码连续的一段总能找到对应一段连续的机器指令
动态: C代码执行的状态总能对应到机器的状态</p>
<ul>
<li>源代码视角: 函数，变量，指针</li>
<li>机器指令视角: 寄存器，内存，地址</li>
</ul>
<p>共同的地方: 内存</p>
<ul>
<li>代码，变量(源代码) = 地址 + 长度(机器指令)</li>
<li>内存 = 代码 + 数据 + 堆栈</li>
</ul>
<p>所以理解C程序执行最重要的就时<strong>内存模型</strong>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>GFS</title>
      <link>https://fzdwx.github.io/posts/2022-10-07-gfs/</link>
      <pubDate>Fri, 07 Oct 2022 21:12:56 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-07-gfs/</guid>
      <description>为了性能(Performance), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(Sharding)。 而成败上千的机器总会发生错误，所以有了容错(Fault Tolerance)。 实现容错最简单的方式就是复制(Replication)，其中一个发生故障了就切换另一个。 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(Inconsistency)。 如果为了实现一致性(Consistency)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(Low Perf) ，但这与我们开始的希望不符合。 TIP So，强一致性代表着低性能。 设计目标 由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：检查，容错以及快速从故障恢复。 主要支持大文件(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。 工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取 。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。 GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对大的流式读取，同时夜支持任意位置的小规模写入操作。 GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即原子操作。通常会有多个客户端会并行的对同一个文件进行append。 高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据 ，而很少有人对单个读写操作有严格的响应时间要求。 架构 单个master，多个chunk server(保存具体的文件)，多个client。 每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。 每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。 master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。 master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等 每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。 GFS Master中的metadata filename -&amp;gt; chunk ids(chunk handles) NV chunk handle与chunk数据的对应关系 chunk保存在哪个服务器上(chunk server list) chunk的version no NV chunk的primary chunk server，因为写操作在在其上进行 primary chunk server的lease expiration 这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。 每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)
GFS Read Steps 首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。 master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。 然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。 client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近) ，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。 chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。 q1: 如果读取的数据跨越了一个chunk怎么办？ 例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界， 所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。</description>
      <content:encoded><![CDATA[<ol>
<li>为了性能(<strong>Performance</strong>), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(<strong>Sharding</strong>)。</li>
<li>而成败上千的机器总会发生错误，所以有了容错(<strong>Fault Tolerance</strong>)。</li>
<li>实现容错最简单的方式就是复制(<strong>Replication</strong>)，其中一个发生故障了就切换另一个。</li>
<li>使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(<strong>Inconsistency</strong>)。</li>
<li>如果为了实现一致性(<strong>Consistency</strong>)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(<strong>Low Perf</strong>)
，但这与我们开始的希望不符合。</li>
</ol>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
            TIP
        
    </p>
    <p> So，强一致性代表着低性能。 </p>
</div>

<h2 id="设计目标">设计目标</h2>
<ol>
<li>由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：<strong>检查，容错以及快速从故障恢复</strong>。</li>
<li><strong>主要支持大文件</strong>(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。</li>
<li>工作负载主要由两种类型的读取组成：<strong>大的流式读取</strong>和<strong>小的随机读取</strong>
。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。
<ul>
<li>在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。</li>
<li>小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。</li>
</ul>
</li>
<li>GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对<strong>大的流式读取</strong>，同时夜支持任意位置的小规模写入操作。</li>
<li>GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即<strong>原子操作</strong>。通常会有多个客户端会并行的对同一个文件进行append。</li>
<li>高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常<strong>重视高速批量处理数据</strong>
，而很少有人对单个读写操作有严格的响应时间要求。</li>
</ol>
<h2 id="架构">架构</h2>
<ol>
<li>单个master，多个chunk server(保存具体的文件)，多个client。</li>
<li>每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。</li>
<li>每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。</li>
<li>master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。</li>
<li>master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等</li>
<li>每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。</li>
</ol>
<h2 id="gfs-master中的metadata">GFS Master中的metadata</h2>
<ol>
<li>filename -&gt; chunk ids(chunk handles) <em><strong>NV</strong></em></li>
<li>chunk handle与chunk数据的对应关系
<ul>
<li>chunk保存在哪个服务器上(chunk server list)</li>
<li>chunk的version no <em><strong>NV</strong></em></li>
<li>chunk的primary chunk server，因为写操作在在其上进行</li>
<li>primary chunk server的lease expiration</li>
</ul>
</li>
</ol>
<p>这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。
每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)</p>
<h2 id="gfs-read-steps">GFS Read Steps</h2>
<ol>
<li>首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。</li>
<li>master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。</li>
<li>然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。</li>
<li>client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近)
，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。</li>
<li>chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。</li>
</ol>
<h3 id="q1-如果读取的数据跨越了一个chunk怎么办">q1: 如果读取的数据跨越了一个chunk怎么办？</h3>
<p>例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界，
所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。</p>
<h2 id="多个副本之间变更顺序的一致性">多个副本之间变更顺序的一致性</h2>
<p>针对一个chunk</p>
<ol>
<li>master授权给某个持有这个chunk的server一个租约期限(60s)，称为primary。</li>
<li>primary对所有的更改操作进行排序(serial order)，然后其他的secondary根据这个顺序进行变更。</li>
<li>只要这个chunk正在变更，那么primary就可以向master申请延长租约。</li>
</ol>
<h2 id="gfs-write-steps">GFS Write Steps</h2>
<ol>
<li>client向master发送请求获取chunk server list(primary,secondaries)，
如果没有primary，master就会选择一个secondary成为primary。</li>
<li>client获取到chunk server list后会缓存下来，只有当primary
没有响应或租约过期后才会再次请求。</li>
<li>client将数据推送到所有replicas，客户端不保证推送的顺序，每个chunk server会将数据保存在内部的lur cache中，直到数据被使用或过期。</li>
<li>当所有replicas都收到了数据，client将会发送一个写请求到primary，它标识了之前推送到每个副本的数据。
primary将这些写入组织成一定的顺序应用到自己本地。</li>
<li>primary然后将这个应用顺序转发给各个secondary。</li>
<li>secondaries应用这个顺序完成修改并答复primary。</li>
<li>primary答复client，如果出现了任意错误也会答复给client。在出现错误的情况下，write request也可能在primary以及secondary中成功
(如果primary直接就失败了，那么它将不会转发serial order给secondaries)，client将认为这次请求是失败的，它会通过重试来处理(
3-7尝试几次重新写入)</li>
</ol>
<h2 id="gfs-atomic-record-appends">GFS Atomic Record Appends</h2>





<div class="tip custom-block">
    <p class="custom-block-title">
        
        
            对同一片区域个并发写入是不可序列化的
        
    </p>
    <p> 这片区域可能最终包含多个客户端的数据片段。 </p>
</div>

<p>一个原子的append操作。<code>recored append</code>至少会在给定的offset(GFS自己选择的，因为这里可能会失败，可能有一些chunk server上有这个数据)
上追加到文件上一次，并将该offset返回给client。它类似<code>O_APPEND</code>保证原子性。
<code>recored append</code>遵守&nbsp;<a href="#gfs-write-steps"> GFS Write Steps </a>
流程，但是有一些特别的地方:</p>
<ol>
<li>client推送所有数据后，primary会检查append到该chunk后是否超过了单个chunk的大小。</li>
<li>如果超过了，则在当前chunk填充到最大offset时(secondary也要保存)，回复client，指出该操作应该在下一个chunk上重试(
record的大小需要控制在单个chunk最大值的四分之一，以保证碎片在可接收的水平)。</li>
<li>如果没有超过最大大小，则按照正常的情况进行保存。</li>
</ol>
<h2 id="过期副本检测">过期副本检测</h2>
<p>如果chunk server发生故障而宕机或者丢失了某些更新请求，那么它就有可能过期了。对于每个chunk，master都维护了一个version
no来标识最新和过期的副本。</p>
<p>当master为一个chunk的primary server授权或续期时就会增加version no并通知所有replicas进行更新。</p>
<p>在数据一致的情况下，master和所有replicas的version no是一致的(在client发送写请求之前可以保证)。</p>
<p>当chunk server重启或上报version no时，master会检查它时否包含过期的副本，如果发现master发现version
no大于它的记录，master会采用更高的version no进行更新。</p>
<p>master通过周期性的垃圾回收来删除过期的副本，在删除前，它会确认在它所有client的chunk信息请求的应答中没有包含这个过期的副本。</p>
<p>client在从master获取chunk server列表时会附带获取version no，所以它可以进行比对，选择最新的副本进行操作。</p>
<h2 id="总结">总结</h2>
<p>这并不是一个合格的多副本，多活，高可用，故障自修复的分布式系统。</p>
<h2 id="links">Links</h2>
<ol>
<li>&nbsp;<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">gfs paper 原文</a>
</li>
<li>&nbsp;<a href="https://zhuanlan.zhihu.com/p/424677701" target="_blank" rel="noopener">gfs paper 中文翻译</a>
</li>
<li>&nbsp;<a href="https://www.bilibili.com/video/BV1R7411t71W/?p=3&amp;spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=98f230be6561d2fc7450e7ce05876f68" target="_blank" rel="noopener">gfs 视频</a>
</li>
<li>&nbsp;<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.1" target="_blank" rel="noopener">gfs 视频翻译</a>
</li>
<li>&nbsp;<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.2-qiang-yi-zhi-xing-strong-consistency" target="_blank" rel="noopener">Bad Replication Design</a>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>调节linux屏幕的亮度</title>
      <link>https://fzdwx.github.io/posts/2022-10-04-backlight/</link>
      <pubDate>Tue, 04 Oct 2022 10:07:28 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-10-04-backlight/</guid>
      <description>由于使用DWM，它不能像KDE那样之间有图形化的亮度调节功能，所以记录一下。</description>
      <content:encoded><![CDATA[<p><strong>查看当前backlight由什么控制:</strong></p>
<blockquote>
<p>一般都是<code>intel</code>。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ls /sys/class/backlight
</span></span></code></pre></div><p><strong>查看当前的亮度:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /sys/class/backlight/intel_backlight/max_brightness
</span></span></code></pre></div><p><strong>修改亮度:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="m">5000</span> <span class="p">|</span> sudo tee /sys/class/backlight/intel_backlight/brightness
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Dwm初体验</title>
      <link>https://fzdwx.github.io/posts/2022-09-29-dwm/</link>
      <pubDate>Thu, 29 Sep 2022 23:42:41 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-09-29-dwm/</guid>
      <description>安装: git clone https://git.suckless.org/dwm cd dwm sudo make clean install 启动 如果已经有了sddm，可以使用sudo systemctl disable sddm.service 来进行关闭，如果到时候不想用了可以用sudo systemctl enable sddm.service来开启sddm。
# 准备配置文件 cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc # 添加 exec dwm # 注释 #twm &amp;amp; #xclock -geometry 50x50-1+1 &amp;amp; #xterm -geometry 80x50+494+51 &amp;amp; #xterm -geometry 80x20+494-0 &amp;amp; #exec xterm -geometry 80x66+0+0 -name login 然后重启并调用startx即可。
遇到的问题 直接断网 使用NetworkManager进行连接，可能要用到dhcpcd。
nmcli device wifi list nmcli device wifi connect {{wifi name}} password {{pwd}} 可能会连接失败，你可以试试nmcli connection show 来查看是否存在以前的连接信息，可以用nmcli connection delete {{wifi name}}来删除对应的信息</description>
      <content:encoded><![CDATA[<h2 id="安装">安装:</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://git.suckless.org/dwm
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> dwm
</span></span><span class="line"><span class="cl">sudo make clean install
</span></span></code></pre></div><h2 id="启动">启动</h2>
<p>如果已经有了sddm，可以使用<code>sudo systemctl disable sddm.service</code>
来进行关闭，如果到时候不想用了可以用<code>sudo systemctl enable sddm.service</code>来开启sddm。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 准备配置文件</span>
</span></span><span class="line"><span class="cl">cp /etc/X11/xinit/xinitrc ~/.xinitrc
</span></span><span class="line"><span class="cl">vim ~/.xinitrc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 添加</span>
</span></span><span class="line"><span class="cl"><span class="nb">exec</span> dwm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 注释</span>
</span></span><span class="line"><span class="cl"><span class="c1">#twm &amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#xclock -geometry 50x50-1+1 &amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#xterm -geometry 80x50+494+51 &amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#xterm -geometry 80x20+494-0 &amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#exec xterm -geometry 80x66+0+0 -name login</span>
</span></span></code></pre></div><p>然后重启并调用<code>startx</code>即可。</p>
<h2 id="遇到的问题">遇到的问题</h2>
<h3 id="直接断网">直接断网</h3>
<p>使用NetworkManager进行连接，可能要用到<code>dhcpcd</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">nmcli device wifi list
</span></span><span class="line"><span class="cl">nmcli device wifi connect <span class="o">{{</span>wifi name<span class="o">}}</span> password <span class="o">{{</span>pwd<span class="o">}}</span>
</span></span></code></pre></div><p>可能会连接失败，你可以试试<code>nmcli connection show</code>
来查看是否存在以前的连接信息，可以用<code>nmcli connection delete {{wifi name}}</code>来删除对应的信息</p>
<h3 id="输入法失效">输入法失效</h3>
<p>添加配置文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim ~/.pam_environment
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">INPUT_METHOD <span class="nv">DEFAULT</span><span class="o">=</span>fcitx5
</span></span><span class="line"><span class="cl">GTK_IM_MODULE <span class="nv">DEFAULT</span><span class="o">=</span>fcitx5
</span></span><span class="line"><span class="cl">QT_IM_MODULE <span class="nv">DEFAULT</span><span class="o">=</span>fcitx5
</span></span><span class="line"><span class="cl">XMODIFIERS <span class="nv">DEFAULT</span><span class="o">=</span>@im<span class="o">=</span>fcitx5
</span></span></code></pre></div><p>添加启动命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim ~/.xinitrc1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在exec dwm之前添加</span>
</span></span><span class="line"><span class="cl"><span class="nb">exec</span> fcitx5 <span class="p">&amp;</span>
</span></span></code></pre></div><h3 id="扩展屏幕无效">扩展屏幕无效</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 可以先查看有哪些屏幕</span>
</span></span><span class="line"><span class="cl">xrandr 
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将下面的命令加入 ~/.xinitrc1 中，在exec dwm之前添加</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 我有两个，是上下关系，所以用below 其他有 left 以及 right</span>
</span></span><span class="line"><span class="cl">xrandr --output eDP-1-1  --auto --below HDMI-0
</span></span></code></pre></div><h2 id="常用快捷键">常用快捷键</h2>
<p>可以参考我配置： &nbsp;<a href="https://github.com/fzdwx/dwm" target="_blank" rel="noopener">https://github.com/fzdwx/dwm</a>
</p>
<p><code>MOD</code> -&gt; <code>WIN</code></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOD+SHIFT+ENTER</code></td>
<td>新开终端</td>
</tr>
</tbody>
</table>
<h3 id="在本tag内切换聚焦窗口">在本tag内切换聚焦窗口</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ALT + tab</code></td>
<td>切换聚焦窗口</td>
</tr>
<tr>
<td><code>MOD + up</code></td>
<td>切换聚焦窗口</td>
</tr>
<tr>
<td><code>MOD + down</code></td>
<td>切换聚焦窗口</td>
</tr>
</tbody>
</table>
<h3 id="跨tag操作">跨tag操作</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOD + left / right</code></td>
<td>切换tag</td>
</tr>
<tr>
<td><code>MOD + SHIGT + left / tight</code></td>
<td>将当前窗口移动到其他tag</td>
</tr>
<tr>
<td><code>MOD + a</code></td>
<td>第一次是显示所有tag，第二次是跳转到聚焦的窗口所在的窗口</td>
</tr>
</tbody>
</table>
<h3 id="窗口操作">窗口操作</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOD + q</code></td>
<td>退出窗口</td>
</tr>
<tr>
<td><code>MOD + h</code></td>
<td>隐藏窗口</td>
</tr>
<tr>
<td><code>MOD + SHIFT + h</code></td>
<td>显示窗口（像一个栈一样。）</td>
</tr>
<tr>
<td><code>MOD + ENTER</code></td>
<td>将当前窗口设置为主窗口</td>
</tr>
<tr>
<td><code>MOD + f</code></td>
<td>将当前窗口全屏</td>
</tr>
<tr>
<td><code>MOD + CTRL + 方向键</code></td>
<td>移动窗口</td>
</tr>
<tr>
<td><code>MOD + ALT + 方向键</code></td>
<td>调整窗口大小</td>
</tr>
<tr>
<td><code>MOD + o</code></td>
<td>只显示当前窗口/显示所有窗口</td>
</tr>
<tr>
<td><code>MOD + t</code></td>
<td>开启/关闭 聚焦目标的浮动模式</td>
</tr>
<tr>
<td><code>MOD + SHIFT + t</code></td>
<td>开启/关闭 全部目标的浮动模式</td>
</tr>
</tbody>
</table>
<p>| <code>MOD + SHIFT + f</code>  | 开启/关闭 状态栏       |</p>
<h3 id="切换屏幕">切换屏幕</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOD + x</code></td>
<td>将鼠标移动到其他屏幕</td>
</tr>
<tr>
<td><code>MOD + SHIFT + X</code></td>
<td>将当前窗口移动到其他屏幕</td>
</tr>
</tbody>
</table>
<h2 id="links">Links</h2>
<ul>
<li>&nbsp;<a href="https://wiki.archlinux.org/title/Dwm_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener">ArchWiki Dwm</a>
</li>
<li>&nbsp;<a href="https://dwm.suckless.org/patches/" target="_blank" rel="noopener">Dwm patches</a>
</li>
<li>&nbsp;<a href="https://github.com/Katzeee/dwm-patches-chinese/blob/master/dwm-patches-chinese.md" target="_blank" rel="noopener">Dwm patches中文翻译</a>
</li>
<li>&nbsp;<a href="https://yaocc.cc/2022/06/19/linux%E4%B8%9D%E6%BB%91%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94picom/" target="_blank" rel="noopener">picom美化</a>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Neovim使用记录  </title>
      <link>https://fzdwx.github.io/posts/2022-09-28-neovim-use-notes/</link>
      <pubDate>Wed, 28 Sep 2022 15:59:37 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-09-28-neovim-use-notes/</guid>
      <description>由于最近切换到了linux，不可避免的经常需要使用vi等编辑器，所以这次好好折腾一下。</description>
      <content:encoded><![CDATA[<blockquote>
<p>由于最近切换到了linux，不可避免的经常需要使用vi等编辑器，所以这次好好折腾一下。</p>
</blockquote>
<p>我的配置地址: &nbsp;<a href="https://github.com/fzdwx/nvim" target="_blank" rel="noopener">https://github.com/fzdwx/nvim</a>
。</p>
<h2 id="我的配置">我的配置</h2>
<h3 id="pakcer">pakcer</h3>
<p>我选用的插件管理器是<code>packer</code>，我也不知道选什么好，就按最新的来吧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--- setup packer</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">vim.fn</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">install_path</span> <span class="o">=</span> <span class="n">fn.stdpath</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="o">..</span> <span class="s1">&#39;/site/pack/packer/start/packer.nvim&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">fn.empty</span><span class="p">(</span><span class="n">fn.glob</span><span class="p">(</span><span class="n">install_path</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">    <span class="n">packer_bootstrap</span> <span class="o">=</span> <span class="n">fn.system</span><span class="p">({</span> <span class="s1">&#39;git&#39;</span><span class="p">,</span> <span class="s1">&#39;clone&#39;</span><span class="p">,</span> <span class="s1">&#39;--depth&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;https://github.com/wbthomason/packer.nvim&#39;</span><span class="p">,</span> <span class="n">install_path</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="n">vim.cmd</span><span class="p">(</span><span class="s2">&#34;packadd packer.nvim&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="c1">--- add plugins</span>
</span></span><span class="line"><span class="cl"><span class="n">require</span><span class="p">(</span><span class="s1">&#39;packer&#39;</span><span class="p">).</span><span class="n">startup</span><span class="p">(</span><span class="kr">function</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- 自托管</span>
</span></span><span class="line"><span class="cl">    <span class="n">use</span> <span class="s1">&#39;wbthomason/packer.nvim&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- 其他插件</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- 如果是第一次则同步</span>
</span></span><span class="line"><span class="cl">    <span class="kr">if</span> <span class="n">packer_bootstrap</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">        <span class="n">require</span><span class="p">(</span><span class="s1">&#39;packer&#39;</span><span class="p">).</span><span class="n">sync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="alphahttpsgithubcomgoolordalpha-nvim">&nbsp;<a href="https://github.com/goolord/alpha-nvim" target="_blank" rel="noopener">alpha</a>
</h3>
<p>是一个dashboard，也可以说是一个欢迎界面。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">require</span><span class="p">(</span><span class="s1">&#39;packer&#39;</span><span class="p">).</span><span class="n">startup</span><span class="p">(</span><span class="kr">function</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">--- 添加下面两行进行安装</span>
</span></span><span class="line"><span class="cl">    <span class="n">use</span> <span class="s2">&#34;goolord/alpha-nvim&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">use</span> <span class="s2">&#34;kyazdani42/nvim-web-devicons&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- ...</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span><span class="p">)</span>
</span></span></code></pre></div><p>配置代码太长了就不放了，可以点击这里&nbsp;<a href="https://github.com/fzdwx/nvim/blob/main/lua/config/plugins/alpha.lua" target="_blank" rel="noopener"> 这里 </a>
参考。</p>
<h3 id="telescopehttpsgithubcomnvim-telescopetelescopenvim">&nbsp;<a href="https://github.com/nvim-telescope/telescope.nvim" target="_blank" rel="noopener">telescope</a>
</h3>
<p>主要作用是文件的查找与预览。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">require</span><span class="p">(</span><span class="s1">&#39;packer&#39;</span><span class="p">).</span><span class="n">startup</span><span class="p">(</span><span class="kr">function</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">--- 添加下面代码进行安装</span>
</span></span><span class="line"><span class="cl">    <span class="n">use</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;nvim-telescope/telescope.nvim&#39;</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;0.1.0&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;ahmedkhalf/project.nvim&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;nvim-lua/plenary.nvim&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">-- ...</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>&nbsp;<a href="https://github.com/fzdwx/nvim/blob/main/lua/config/plugins/telescope.lua" target="_blank" rel="noopener">配置</a>
</li>
<li>&nbsp;<a href="https://github.com/fzdwx/nvim/blob/main/lua/config/key/init.lua#L34-L52" target="_blank" rel="noopener">key map</a>
</li>
</ul>
<h2 id="一些教程">一些教程</h2>
<ol>
<li>&nbsp;<a href="https://rsdlt.github.io/posts/rust-nvim-ide-guide-walkthrough-development-debug/" target="_blank" rel="noopener">Rust and nvim</a>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>HTTP协议</title>
      <link>https://fzdwx.github.io/posts/2022-09-28-http-protocol/</link>
      <pubDate>Wed, 28 Sep 2022 12:19:15 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-09-28-http-protocol/</guid>
      <description>简介HTTP/1.1与H2。</description>
      <content:encoded><![CDATA[<blockquote>
<p>HTTP 1.1之前的实现就不讨论了，因为它们已经过时太久了，我上网的时候就已经接触不到了，所以主要说说HTTP/1.1、HTTP/2。</p>
</blockquote>
<h2 id="http11">HTTP/1.1</h2>
<h3 id="http11协议报文简介">HTTP/1.1协议报文简介</h3>
<blockquote>
<p>CRLF: <code>\r\n</code></p>
<p>METHOD: HTTP请求，<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>&hellip;</p>
<p>URI: 统一资源标识符，例如<code>/</code>，<code>/index.html</code>&hellip;</p>
<p>HTTPVersion: HTTP协议的版本号，例如<code>HTTP/1.1</code>，<code>HTTP/2</code></p>
<p>HEADERS: 请求头，例如<code>Host:localhost</code>，<code>Accept: */*</code>。</p>
<p>BODY: 请求体，例如说一个JSON数据<code>{&quot;name&quot;:&quot;fzdwx&quot;}</code></p>
<p>HTTPStatus: HTTP响应状态，常见的有<code>200</code>，<code>404</code>等</p>
<p>HTTPStatusDesc: HTTP响应状态描述，<code>200</code>对应的<code>OK</code>。</p>
</blockquote>
<h4 id="请求">请求</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">METHOD&lt;SPACE&gt;URI&lt;SPACE&gt;HTTPVersion
</span></span><span class="line"><span class="cl">HEADERS
</span></span><span class="line"><span class="cl">&lt;CRLF&gt;
</span></span><span class="line"><span class="cl">BODY
</span></span></code></pre></div><p>示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="nf">GET</span> <span class="nn">/hello</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">Host</span><span class="o">:</span> <span class="l">192.168.1.107:8889</span>
</span></span><span class="line"><span class="cl"><span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
</span></span><span class="line"><span class="cl"><span class="n">Cache-Control</span><span class="o">:</span> <span class="l">max-age=0</span>
</span></span><span class="line"><span class="cl"><span class="n">Upgrade-Insecure-Requests</span><span class="o">:</span> <span class="l">1</span>
</span></span><span class="line"><span class="cl"><span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.82 Safari/537.36</span>
</span></span><span class="line"><span class="cl"><span class="n">Accept</span><span class="o">:</span> <span class="l">text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span>
</span></span><span class="line"><span class="cl"><span class="n">Accept-Encoding</span><span class="o">:</span> <span class="l">gzip, deflate</span>
</span></span><span class="line"><span class="cl"><span class="n">Accept-Language</span><span class="o">:</span> <span class="l">zh-CN,zh;q=0.9</span>
</span></span></code></pre></div><h4 id="响应">响应</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">HTTPVersion HTTPStatus HTTPStatusDesc
</span></span><span class="line"><span class="cl">HEADERS
</span></span><span class="line"><span class="cl">&lt;CRLF&gt;
</span></span><span class="line"><span class="cl">BODY
</span></span></code></pre></div><p>示例:</p>
<blockquote>
<p>如果响应中使用了<code>transfer-encoding: chunked</code>这个来替代<code>Content-Length</code>
，就表示这是一个不固定大小的响应，结尾通常用<code>0\r\n</code>来分割。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
</span></span><span class="line"><span class="cl"><span class="n">transfer-encoding</span><span class="o">:</span> <span class="l">chunked</span>
</span></span><span class="line"><span class="cl"><span class="n">content-type</span><span class="o">:</span> <span class="l">application/json; charset=utf-8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">0</span><span class="err">/r/n</span>
</span></span></code></pre></div><h3 id="http11主要新特性">HTTP/1.1主要新特性</h3>
<ol>
<li>默认是长连接(<code>Connection: Keep-alive</code>)，支持一个TCP连接处理多个请求。</li>
<li>缓存策略，在请求头中使用<code>Cache-Control</code>，<code>Expires</code>，<code>Last-Modified</code>，<code>ETag</code>等来控制。</li>
<li>允许响应分块，就是上面提到的<code>transfer-encoding: chunked</code>，允许服务端可以多次返回响应体。</li>
</ol>
<p>但是还是存在一定的问题，例如说如果有一个TCP连接阻塞了，还是会开启新的TCP连接进行处理请求。</p>
<h2 id="h2">H2</h2>
<p>HTTP2中的主要概念:</p>
<ol>
<li><code>Connection</code>: 一个TCP连接包含一个或多个<code>Stream</code>,所有的通讯都在<strong>一个TCP连接</strong>上完成。</li>
<li><code>Stream</code>: 一个可以双向通讯的数据流，包含一条或多条<code>Message</code>，每个数据流都一个<strong>唯一标识符</strong>以及<strong>可选的优先级</strong>信息。</li>
<li><code>Message</code>: 对应HTTP/1.1中的请求或响应，包含一条或多条<code>Frame</code>。</li>
<li><code>Frame</code>: <strong>最小传输单位</strong>，它以<strong>二进制</strong>进行编码。</li>
</ol>
<p>&nbsp;<a href="/images/1.png">HTTP通讯简图</a>
</p>
<p>在HTTP/1.1中是有<code>Start Line</code> + <code>header</code> + <code>body</code> 组成的，而在H2中是由一个<code>HEADER Frame</code>以及多个<code>DATA Frame</code>组成的。</p>
<p><figure id="a-/images/2.png" class="align-center">
    <img src="/images/2.png" alt="HTTP/1.1与H2报文组成的区别"  />
    
    <figcaption>
       HTTP/1.1与H2报文组成的区别
    </figcaption>
    
</figure></p>
<h3 id="frame">Frame</h3>
<p>通常有一些公共的字段，例如<code>Length</code>，<code>Type</code>，<code>Flags</code>以及<code>Stream Id</code>；也各个类型所独有的字段。</p>
<p>分类如下:</p>
<ul>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-0" target="_blank" rel="noopener">DATA</a>
: 用于传输http消息体。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-1" target="_blank" rel="noopener">HEADERS</a>
: 用于传输首部字段。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-2" target="_blank" rel="noopener">PRIORITY</a>
: 用于指定或重新指定引用资源的优先级。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-3" target="_blank" rel="noopener">RST_STREAM</a>
: 用于通知流的非正常终止。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-4" target="_blank" rel="noopener">SETTINGS</a>
: 用于约定客户端和服务端的配置数据。例如设置初识的双向流量控制窗口大小。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-9" target="_blank" rel="noopener">PUSH_PROMISE</a>
: 服务端推送许可。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-10" target="_blank" rel="noopener">PING</a>
: 用于计算往返时间，执行“ 活性” 检活。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-11" target="_blank" rel="noopener">GOAWAY</a>
: 用于通知对端停止在当前连接中创建流。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-12" target="_blank" rel="noopener">WINDOW_UPDATE</a>
: 用于调整个别流或个别连接的流量。</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/#toc-17" target="_blank" rel="noopener">CONTINUATION</a>
: 专门用于传递较大 HTTP 头部时的持续帧。</li>
</ul>
<h3 id="为什么h2必须要走https">为什么H2必须要走HTTPS？</h3>
<p>这其实在H2标准中没有规定，主要是为了更方便的进行HTTP协议的 升级/协商，确认一个Web服务器是否支持H2通常有两种方式:</p>
<ol>
<li>在请求头中设置<code>Upgrade: HTTP/2.0</code>以及<code>Connection: Upgrade,HTTP2-Settings</code>等，类似升级到<code>Websocket</code>。</li>
<li>使用<code>TLS</code>中的<code>ALPN</code>(Application Layer Protocol Negotiation，应用层协议协商)中的<code>ALPN Next Protocol</code>
字段，在<code>Client Hello</code>与<code>Server Hello</code>这个阶段就可以确定下来。</li>
</ol>
<p>而现在的<strong>浏览器</strong>基本都是<strong>实现的方式二</strong>，即<strong>与HTTPS绑定在一起</strong>。但是如果我们不用浏览器进行访问，当然也可以不用HTTPS。</p>
<p>详细可&nbsp;<a href="https://imququ.com/post/protocol-negotiation-in-http2.html" target="_blank" rel="noopener">参考</a>
。</p>
<h3 id="为什么h2能实现并行响应请求">为什么H2能实现并行响应请求?</h3>
<p>在HTTP/1.1中，请求与响应是一一对应的，在同一个连接里，客户端依次发送两个请求，一段时间以后收到来自服务器的一个响应，这个响应一定是对应于第一个发出去的请求的。
因为<strong>没有一个标志来表示哪个响应对应哪个请求</strong>。</p>
<p>而在H2中基于<code>Stream</code>和<code>Frame</code>的设计: <strong>每个<code>Frame</code>都带有<code>Stream Id</code>来标识是否为同一个<code>Stream</code>里面的数据</strong>，每个<code>Stream</code>
互不影响，这样就能做到在一个TCP里面连接里面传输多对请求/响应。</p>
<h2 id="h2的新特性">H2的新特性</h2>
<p>H2的对HTTP/1.1优化的核心就是 <strong>使用尽可能少的连接数</strong>。</p>
<ol>
<li>多路复用: 只用一个TCP连接就能处理多对 请求/响应 ，不用在开启另外的TCP连接，就是通过<code>Stream</code>与<code>Frame</code>来实现的。</li>
<li>二进制分帧: 使用<code>Frame</code>为最小单位进行通讯，并采用二进制编码。</li>
<li>&nbsp;<a href="https://juejin.cn/post/7133238781452222472" target="_blank" rel="noopener">头部压缩</a>
: 使用<code>HPACK</code>算法进行优化.
<ul>
<li>维护一份相同的&nbsp;<a href="https://httpwg.org/specs/rfc7541.html#static.table.definition" target="_blank" rel="noopener">静态字典</a>
，包含常见的请求头的KV组合</li>
<li>一份动态字典，可以动态的扩容(每个连接单独维护)</li>
<li>支持哈夫曼编码(&nbsp;<a href="https://httpwg.org/specs/rfc7541.html#huffman.code" target="_blank" rel="noopener">静态哈夫曼码表</a>
)</li>
</ul>
<blockquote>
<p>在HTTP/1中消息体可以用gzip进行压缩，但是请求头通常没有任何压缩，有时候请求头的数据可能比请求体的数据还多。</p>
</blockquote>
</li>
<li>请求优先级: 一般在<code>HEADERS</code>帧与<code>PRIORITY</code>帧中携带，通常依赖于服务端的支持程度。</li>
</ol>
<h2 id="工具">工具</h2>
<h3 id="生成测试签名">生成测试签名</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">go run <span class="nv">$GOROOT</span>/src/crypto/tls/generate_cert.go --host localhost
</span></span></code></pre></div><h3 id="使用curl调试https">使用curl调试HTTPS</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">curl https://zcygov.cn -vv
</span></span></code></pre></div><h2 id="links">Links</h2>
<ul>
<li>&nbsp;<a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>
</li>
<li>&nbsp;<a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener">HPACK: Header Compression for HTTP/2</a>
</li>
<li>&nbsp;<a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener">HTTP/2资料汇总</a>
</li>
<li>&nbsp;<a href="https://halfrost.com/http2-http-frames-definitions/" target="_blank" rel="noopener">HTTP/2中帧的定义</a>
</li>
<li>&nbsp;<a href="https://www.dropbox.com/s/4duv6cqrhud4qzw/HTTP2%EF%BC%9A%E6%96%B0%E7%9A%84%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98.pdf?dl=0" target="_blank" rel="noopener">HTTP/2新的机遇与挑战</a>
</li>
<li>&nbsp;<a href="https://zhuanlan.zhihu.com/p/566351358" target="_blank" rel="noopener">探索http1.0到http3.0的发展史，详解http2.0</a>
</li>
<li>&nbsp;<a href="https://www.zhihu.com/question/34074946/answer/2264788574" target="_blank" rel="noopener">HTTP/2相比1.0有哪些重大改进</a>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>MapReduce 框架实现思路</title>
      <link>https://fzdwx.github.io/posts/2022-09-27-mit6.824-lab1/</link>
      <pubDate>Tue, 27 Sep 2022 21:45:29 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-09-27-mit6.824-lab1/</guid>
      <description>about mit6.824 lab1(Map reduce framework)</description>
      <content:encoded><![CDATA[<p>看的时候很懵，写的时候更懵，我以为是要写几个<code>MapReduce</code>的程序，在把官方的<code>A few rules</code>以及<code>Hints</code>(
翻译可以看&nbsp;<a href="https://www.nowcoder.com/discuss/962675" target="_blank" rel="noopener">这里</a>
) 仔细的阅读了几遍后才发现是要写一个
MapReduce 的调度框架。。。</p>
<p>解题思路可以分为 3 步。</p>
<ol>
<li><code>worker</code>与<code>master</code>先通过<code>rpc</code>进行通信，即<code>worker</code>发送请求，<code>master</code>能够正确的应答且<code>worker</code>
能够收到。这一部分其实示例代码已经给到了，可以模仿着写一个从<code>master</code>获取需要执行的任务名称的<code>rpc request</code>。</li>
<li>上面一步完成后就可以进行真正的<code>Map task</code>请求以及执行了:
<ul>
<li><code>Map task</code>何时生成？</li>
<li>每个<code>worker</code>只向<code>master</code>请求一次就好了吗？</li>
<li><code>Map task</code>执行 超时/失败 需要有重试机制吗？</li>
<li>如何保证<code>Map task</code>消费时的线程安全？</li>
</ul>
</li>
<li>当所有的<code>Map task</code>执行完毕后就需要执行<code>Reduce task</code>了，如果你写完了第 2 步，那么<code>Reduce task</code>其实就是水到渠成了。
<ul>
<li>生成<code>Reduce task</code>，这里的每个<code>Reduce task</code>需要加载的文件按什么分成一组？</li>
<li>剩下的与<code>Map task</code>处理方法相同。</li>
</ul>
</li>
</ol>
<hr>
<p>我就是卡在了<code>Reduce task</code>创建时文件分组这个地方了，我直接把同一个<code>Map task</code>生成的文件当成一组了&hellip;但是显然不是这样。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>About rofi</title>
      <link>https://fzdwx.github.io/posts/2022-09-18-about-rofi/</link>
      <pubDate>Sun, 18 Sep 2022 22:15:39 +0800</pubDate>
      
      <guid>https://fzdwx.github.io/posts/2022-09-18-about-rofi/</guid>
      <description>一个 linux 下的 application launcher, 让你只用键盘就可以进行应用的启动与切换。</description>
      <content:encoded><![CDATA[<blockquote>
<p>今天发现了一个 linux 下的 application launcher &nbsp;<a href="https://github.com/davatorium/rofi" target="_blank" rel="noopener">rofi</a>
 ，它可以快速切换窗口和启动程序，
我用它和<code>wmctrl</code>进行配合使用。</p>
</blockquote>
<p><strong>我的使用过程:</strong></p>
<p>1.Archlinux install</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">yay -S rofi
</span></span></code></pre></div><p>2.添加自定义快捷键绑定 hotkey 为<code>alt</code>+<code>space</code>触发<code>rofi -show</code>。</p>
<p>3.press<code>alt</code>+<code>space</code>，然后使用<code>shift</code>+<code>left</code>or<code>right</code>进行切换 mode 。</p>
<hr>
<p><strong>更改主题以及显示 icon</strong>:</p>
<p>1.生成配置文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p ~/.config/rofi
</span></span><span class="line"><span class="cl">rofi -dump-config &gt; ~/.config/rofi/config.rasi
</span></span></code></pre></div><p>2.显示icon</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sed -i <span class="s1">&#39;8c show-icons: true;&#39;</span> ~/.config/rofi/config.rasi
</span></span></code></pre></div><p>3.更换主题</p>
<p>参考 &nbsp;<a href="https://github.com/lr-tech/rofi-themes-collection#installing-themes" target="_blank" rel="noopener">https://github.com/lr-tech/rofi-themes-collection#installing-themes</a>
</p>
<hr>
<p><strong>我的<code>wmctrl</code>的配置示例</strong>:</p>
<blockquote>
<p>使用<code>xprop WM_CLASS</code>获取前缀。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">chrome</span><span class="o">=</span><span class="s2">&#34;wmctrl -x -a google-chrome || google-chrome-stable &gt; /dev/null 2&gt;&amp;1 &amp;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">note</span><span class="o">=</span><span class="s2">&#34;wmctrl -x -a obsidian || /usr/bin/obsidian &gt; /dev/null 2&gt;&amp;1 &amp;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">codew</span><span class="o">=</span><span class="s2">&#34;wmctrl -x -a code || /opt/code/code &gt; /dev/null 2&gt;&amp;1 &amp;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">idea</span><span class="o">=</span><span class="s2">&#34;wmctrl -x -a jetbrains-idea || /opt/idea/bin/idea.sh &gt; /dev/null 2&gt;&amp;1 &amp;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">discord</span><span class="o">=</span><span class="s2">&#34;wmctrl -x -a discord || /opt/discord/Discord &gt; /dev/null 2&gt;&amp;1 &amp;&#34;</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
