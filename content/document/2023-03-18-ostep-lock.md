---
title: "锁: Lock"
date: 2023-03-18T13:50:19+08:00
update: 2023-03-18T13:50:19+08:00
draft: false
ShowToc: true
ShowBreadCrumbs: false
docs: [ostep]
---

> 在上一篇出现问题的最主要原因就是有多个线程访问了同一个变量(共享变量),导致出现了竞态条件.
> 从而使一个简单的 ++ 操作都不能正确的执行
>
> 这是由于操作系统的打断机制: 操作系统不会让每个程序独占 cpu 一直执行,会进行周期性的打断,
> 来切换其他 线程/程序 来执行.(++ 操作不仅只是一条指令)
>
> 而 Lock 可以直接解决这个问题,在代码中加锁,放在临界区的周围,确保临界区能够向单条指令的原子执行

lock() 就是获取锁,如果没有其他线程持有锁,当前线程就会获取锁从而进入临界区. 如果此时有另一个线程也调用 lock() 那么这个线程调用的 lock() 不会返回,直到这把锁释放.

而当锁的持有者调用 unlock() 后锁就变为可用的了. 如果没有其他线程卡在 lock() 里面,锁的状态就为可用的,如果有线程卡在 lock() 里面,那么其中的某一个会注意到锁状态的变化,然后获取到锁并进入临界区

## 1. 禁用操作系统打断实现的锁

最简单的单 cpu 的锁实现, 可以通过 启用/禁用 操作系统的打断机制来实现

```c
void lock(){
  disableInterrupts()
}

void unlock(){
  enableInterrupts()
}
```

这个锁实现的前提是单 cpu,调用 lock() 后当前线程就能独自 cpu,因为它禁用了操作系统的打断功能,从而独占了 cpu

## 2. CAS

```rust
let lock = 0;

fn lock(){
  while (lock ==1){
    }
    lock = 1;
}

fn unlock(){
  lock = 0;
}
```
