---
title: "GFS"
date: 2022-10-07T21:12:56+08:00
draft: false
---

1. 为了性能(**Performance**), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(**Sharding**)。
2. 而成败上千的机器总会发生错误，所以有了容错(**Fault Tolerance**)。
3. 实现容错最简单的方式就是复制(**Replication**)，其中一个发生故障了就切换另一个。
4. 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(**Inconsistency**)。
5. 如果为了实现一致性(**Consistency**)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(**Low Perf**)
   ，但这与我们开始的希望不符合。

{{< block type="tip">}}
So，强一致性代表着低性能。
{{< /block >}}

## GFS Master 中主要的两个data table

1. filename -> chunk ids(chunk handles) _**NV**_
2. chunk handle与chunk数据的对应关系
    - chunk保存在哪个服务器上(chunk server list)
    - chunk的version no _**NV**_
    - chunk的primary chunk server，因为写操作在在其上进行
    - primary chunk server的lease expiration

这两个data table都在master的内存中存放，为了容错(比如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。
每当有数据变更时，就会在磁盘上的日志进行追加，并且定期创建checkpoint(类似快照，不用从头开始读取)


next https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.5

## Links

1. [gfs paper 原文](https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf)
2. [gfs paper 中文翻译](https://zhuanlan.zhihu.com/p/424677701)
3. [gfs 视频](https://www.bilibili.com/video/BV1R7411t71W/?p=3&spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=98f230be6561d2fc7450e7ce05876f68)
4. [gfs 视频翻译](https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.1)
5. [Bad Replication Design](https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.2-qiang-yi-zhi-xing-strong-consistency) 
