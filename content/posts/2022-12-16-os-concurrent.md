---
title: "操作系统的并发编程"
date: 2022-12-16T20:54:45+08:00
draft: false
---

> 操作系统是最早的并发程序之一。


开始，我们肯定要理解什么是并发和并行以及它们的区别。
- 并行： 可以同时处理多个任务。
- 并发： 可以执行多个任务，但是同时只能执行一个任务，会在它们之间进行切换。

## 如果一个操作系统要支持并发，那么以下的哪些部分需要复制多份？

1. 全局变量
2. 堆内存
3. 函数调用栈

![答案显而易见的是 函数调用栈](/images/Pasted%20image%2020221216211245.png)

并发编程为什么难？
1. 所有线程都共享一个堆内存
2. 单个线程的状态机的执行结果是固定的，但是多线程不一样，因为它们涉及到一个线程切换的问题，这会导致每次程序运行的结果可能都是不一样的。

![多线程状态机执行示意图](/images/Pasted%20image%2020221216211708.png)

## 无法保证的三个特性

1. 原子性: 一段代码执行时独占整个计算机系统
	1. 无法保证的例子： 两个线程对一个值进行 ++ N 次， 这个结果可能不是 2N
	2. 实现原子性： `lock` & `unlock` 
		- 实现临界去的绝对串行化
		- 其他部分仍然可以并行执行
2. 顺序性: 代码按编写的顺序执行，也就是实现源代码的按顺序翻译(为汇编)。
	1. 会导致的原因: 编译器的优化(**编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效**。)，比如说 gcc 加`-O1/2`
	2. 实际例子：
		```c
		while(!done);
		// => opt
		if (!done) while(1); 
		```
	3. 实现源代码的按顺序翻译： 在代码中插入“优化不能穿越的” barrier
		1. asm volatile ("" ::: "memory");
			1. 含义是 可以读写任何内存
		2. 使用 volatile 变量
			1. 保持 c 语义和汇编语义一致
		 ```c
		 extern int volatile done;
		 while(!done);
		```
1. 可见性： 对某个共享内存的修改，其他线程要立马可见。
	1. 一段代码: 它的结果可能为: `0,0` `0,1` `1,0` `1,1` 4种情况, 但是只要有方法(f1 / f2)被执行就不会出现`0,0`这种结果。但实际的情况是`0,0`这个结果出现的次数最多。
		```c
		int x = 0, y= 0;
		void f1(){
			 x = 1;
			 asm volatile("":::"memory");
			 printf("%d ",y)
		}

		void f2(){
			y = 1;
			asm volatile("":::"memory");
			printf("%d ",x)
		}
		```
	2. 原因是：现代处理器也是一个动态编译器。单个处理器把汇编（用电路）编译成更小的操作符。
		1. 在任何时刻，处理器都维护了一个操作符的容器
		2. 每一周期尽可能多的补充操作符
		3. 每一周期执行尽可能多的操作符
		4. 乱序执行，按序提交
	3. 实现顺序一致性： 使用`mfence`指令或使用原子指令(lock),让它每次都到内存中去读取，而不读取缓存
  
