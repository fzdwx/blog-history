[{"content":"以 Archlinux 为例子\nbluetoothctl power on # 扫描 bluetoothctl scan on # 结对 bluetoothctl pair xxx # 连接 bluetoothctl connect xxx # 设置 蓝牙为默认输出 pavucontrol 设置 蓝牙为默认输出 ","permalink":"https://fzdwx.github.io/posts/2023-02-09-bluetooth/","summary":"以 Archlinux 为例子\nbluetoothctl power on # 扫描 bluetoothctl scan on # 结对 bluetoothctl pair xxx # 连接 bluetoothctl connect xxx # 设置 蓝牙为默认输出 pavucontrol 设置 蓝牙为默认输出 ","title":"linux 连接蓝牙耳机"},{"content":" 现在比较流行的 buffer line 插件是 \u0026nbsp;akinsho/bufferline ，但是我感觉他太重了，而且不好看。比如说它可以跟 lsp 集成，可以切换各种 tab/buffer 模式等,但是不一定每个人都需要，而且各个顺序都固定了，总之就是我想造轮子: \u0026nbsp;fzdwx/bufline.nvim 在 nvim 中定义 tabline 可以使用 vim.opt.tabline=xxx 来设置, 比如说下面这段代码，就很容易的实现一个 buffer line：\nfunction _G.qweqweqwe() retrun \u0026#34;this is my line\u0026#34; end -- config vim.opt.tabline = \u0026#34;%!v:lua.qweqweqwe()\u0026#34; Show 那么接下来就很容易想到:\n获取所有 buffer 获取 buffer 对应文件的信息 比如说文件名称 显示文件 icon(由 \u0026nbsp;nvim-tree/nvim-web-devicons 支持) 支持高亮 如何实现的就不赘述了，如果有兴趣可以查看: \u0026nbsp;fzdwx/bufline.nvim 。 目前所有的内容都可以自定义：\nM.folder -- 入参是 buffer 数量，要求返回 Group: {hl,str} M.dirName -- 入参是当前 buffer id, 要求返回 Group M.devicon -- 入参是当前 buffer id,\u0026#34;Sel/NoSel\u0026#34;,是否选中, 要求返回 Group M.title -- 入参是当前 buffer id,\u0026#34;Sel/NoSel\u0026#34;, 要求返回 Group M.modified -- 入参是当前 buffer id, 要求返回 str M.separator -- 要求返回 Group -- 下面这两个方法也可以自定义，需要用户自己保证正确性 M.cell -- 每个 buffer 对应的信息,入参是当前 buffer id,当前选择的buffer id,要求返回 group 列表 M.bufline -- 构造整个 bufline str 就是具体内容, hl 就是要高亮标签, 例如 BufLineFolder当前支持：\nBufLineTitleSel BufLineTitleNoSel BufLineFill BufLine BufLineFolder 这些高亮标签都没有默认设置，需要用户自定义，例如:\nvim.cmd([[au ColorScheme * hi BufLineTitleSel gui=none guibg=\u0026#39;#282C34\u0026#39; guifg=\u0026#39;#5C6370\u0026#39;]]) 设置高亮遇到的问题，当设置 icon 的背景为空时，有背景颜色的 icon 跟没有的会一大一小，后来没办法，只能让它都开启颜色的，也就是没选中的 buffer 也会开启颜色跟 bufferline的一样。\n在 lazy 中使用:\n{ \u0026#34;fzdwx/bufline.nvim\u0026#34;, event = \u0026#34;BufEnter\u0026#34;, dependencies = { \u0026#34;nvim-tree/nvim-web-devicons\u0026#34;, }, config = function() local buf = require(\u0026#34;bufline\u0026#34;) buf.setup({ -- 自定义 separator separator = function() return { str = \u0026#39;\u0026#39;, hl = \u0026#34;\u0026#34; } end }) end, }, ","permalink":"https://fzdwx.github.io/posts/2023-02-01-bufline/","summary":"现在比较流行的 buffer line 插件是 \u0026nbsp;akinsho/bufferline ，但是我感觉他太重了，而且不好看。比如说它可以跟 lsp 集成，可以切换各种 tab/buffer 模式等,但是不一定每个人都需要，而且各个顺序都固定了，总之就是我想造轮子: \u0026nbsp;fzdwx/bufline.nvim 在 nvim 中定义 tabline 可以使用 vim.opt.tabline=xxx 来设置, 比如说下面这段代码，就很容易的实现一个 buffer line：\nfunction _G.qweqweqwe() retrun \u0026#34;this is my line\u0026#34; end -- config vim.opt.tabline = \u0026#34;%!v:lua.qweqweqwe()\u0026#34; Show 那么接下来就很容易想到:\n获取所有 buffer 获取 buffer 对应文件的信息 比如说文件名称 显示文件 icon(由 \u0026nbsp;nvim-tree/nvim-web-devicons 支持) 支持高亮 如何实现的就不赘述了，如果有兴趣可以查看: \u0026nbsp;fzdwx/bufline.nvim 。 目前所有的内容都可以自定义：\nM.folder -- 入参是 buffer 数量，要求返回 Group: {hl,str} M.dirName -- 入参是当前 buffer id, 要求返回 Group M.devicon -- 入参是当前 buffer id,\u0026#34;Sel/NoSel\u0026#34;,是否选中, 要求返回 Group M.","title":"自定义一个 Neovim bufferline"},{"content":"今天简单尝试了一下 \u0026nbsp;Hyprland ,它的功能类似于 \u0026nbsp;DWM + picom 的组合。只是粗略的尝试了一下，发现还是有一些问题:\n分屏的时候，扩展屏幕的光标不显示 设置 WLR_NO_HARDWARE_CURSORS=1 即可解决 扩展屏幕不时有一些黑块闪烁 替换安装包为 hyprland-nvidia-git 即可解决 waybar 有一点用的不爽，它的 workspaces 不是每个屏幕都是独立的(DWM 中的 tag 功能) 当然它还是有一些好处的:\n不打任何补丁就有很好的可用性 自带了一些动画效果 配置文件热加载(即每次修改就会立即生效) 这一点好评，DWM 是每次修改了配置都要重新 make 但是我还是选择继续使用 DWM，因为它没有什么必须切换的理由，而且有一些我常用的功能在 Hyprland 中没有找到替代的，加上我的 DWM 的配置也趋于稳定了，也新增了可以点击的 status bar（Hyprland 下使用waybar 可以做到这个功能）。\n相关代码 安装脚本:\n# 安装 hyperland yay -S hyprland-nvidia-git # 安装 waybar yay -S waybar-hyprland-git # 安装 hyprland share yay -S xdg-desktop-portal-hyprland-git # 安装 rofi for wayland yay -S rofi-lbonn-wayland-git # 安装 壁纸切换 git clone https://github.com/Horus645xx/swww cd swww cargo build --release cp /target/release/swww /usr/bin cp /target/release/swww-daemon /usr/bin swww init swww img --transition-type left ~/Pictures/bg/0494e945880511ebb6edd017c2d2eca2.png 供参考的启动脚本:\nexport LIBVA_DRIVER_NAME=nvidia export XDG_SESSION_TYPE=wayland export GBM_BACKEND=nvidia-drm export __GLX_VENDOR_LIBRARY_NAME=nvidia export WLR_NO_HARDWARE_CURSORS=1 # fix cursor # Example IME Support: fcitx5 export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 export SDL_IM_MODULE=fcitx5 export GLFW_IM_MODULE=ibus exec Hyprland ~/.config/hypr/hyprland.conf:\n######################################################################################## AUTOGENERATED HYPR CONFIG. PLEASE USE THE CONFIG PROVIDED IN THE GIT REPO /examples/hypr.conf AND EDIT IT, OR EDIT THIS ONE ACCORDING TO THE WIKI INSTRUCTIONS. ######################################################################################## # # Please note not all available settings / options are set here. # For a full list, see the wiki # # See https://wiki.hyprland.org/Configuring/Monitors/ monitor=,preferred,auto,auto #monitor=eDP-1-1, 1920x1080@144, 1920x0, 1 #monitor=HDMI-0, 1920x1080@60, 0x0, 1 # See https://wiki.hyprland.org/Configuring/Keywords/ for more # Execute your favorite apps at launch # exec-once = waybar \u0026amp; hyprpaper \u0026amp; firefox exec-once = fcitx5 exec-once = flameshot exec-once = /opt/clash/cfw exec-once = waybar #exec-once = dunst # Source a file (multi-file configs) # source = ~/.config/hypr/myColors.conf #misc { # no_vfr = 1 #} # For all categories, see https://wiki.hyprland.org/Configuring/Variables/ input { kb_layout = us kb_variant = kb_model = kb_options = kb_rules = follow_mouse = 1 touchpad { natural_scroll = no } sensitivity = 0 # -1.0 - 1.0, 0 means no modification. } general { # See https://wiki.hyprland.org/Configuring/Variables/ for more gaps_in = 5 gaps_out = 20 border_size = 2 col.active_border = rgba(33ccffee) rgba(00ff99ee) 45deg col.inactive_border = rgba(595959aa) layout = dwindle } decoration { # See https://wiki.hyprland.org/Configuring/Variables/ for more rounding = 10 blur = yes blur_size = 3 blur_passes = 1 blur_new_optimizations = on drop_shadow = yes shadow_range = 4 shadow_render_power = 3 col.shadow = rgba(1a1a1aee) } animations { enabled = yes # Some default animations, see https://wiki.hyprland.org/Configuring/Animations/ for more bezier = myBezier, 0.05, 0.9, 0.1, 1.05 animation = windows, 1, 7, myBezier animation = windowsOut, 1, 7, default, popin 80% animation = border, 1, 10, default animation = fade, 1, 7, default animation = workspaces, 1, 6, default } dwindle { # See https://wiki.hyprland.org/Configuring/Dwindle-Layout/ for more pseudotile = yes # master switch for pseudotiling. Enabling is bound to mainMod + P in the keybinds section below preserve_split = yes # you probably want this } master { # See https://wiki.hyprland.org/Configuring/Master-Layout/ for more new_is_master = true } gestures { # See https://wiki.hyprland.org/Configuring/Variables/ for more workspace_swipe = off } # Example per-device config # See https://wiki.hyprland.org/Configuring/Keywords/#executing for more device:epic mouse V1 { sensitivity = -0.5 } # Example windowrule v1 # windowrule = float, ^(kitty)$ # Example windowrule v2 # windowrulev2 = float,class:^(kitty)$,title:^(kitty)$ # See https://wiki.hyprland.org/Configuring/Window-Rules/ for more # # 定义 class 带 float 的都初始为 float 启动 windowrulev2 = float,class:^(float)$ windowrulev2 = noborder,class:^(noborder)$ # See https://wiki.hyprland.org/Configuring/Keywords/ for more $mainMod = SUPER $term = wezterm $term_float = wezterm start --class float $rofi = rofi -show window -show-icons # start term bind = $mainMod, Return, exec, $term # start float term bind = $mainMod, minus, exec, $term_float # start launch bind = ALT, SPACE, exec, $rofi # kill window bind = $mainMod, Q, killactive, bind = $mainMod, P, pseudo, # dwindle bind = $mainMod, J, togglesplit, # dwindle # super + f 全屏窗口 bind=$mainMod,F,fullscreen,0 # super + space 将窗口切换为浮动 bind=$mainMod,SPACE,togglefloating,active # 切换聚焦窗口 bind=SUPER,left,movefocus,l bind=SUPER,right,movefocus,r bind=SUPER,up,movefocus,u bind=SUPER,down,movefocus,d # 将当前窗口移动 可以一直移动 bind=SUPERSHIFT,left,movewindow,l bind=SUPERSHIFT,right,movewindow,r bind=SUPERSHIFT,up,movewindow,u bind=SUPERSHIFT,down,movewindow,d # 切换工作空间 bind=SUPER,TAB,workspace,previous bind = $mainMod, 1, workspace, 1 bind = $mainMod, 2, workspace, 2 bind = $mainMod, 3, workspace, 3 bind = $mainMod, 4, workspace, 4 bind = $mainMod, 5, workspace, 5 bind = $mainMod, 6, workspace, 6 bind = $mainMod, 7, workspace, 7 bind = $mainMod, 8, workspace, 8 bind = $mainMod, 9, workspace, 9 bind = $mainMod, 0, workspace, 10 # alt+super + 方向键 控制窗口大小 bind=$mainMod,comma,resizeactive,-20 0 bind=$mainMod,period,resizeactive,20 0 bind=ALT_SUPER,up,resizeactive,0 -20 bind=ALT_SUPER,down,resizeactive,0 20 # Move active window to a workspace with mainMod + SHIFT + [0-9] bind = $mainMod SHIFT, 1, movetoworkspace, 1 bind = $mainMod SHIFT, 2, movetoworkspace, 2 bind = $mainMod SHIFT, 3, movetoworkspace, 3 bind = $mainMod SHIFT, 4, movetoworkspace, 4 bind = $mainMod SHIFT, 5, movetoworkspace, 5 bind = $mainMod SHIFT, 6, movetoworkspace, 6 bind = $mainMod SHIFT, 7, movetoworkspace, 7 bind = $mainMod SHIFT, 8, movetoworkspace, 8 bind = $mainMod SHIFT, 9, movetoworkspace, 9 bind = $mainMod SHIFT, 0, movetoworkspace, 10 # shift + super + left/right 移动窗口 到下一个或上一个工作区 bind = $mainMod SHIFT,Left,movetoworkspace,e-1 bind = $mainMod SHIFT,right,movetoworkspace,e+1 # Scroll through existing workspaces with mainMod + scroll bind = $mainMod, mouse_down, workspace, e+1 bind = $mainMod, mouse_up, workspace, e-1 # Move/resize windows with mainMod + LMB/RMB and dragging bindm = $mainMod, mouse:272, movewindow bindm = $mainMod, mouse:273, resizewindow ","permalink":"https://fzdwx.github.io/posts/2023-01-26-hyprland/","summary":"今天简单尝试了一下 \u0026nbsp;Hyprland ,它的功能类似于 \u0026nbsp;DWM + picom 的组合。只是粗略的尝试了一下，发现还是有一些问题:\n分屏的时候，扩展屏幕的光标不显示 设置 WLR_NO_HARDWARE_CURSORS=1 即可解决 扩展屏幕不时有一些黑块闪烁 替换安装包为 hyprland-nvidia-git 即可解决 waybar 有一点用的不爽，它的 workspaces 不是每个屏幕都是独立的(DWM 中的 tag 功能) 当然它还是有一些好处的:\n不打任何补丁就有很好的可用性 自带了一些动画效果 配置文件热加载(即每次修改就会立即生效) 这一点好评，DWM 是每次修改了配置都要重新 make 但是我还是选择继续使用 DWM，因为它没有什么必须切换的理由，而且有一些我常用的功能在 Hyprland 中没有找到替代的，加上我的 DWM 的配置也趋于稳定了，也新增了可以点击的 status bar（Hyprland 下使用waybar 可以做到这个功能）。\n相关代码 安装脚本:\n# 安装 hyperland yay -S hyprland-nvidia-git # 安装 waybar yay -S waybar-hyprland-git # 安装 hyprland share yay -S xdg-desktop-portal-hyprland-git # 安装 rofi for wayland yay -S rofi-lbonn-wayland-git # 安装 壁纸切换 git clone https://github.","title":"Wayland下的窗口管理器： Hyprland"},{"content":" TIP 提高系统的性能和效率是操作系统的核心目标之一：\n通过提前加载应用程序到内存，减少应用程序切换开销 通过协作机制支持程序主动放弃处理器，提高系统执行效率 通过抢占机制支持程序被动放弃处理器，保证不同程序对处理器资源使用的公平性，也进一步提高了应用对 I/O 事件的响应效率 通过特权级机制我们可以轻松实现一个顺序执行程序的操作系统：\n在硬件级特权隔离机制的帮助之下，运行在更高特权级的操作系统不会受到有意或者无意出错的应用的影响 在硬件异常触发机制的帮助之下，可以全方位监控运行在用户态低特权级的应用执行 一旦应用越过了特权级界限或主动申请获得操作系统的服务，就会触发 Trap 进入到内核栈中进行处理 无论原因是应用出错或应用申请更高级别的权限，操作系统就会开始运行下一个程序 可以看到这个操作系统的特是: 在内存中同一时间最多只需要驻留一个应用。因为只要当一个应用结束运行或运行出错时，操作系统才会加载另一个应用程序到该内存 。\n而一次只能运行一个程序是显然不符合我们对于操作系统的期望的，所以人们就考虑开始在内存中尽量同时驻留多个应用，提高处理器的利用率。\n多道程序 一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序 多道程序操作系统的结构 首先 Qemu 把多个应用程序和 MultiprogOS 的 image 镜像加载到内存中 RustSBI(bootloader)完成基本的硬件初始化后，跳转到 MultiprogOS 的起始位置 MultiprogOS 首先进行正常运行前的初始化工作，建立栈空间和清空 bss 段 然后通过 AppManager 从 app 列表中把所有 app 都加载到内存中，并按指定顺序在用户态一个个的执行 协作式操作系统 在多道程序运行方式下，一个程序如果不让出处理器，其他程序是无法执行的。如果一个应用由于 I/O 操作让处理器空闲或让处理器忙等，那其他需要处理器资源进行计算的应用还是没法使用空闲的处理器。\n所以就相当让应用在执行 I/O 操作或空闲时，可以主动 释放处理器，让其他应用继续执行。由操作系统提供这样的服务(syscall)给应用程序调用,这种操作系统就是支持 多道程序 或 协作式多任务 的协作式操作系统\n协作式操作系统 把 Appmanager 拆分为负责加载应用的 Loader 和管理应用运行过程的 TaskManger Taskmanager 通过 task 任务控制块来管理应用程序的执行过程，支持应用程序主动放弃 CPU 并切换到另一个应用继续执行 应用程序在运行时有自己所在的内存空间和栈，确保被切换时相关信息不会被其他应用破坏 如果当前应用程序正在运行，则该应用对应的任务处于 Running 状态 如果该应用主动放弃处理器，则切换到 Ready 状态 操作系统进行任务切换时，需要把暂停任务的上下文(即任务用到的通用寄存器)保存起来 把要继续执行的任务的上下文恢复为暂停前的内容 抢占式操作系统 由于应用程序员在编写程序时，无法做到在程序合适的位置放置 放弃处理器的系统调用请求，这样系统的整体利用率还是无法提高。\n所以还需要有一种机制能强制打断应用程序的执行，来提高系统的利用率。在计算机体系的硬件设计中，外设可以通过硬件中断机制来与处理器进行 I/O 交互操作。这种打断机制可以随时打断应用程序的执行，并让操作系统完成对外设的 I/O 响应。\n而操作系统可以进一步用某种固定时长为时间间隔的外设中断(比如时钟中断)来强制打断一个程序的执行，这样一个程序只能运行一段时间(可以简称为一个时间片, time slice)就一定会让出处理器，且操作系统可以在处理外设的 I/O 响应后，让不同的应用程序分时占用处理器执行，并可通过统计程序占用处理器的总执行时间来评估程序对处理器资源的消耗。这种运行方式就是分时共享(time sharing) 或 抢占式多任务(multitasking),也可以合称为分时多任务。\n我们可以把:\n一个程序一次完整执行过程称为一次任务(task) 一个程序在一个时间片上占用处理器执行的过程称为一个任务片（task slice) 操作系统对不同程序的执行过程中的任务片进行调度和管理，即通过平衡各个程序在整个时间段上的任务片数量就能达到一定程序的系统公平和高效的系统效率。\nTIP 在一个包含多个时间片的时间段上，会有属于不同程序的多个任务片在轮流占用处理器执行，这样的系统就是支持分时多任务或抢占式多任务的抢占式操作系统。 分时多任务操作系统 改进 Trap Handle，支持时钟中断，从而可以抢占应用的执行 改进 TaskManger，提供任务调度功能，可以在收到时钟中断后统计任务的使用时间片，如果任务的时间片用完后，则切换任务 多道程序的放置与加载 每个应用都按照它的编号被分别放置并加载到内存中的不同位置，因为是一次性全部加载的，所以在切换到另一个应用执行时会很快，不需要清空前一个应用然后在加载当前应用的开销。\n多道程序放置 调整每个用户应用程序构建时的链接脚本linker.ld中的起始地址BASE_ADDRESS,这个地址就是应用被内核加载到内存中的起始地址，所以每个应用也知道自己会被加载到某个地址运行 比如说第一个应用的地址范围是BASE_ADDRESS ～ BASE_ADDRESS+APP_LIMIT,第二个应用的地址范围是BASE_ADDRESS+APP_LIMIT~BASE_ADDRESS+2 * APP_LIMIT。 可以看出这就是另一种形式的硬编码，与每次复制应用程序到BASE_ADDRESS而言没什么区别 这么做的原因是因为操作系统的能力还比较弱，目前应用程序的编址方式是基于绝对位置的，并没做到与位置无关，内核也没有提供相应的地址重定位机制 import os base_address = 0x80400000 step = 0x20000 linker = \u0026#39;src/linker.ld\u0026#39; app_id = 0 apps = os.listdir(\u0026#39;src/bin\u0026#39;) apps.sort() for app in apps: app = app[:app.find(\u0026#39;.\u0026#39;)] lines = [] lines_before = [] with open(linker, \u0026#39;r\u0026#39;) as f: for line in f.readlines(): lines_before.append(line) // 替换初始的base_address 到每个应用具体的内存地址 line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, \u0026#39;w+\u0026#39;) as f: f.writelines(lines) // 编译应用程序 os.system(\u0026#39;cargo build --bin %s --release\u0026#39; % app) print(\u0026#39;[build.py] application %s start with address %s\u0026#39; %(app, hex(base_address+step*app_id))) // 还原到初始的base_address with open(linker, \u0026#39;w+\u0026#39;) as f: f.writelines(lines_before) app_id = app_id + 1 多道程序的加载 前面一个操作系统的所有应用都是使用同一个固定的加载物理地址，所以内存中最多只能驻留一个应用，只要当它运行完毕或运行出错时才由操作系统加载一个新的应用来替换它。\n但是我们要实现所有的应用在内核初始化的时候就一起加载到内存中。为了防止覆盖，所以要加载到不同的物理地址上:\n/// Load nth user app at /// [APP_BASE_ADDRESS + n * APP_SIZE_LIMIT, APP_BASE_ADDRESS + (n+1) * APP_SIZE_LIMIT). pub fn load_apps() { extern \u0026#34;C\u0026#34; { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\u0026#34;fence.i\u0026#34;); } // load apps for i in 0..num_app { // 计算方式同放置时一样 let base_i = get_base_i(i); // clear region (base_i..base_i + APP_SIZE_LIMIT) .for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // load app from data section to memory let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; dst.copy_from_slice(src); } } .align 3 .section .data .global _num_app _num_app: .quad 4 s .quad app_0_start .quad app_1_start .quad app_2_start .quad app_3_start .quad app_3_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/00power_3.bin\u0026#34; app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/01power_5.bin\u0026#34; app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/02power_7.bin\u0026#34; app_2_end: .section .data .global app_3_start .global app_3_end app_3_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/03sleep.bin\u0026#34; app_3_end: 执行应用程序 当应用程序的初始化放置完成后，或者某个应用程序结束或出错时就要调用run_next_app运行下一个程序。\n此时 CPU 是 S 模式，而要切换到 U 模式下运行。这一过程与\u0026nbsp;执行应用程序 类似。不同的是操作系统知道每个应用程序预先加载在内存中的位置，这就需要设置应用程序返回不同 Trap 上下文(保存了 放置程序起始地址的epc寄存器内容)：\n跳转到应用程序(i)的入口点 entryi 切换到用户栈 stacki 这样的一个支持把多个应用的代码和数据放置到内存中，并能够依次执行每个应用的操作系统就完成了，但是它的任务调度的灵活性还有很大改进空间。\n任务切换 上面这这个操作系统还是一个应用会一直占用 CPU 直到它结束或者出错。为了提高效率，我们需要介绍新的概率: 任务、任务切换、任务上下文。\n首先我们把应用程序在不同时间段的执行过程分为两类：\n占用处理器执行有效任务的计算阶段 不必占用处理器的等待阶段(比如等待 I/O) 这些阶段就形成了一个\u0026quot;暂停~运行\u0026hellip;\u0026ldquo;组合的控制流或执行历史。\n任务 如果操作系统能在某个应用程序处于等待阶段的时候，把处理器转给另外一个处于计算阶段的应用程序，那么只要转换的开销不大，那么处理器的执行效率就会大大提高。\n这需要应用程序在运行途中能主动让出 CPU 的使用权，等到操作系统让它再次执行后，那它才能继续执行。\n我们把\n应用程序的一次执行过程称为一个任务 应用执行过程中的一个时间片段或空闲片段称为“计算任务片”或“空闲任务片” 当应用程序的所有任务片都完成后，应用程序的一次任务也就完成了。从一个程序的任务切换到另外一个程序的任务称为“任务切换”，为了确保切换后的任务能正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。\n一条控制流需要支持“暂停～继续”，就需要提供一种控制流切换的机制，而且需要保证程序执行的控制流被切换出去之前和切换回来之后，能够继续正确执行。这需要让程序执行的状态(上下文 context)，即在执行过程中同步变化额度资源(如寄存器，栈等)保持不变，或者变化在它的预期之内。不是所有的资源都需要保存，事实上只有那些对于程序接下来的正确执行仍然有用，且在它被切换出去的时候有被覆盖风险的那些资源才有被保持的价值。这些需要保存与恢复的资源称为任务上下文(task context)。\n不同类型的上下文与切换 在控制流切换的过程中，我们需要结合硬件机制和软件来实现保存和恢复任务上下文。任务的一次切换涉及到被换出和即将被换入的两条控制流(两个应用的不同任务)。前面介绍的两种上下文保存/恢复的例子：\nRISC-V 中的函数调用，为了支持嵌套函数调用，不仅需要硬件平台提供的跳转指令，同时还需要保存和恢复\u0026nbsp;函数调用上下文 (比如说返回地址—— ra 寄存器，比如说需要保存的寄存器—— s0~s10)。 在这个例子中，函数调用包含在普通控制流(与异常控制流相对)之类，且始终用一个固定的栈来保存执行的历史记录，因此函数调用并不涉及控制流的特权级切换。 但是我们依然可以看成调用者与被调用者两个执行过程的“切换” 在前面的特权级的笔记中涉及到了某种异常（Trap）控制流，即两条控制流的特权级切换,需要保存和恢复\u0026nbsp;系统调用(Trap)上下文 。为了让内核能够完全掌控应用的执行，且不会被应用破坏整个系统，就必须利用硬件提供的特权级机制，让应用和内核运行在不同的特权级。 应用程序与操作系统打交道的核心在于硬件提供的 Trap 机制，也就是在 U 运行的应用控制流和在 S 运行的 Trap 控制流(操作系统的陷入处理部分)之间的切换。Trap 控制流是 Trap 触发的一瞬间生成的，它几乎唯一的目标就是处理 Trap 并恢复到原应用控制流。Trap 控制流需要把 Trap 上下文(几乎所有的通用寄存器)保存在自己的内核栈上，可以回看\u0026nbsp;Trap 上下文的保存与恢复 。\n任务切换的设计与实现 现在要介绍的是一种与 Trap 不同的异常控制流,它们都是描述两条控制流之间的切换，如果将它和 Trap 切换进行比较，会有如下异同:\n与 Trap 切换不同，它不涉及特权级切换 与 Trap 切换不同，它的一部分是由编译器帮忙完成的 与 Trap 切换相同，它对应用是透明的 任务切换是来自两个不同应用在内核中的 Trap 控制流之间的切换。当一个应用 Trap 到 S 模式的操作系统内核中进一步处理(操作系统的 Trap 控制流)的时候，Trap 控制流会调用一个特殊的 __switch 函数：在 __switch 返回之后，将继续从调用该函数的位置继续向下执行，但是其中却隐藏者复杂的控制流切换过程：\n调用 __switch 之后直到它返回前，原 Trap 控制流 A 会被切换出去，CPU 会运行另一个应用在内核中的 Trap 控制流 B 然后在某个合适的时机，原 Trap 控制流 A 才会从某一条 Trap 控制流 C（很可能不是 B）切换回来继续执行并最终返回 __switch函数和一个普通的函数之间的核心差别就是它会换栈。\n当 Trap 控制流准备调用 __switch 函数使任务从运行状态进入暂停状态的时候，在调用之前，内核栈会保存应用执行状态的 Trap 上下文以及内核在对 Trap 处理过程中留下的调用栈信息。由于之后还需要恢复并继续执行，所以必须要保存 CPU 当前的某些寄存器(如下图第一阶段中的最下一部分)，这些就是任务上下文。这些任务上下文都被保存在 TaskManager 中，从内存布局来看就是 .data 段中。\n对于当前正在执行的任务的 Trap 控制流，我们用一个名为 current_task_cx_ptr 的变量来保存放置当前任务上下文的地址；而用 next_task_cx_ptr 的变量来保存放置下一个要执行任务的上下文的地址。利用 C 语言的引用来描述的话就是：\nTaskContext *current_task_cx_ptr = \u0026amp;tasks[current].task_cx; TaskContext *next_task_cx_ptr = \u0026amp;tasks[next].task_cx; switch 换栈 假设某次 __switch 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容：\n在 Trap 控制流 A 调用函数之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的(处于暂停状态) A 在 A 任务上下文空间中保存 CPU 当前寄存器的快照 读取 next_task_cx_ptr 指向的 B 任务上下文,恢复寄存器后，就做到了一个函数跨两条控制流执行： 通过换栈实现了控制流的切换 恢复 ra 恢复s0~s11 恢复 sp 上一步寄存器恢复完成后，可以看到通过恢复 sp 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。当 CPU 执行 ret 指令完成 __switch 函数返回后，任务 B 就可以从调用 __switch 的位置继续向下执行 这时候任务 A 处于暂停状态，而任务 B 恢复了上下文并处于运行状态。\n__switch 的实现 .altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # 阶段 1 # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # 阶段 2 保存 curr 寄存器 sp ra s0~s11 # save kernel stack of current task sd sp, 8(a0) # save ra \u0026amp; s0~s11 of current execution sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # 阶段 3 恢复 next 寄存器 # restore ra \u0026amp; s0~s11 of next execution ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task ld sp, 8(a1) # 阶段 4 ret 保存 ra 是记录 __switch 返回后跳转的位置(ret执行完毕后) s0~s11 是规定被调用者保存的寄存器 对应的 TaskContext 的代码:\npub struct TaskContext { ra: usize, sp: usize, s: [usize; 12], } // 在 rust 中调用 __switch global_asm!(include_str!(\u0026#34;switch.S\u0026#34;)); use super::TaskContext; extern \u0026#34;C\u0026#34; { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); } 多道程序与协作式调度 TIP 任务相关概念的扩展:\n任务运行状态: 任务从开始到结束执行过程中所处的不同运行状态，比如:未初始化、准备执行、正在执行、已推出 任务控制块： 管理程序的执行过程的任务上下文，控制程序的执行与暂停 任务相关系统调用： 应用程序和操作系统直接的接口，用于程序主动暂停 sys_yield 和主动退出 sys_exit 多道程序背景与 yield 系统调用 我们知道 CPU 的处理速度远快于外设的 I/O 的，只有当 I/O 响应之后 CPU 才能继续计算。那么这是如何实现的？\n通常外设会提供一个可读的寄存器记录它目前的工作状态，于是 CPU 需要不断原地循环读取它直到它的结果显示设备已经将请求处理完毕了，才能继续执行（这就是 忙等 的含义）。\n而如果经常让 CPU 忙等的话，效率肯定是不符合预期的。多道程序是如何优化呢？\n内核管理多个应用程序 如果 I/O 的时间很常，可以切换任务去处理其他应用 在某次切换回来时去读取设备寄存器，如果已经返回则继续执行 这样，只要同时存在的应用够多，就能在一定程度上隐藏 I/O 处理的延迟 这种任务切换应该是应用程序主动调用 sys_yield 来实现的。 紫色是外设开始处理 I/O,蓝色和绿色的两个应用程序分别占用 CPU 的时间 任务控制块与任务运行状态 在引入了任务切换机制后，内核需要管理多个未完成的应用，而且我们不能对应用完成的顺序做任何假定。所以我们必须维护任务的运行状态:\npub enum TaskStatus{ UnInit, // 未初始化 Ready, // 准备运行 Running,// 正在运行 Exited, // 已退出 } 内核还需要一个保存应用的更多信息，将它们保存在 任务控制快 中:\npub struct TskControlBlock{ pub task_status: TaskStatus, pub task_cx: TaskContext, // 任务上下文，内有ra,sp,s0~s11等寄存器 } 任务管理器 一个全局的管理器，包含了所有要执行的任务\npub struct TaskManager { num_app: usize, // 任务管理器管理的应用数目 inner: UPSafeCell\u0026lt;TaskManagerInner\u0026gt;, } struct TaskManagerInner { tasks: [TaskControlBlock; MAX_APP_NUM], current_task: usize, // 正在执行的应用编号 } 我们可重用并扩展之前初始化 TaskManager 的全局实例 TASK_MANAGER ：\n每个应用的上下文(TaskContext)的 ra 都默认是 __restore init_app_cx 为每个应用的内核栈都构建一个 TrapContext，且设置 sepc( Trap 返回后继续执行的位置) 的值为每个 App 的入口 初始全局 TaskManger代码 lazy_static! { /// Global variable: TASK_MANAGER pub static ref TASK_MANAGER: TaskManager = { let num_app = get_num_app(); let mut tasks = [TaskControlBlock { task_cx: TaskContext::zero_init(), task_status: TaskStatus::UnInit, }; MAX_APP_NUM]; for (i, task) in tasks.iter_mut().enumerate() { task.task_cx = TaskContext::goto_restore(init_app_cx(i)); task.task_status = TaskStatus::Ready; } TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, }) }, } }; } sys_yield 和 sys_exit 的实现 sys_yield 与 sys_exit 的第一步就是更改当前任务的状态 sys_yield -\u0026gt; Ready sys_exit -\u0026gt; Exited 第二步都是运行下一个任务 self.find_next_task() 找到下一个状态处于 Ready 的应用 ID 更改为 Running 状态 更新 current_task 根据 current 和 next 进行换栈，也就是调用 __switch /// Switch current `Running` task to the task we have found, /// or there is no `Ready` task and we can exit with all applications completed fn run_next_task(\u0026amp;self) { if let Some(next) = self.find_next_task() { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[next].task_status = TaskStatus::Running; inner.current_task = next; let current_task_cx_ptr = \u0026amp;mut inner.tasks[current].task_cx as *mut TaskContext; let next_task_cx_ptr = \u0026amp;inner.tasks[next].task_cx as *const TaskContext; drop(inner); // before this, we should drop local variables that must be dropped manually unsafe { __switch(current_task_cx_ptr, next_task_cx_ptr); } // go back to user mode } else { println!(\u0026#34;All applications completed!\u0026#34;); use crate::board::QEMUExit; crate::board::QEMU_EXIT_HANDLE.exit_success(); } } } 应用的运行状态变化 第一次进入用户态 第一次运行应用程序，调用 __switch 函数是用一个默认的 TaskContext 与 task.0 ,进行换栈 每个应用程序的 TaskContext 的 ra 都默认是 __restore, 且都压入了一个默认的 TrapContext,这个 TrapContect 的 sepc 设置的值为每个应用程序的入口。即： 第一次运行时，调用 __switch，换入 task.0 这时候 ra 会被设置为 __restore 的地址 返回后进入 __restore 的处理流程 由于sret 会跳转到 sepc 的地址，即 task.0 的入口 在运行 __restore 的过程中，特权级会被切换到用户态 这里也只是一个简单的协作式操作系统，需要每个应用显示的调用 yeild 才能共享 CPU。\n分时多任务系统与抢占式调度 对 任务 的概念进行进一步扩展和延伸：\n分时多任务： 操作系统管理每个应用程序，以时间片为单位来分时占用处理器运行应用 时间片轮转调度： 操作系统在一个程序用完其时间片后，就抢占当前程序并调用下一个程序执行，周而复始，形成对应用程序在任务级别上的时间片轮转调度 TIP 抢占式调度是应用程序 随时 都有被内核切换出去的可能。现代的任务调度算法基本都是抢占式的，它要求每个应用只能连续执行一段时间(一般是以时间片作为应用连续执行时长的度量单位)，然后内核就会将它强制性切换出去。\n算法需要考虑：\n每次在换出之前给一个应用多少时间片去执行 要换入哪个应用 从以下角度来评价调度算法：\n性能(吞吐量和延迟) 吞吐量: 某个时间点将一组应用放进去，在固定时间内执行完毕的应用最多 公平性(多个应用分到的时间片占比不能过大) 这里使用时间片轮转算法进行调度：使用最原始的 RR 算法，维护一个任务队列，每次从队头去一个应用执行完一个时间片，然后丢入队尾，在继续去队头的应用执行。\nRISC-V 中的中断 时间片轮转调度的核心机制就在于计时，操作系统的计时功能是依靠硬件提供的时钟中断来实现的。而中断与 ecall 都是 Trap,但是中断是异步于当前的指令(即中断的原因与正在执行的指令无关)。\nRISC-V 的中断可以分成三类：\n软件中断 (Software Interrupt)：由软件控制发出的中断 时钟中断 (Timer Interrupt)：由时钟电路发出的中断 外部中断 (External Interrupt)：由外设发出的中断 在判断中断是否会被屏蔽的时候，有以下规则：\n如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽 中断产生后，硬件会完成如下事务：\n当中断发生时，sstatus.sie 字段会被保存在 sstatus.spie 字段中，同时把 sstatus.sie 字段置零，这样软件在进行后续的中断处理过程中，所有 S 特权级的中断都会被屏蔽 当软件执行中断处理完毕后，会执行 sret 指令返回到被中断打断的地方继续执行，硬件会把 sstatus.sie 字段恢复为 sstatus.spie 字段内的值 时钟中断与计时器 由于软件需要一种计时机制，RISC-V 要求处理器有一个内置时钟：\n频率一般低于 CPU 主频 还有一个计数器用来统计处理器自上电以来经过了多少个内置时钟的时钟周期 在 RISC-V 中一般保存在 64 位的 CSR mtime 中 还有一个 64 位的 CSR mtimecmp 的作用是：一旦计数器 mtime 的值超过了 mtimecmp，就会触发一次时钟中断。这使得我们可以方便的通过设置 mtimecmp 的值来决定下一次时钟中断何时触发 它们都是 M 级别的寄存器，只能通过 M 级别的 SEE 来访问(RustSBI) 相关代码 CLOCK_FREQ 是不同平台的时钟频率，单位是赫兹，也就是一秒钟之内计数器的增量 set_next_trigger 设置下一次打断的是时间 set_timer 就是设置寄存器 mtimecmp 的值 use crate::config::CLOCK_FREQ; use crate::sbi::set_timer; use riscv::register::time; const TICKS_PER_SEC: usize = 100; const MSEC_PER_SEC: usize = 1000; /// read the `mtime` registerpub fn get_time() -\u0026gt; usize { time::read() } /// get current time in milliseconds pub fn get_time_ms() -\u0026gt; usize { time::read() / (CLOCK_FREQ / MSEC_PER_SEC) } /// set the next timer interrupt pub fn set_next_trigger() { set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC); } 抢占式调度 在 trap_handler 放在中添加以下代码，即根据当原因是 S 级特权级时钟打断时，重新设置打断，并暂停当前应用然后运行下一个应用。\nmatch scause.cause() { Trap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { set_next_trigger(); suspend_current_and_run_next(); } } 然后添加一些初始化代码：\n#[no_mangle] pub fn rust_main() -\u0026gt; ! { // ... trap::enable_timer_interrupt(); // 设置 `sie.stie` 使得 S 特权级时钟中断不会被屏蔽 timer::set_next_trigger(); // 设置第一个 10ms 的计时器 // ... } 当第一个应用运行了 10ms 后，第一个 S 特权级时钟中断就会触发 由于应用运行在 U 特权级，且 sie 寄存器被正确设置，该中断不会被屏蔽，而是跳转到 S 特权级内的我们的 trap_handler 里面进行处理，并顺利切换到下一个应用 现在的操作系统已经支持：\n操作系统进行主动调度 程序可以主动出让时间片(sys_yield) 练习 1. 显示操作系统切换任务的过程 包装 __switch 函数，然后打印切换任务的 id\n/// switch 交换两个 task,替换执行流 pub fn switch__(current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext) { unsafe { let current = current_task_cx_ptr.as_ref().unwrap(); let next = next_task_cx_ptr.as_ref().unwrap(); debug!( \u0026#34;switch from {:?} to {:?}\u0026#34;, current.get_app_id(), next.get_app_id(), ); __switch(current_task_cx_ptr, next_task_cx_ptr); } } 2.统计每个应用执行后的完成时间：用户态完成时间和内核态完成时间 根据 user/src/lib.rs 中可得知，用户程序执行完毕后都会调用 syscall 这个系统调用 #[no_mangle] #[link_section = \u0026#34;.text.entry\u0026#34;] pub extern \u0026#34;C\u0026#34; fn _start() -\u0026gt; ! { clear_bss(); exit(main()); panic!(\u0026#34;unreachable after sys_exit!\u0026#34;); } 即操作系统处理这个 syscall 时就是用户态完成时间，处理完毕后就是内核态完成时间 调用 mark_current_exited 时是用户态结束时间 关于内核态结束时间 调用 __swich 后会执行 ret 指令直接运行下一个程序 想到一个简单的办法，在运行下一个程序的开头先调用一个自定义的 syscall: mark_prev_kernel_end 就可以标记上一个应用程序内核态完成时间 发现了 bug, 这里能成功运行是因为这几个程序在一个时钟周期就运行完毕了，但是如果程序的执行时间大于几个时间周期，而 mark_prev_kernel_end 只在第一次运行时设置，这样就有问题，因为 switch 回来后程序不是从头开始的 只能在汇编 ret 前加一个方法调用: // ... addi sp, sp, -8 sd ra, 0(sp) call mark_prev_kernel_end ld ra, 0(sp) addi sp, sp, 8 # return to next task ret 然后在应用程序的 main 结束后，调用标记用户态退出时间 DEBUG - Task 0 user end time: 99257,kernel end time 102332 | switch cost: 3075 DEBUG - Task 1 user end time: 123140,kernel end time 124516 | switch cost: 1376 DEBUG - Task 2 user end time: 149108,kernel end time 150363 | switch cost: 1255 DEBUG - Task 3 user end time: 37651703,kernel end time 37652583 | switch cost: 880 DEBUG - Task 4 user end time: 56401809,kernel end time 56402745 | switch cost: 936 3. 实现sys_task_info 根据任务 ID 查询任务信息，任务信息包括任务 ID、任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、任务总运行时长。\n思路比较简单:\n在操作系统分发处理的时候添加次数 在程序第一次运行时标记开始时间 如果任务已经结束则直接用当前时间减去开始时间 如果任务还在运行这用用户态结束时间减去开始时间 ","permalink":"https://fzdwx.github.io/document/2023-01-08-os-multi-programs/","summary":"记录如何实现一个简单的支持运行多个程序的操作系统，比如如何暂停和恢复应用程序(换栈)，以及如何实现一个抢占式操作系统。","title":"操作系统的分时多任务"},{"content":"应用程序会不可避免的出现错误，如果一个程序出现错误会导致其他程序或操作系统都无法运行那就是不可接受的。\n所以人们提出特权级（Privilege）这一保护计算机系统不受有意或无意出错的程序破坏的机制，它让应用程序运行在用户态 ，而操作系统运行在内核态，并且实现用户态和内核态的隔离。\n一个支持顺序执行多个应用程序的操作系统结构图 主要通过 RustSBI 完成基本的硬件初始化后，跳转到操作系统的起始位置，操作系统然后建立栈空间并情况 bss 段（置0），然后通过 AppManager 从 app 列表中一次加载各个 app 到指定的内存在用户态执行。app 在执行时，会通过系统调用的方式得到操作系统提供的功能，比如输出字符串。\n特权级的软硬件协同设计 实现特权级机制的根本原因是应用程运行的安全性不可充分信任 。所以，计算机科学家和工程师想到了一个方法：让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受到程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。\n应用程序不能随意访问地址空间 应用程序不能执行某些可能破坏计算机系统的指令 同时为了应用程序能获得操作系统的服务——应用程序和操作系统还需要有交互的手段。\n低特权级的软件只能做高特权级允许它做的操作 超出低特权级能力的功能必须寻求高特权级的帮助 这样高特权级(操作系统)就成为低特权级（一般应用）的执行环境的总要组成部分。\n为了实现这样的特权级机制，需要进行软硬件协同设计。一种简介的方式是： 处理器设置两个不同安全等级的执行环境，用户态特权级的执行环境和内核态特权级的执行环境。\n明确指出可能破坏计算机系统的内核态特权指令集子集 规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行 处理器在执行指令前会进行特权级安全检查，如果在用户态环境中执行内核态特权级指令就会产生异常 传统的call和ret指令组合会直接绕过硬件的特权级保护检查，所以需要新的指令：\necall： 执行环境调用，具有用户态到内核态的执行环境切换能力的函数调用指令 从当前特权级切换到比当前高一级 eret： 执行环境返回，基友内核态到用户态的执行环境切换能力的函数返回指令 切换到不高于当前特权级 硬件有了这样的机制之后，还需要操作系统的配合才能完成对操作系统自身的保护。\n操作系统需要提供能在执行eret前准备和恢复用户态执行应用程序的上下文 在用户程序调用ecall后能检查应用程序的系统调用参数，确保参数不会破坏操作系统 RISC-V 特权级架构 级别 编码 名称 0 00 用户/应用模式 (U,User/Application) 1 01 监督模式 (S,Supervisor) 2 10 虚拟监督模式 (H,Hypervisor) 3 11 机器模式 (M,Machine) 级别数值越大则特权级越高，掌控硬件的能力越强。即 M 最强，U 最弱，在 CPU 层面只有 M 是必须的。\n在特权级架构的角度看待一套支持应用程序运行的执行环境 白色表示执行环境，黑色表示相邻两层执行环境之间的接口。SSE 代表监督模式执行环境，例如 RustSBI。\n按需实现 RISC-V 特权级：\n简单的嵌入式应用只需实现 M 带有一定保护能力的嵌入式系统需要实现 M、U 复杂的多任务系统需要实现 M、S、U 操作系统异常控制流 中断： 由外部设备引起的外部 I/O 时间如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。 异常： 处理器执行指令期间检测到不正常的或非法的内部事件(如除零、数组越界等) 陷入: 程序在执行过程中通过系统调用请求操作系统服务时而有意引发的事件 要处理上面的异常，都需要操作系统保存与恢复被 打断/陷入 前应用程序的控制流上下文。\nTIP 控制流上下文： 确保下一刻能继续正确执行控制流指令的物理资源，也可称为控制流所在执行环境的状态。\n这里的物理资源即计算机硬件资源，如 CPU 的寄存器、内存等。\n执行环境的另一种功能是对上层软件的执行进行监管管理： 当上层软件执行出现了异常或特殊情况，导致需要用到执行环境 中提供的功能，因此需要暂停上层软件的执行，转而运行执行环境的代码。\n而上层软件和执行环境的特权等级往往不同，所以这个过程可能(大部分情况下)会有 CPU 的特权级切换。当执行环境 的代码运行结束后，我们就需要回到上层软件暂停的位置继续执行。在 RISC-V 中，这种异常控制流被称为异常，是 RISC-V 中的 trap 的一种。\n用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：\n用户态软件为获得内核态操作系统的服务功能而执行特殊指令 在执行某条指令出现了错误(如执行了用户态不允许执行的指令)并被 CPU 检测到 interrupt exception code description 0 0 Instruction address misaligned 0 1 Instruction access fault 0 2 Illegal instruction 0 3 Breakpoint 0 4 Load address misaligned 0 5 Load access fault 0 6 Store/AMO address misaligned 0 7 Store/AMO access fault 0 8 Environment call from U-mode 0 9 Environment call from S-mode 0 11 Environment call from M-mode 0 12 Instruction page fault 0 13 Load page fault 0 15 Store/AMO page fault 其中 Breakpoint 和 Environment call 两种异常指令称为 陷入 或 trap 类指令。通过在上层软件中执行一条特定的指令触发的：\n执行 ebreak 指令就会触发 Breakpoint 异常 执行 ecall 指令就会根据 CPU 当前所处的特权级而触发不同的异常(8/9/11) ecall 这是一种特殊的陷入类指令，相邻的两特权级软件之间的接口正是通过这种陷入机制实现的。M 模式软件 SEE 和 S 模式的内核之间的接口被称为监督模式二进制接口(Supervisor Binary interface, SBI)，而内核和 U 模式的应用程序之间的接口被称为应用程序二进制接口(Application Binary interface, ABI)——系统调用(syscall)。\n而为什么叫二进制接口，是因为它是机器/汇编指令级的接口(没有针对某种特定的高级语言编写的内部调用接口)，而且不是普通的函数调用控制流，而是陷入异常控制流，会切换 CPU 特权级。所以只有机器/汇编级别才能满足跨语言的通用和灵活性。\n在软件(应用，操作系统)执行过程中经常能看到特权级切换 总之出现:\n执行某一指令发生了某种错误(如除零、无效地址访问、无效指令等) 执行了高特权级指令 访问了不应该方法的高特权级的资源 就需要将控制权移交给高特权级的软件来处理。当错误/异常恢复后，则重新回到低特权级的软件中执行，如果错误不能恢复，那么高特权级软件有权限杀死和清除低特权级软件。\nRISC-V 的S级特权指令 在 RISC-V 中有两类属于 S 模式的特权指令\n指令本身属于高特权级，如 sret(从 S 模式返回 U 模式) 访问的 S 模式下才能访问的寄存器或内存 sstatus: SPP 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 spec: 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 scause: 描述 Trap 的原因 stval: 给出 Trap 附加信息 stvec: 控制 Trap 处理代码的入口地址 特权级切换 当执行到一条 trap 类指令时(如ecall)，CPU 发现触发了一个异常并需要进行特殊处理，这涉及到执行环境切换，就是：\n用户态的执行环境中的应用程序通过调用ecall指令来向内核态的执行环境中的操作系统来请求某项服务 这时候 CPU 和操作系统就会完成用户态到内核态的执行环境切换 并在操作系统完成服务后再次切换回用户态执行环境 然后应用程序就会紧接着ecall指令的后一条继续执行 在切换回来之后需要从发出 syscall 的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。\n应用程序的上下文包括通用寄存器和栈两个主要部分。而 CPU 在不同特权级下共享一套通用寄存器，所以操作系统在处理 trap 的过程中也会使用到这些寄存器，就会改变应用程序的上下文。所以同函数调用一样，在执行操作系统的 trap 处理过程之前我们需要在某个地方(某内存块或内核的栈)保存这些寄存器并在 trap 处理结束之后恢复这些寄存器。\n同时还有一些在 S 模式下专用的寄存器，也需要保证它们的变化在预期之内。\nTIP 执行环境： 主要负责给在其上执行的软件提供相应的功能与资源，并可在计算机系统中形成多层次的执行环境。\n比如之间运行在裸机硬件上的操作系统，其执行环境就是 计算机的硬件 后面就出现了在应用程序下面有了一层比较通用的函数库，这使得程序不用直接访问硬件了。所以应用程序的执行环境就是 函数库 -\u0026gt; 计算机硬件 在后来，操作系统取代了函数库来访问硬件。 函数库 -\u0026gt; 操作系统 -\u0026gt; 计算机硬件 特权级切换的硬件控制机制 当 CPU 执行完一条指令(如ecall)并准备从 U 陷入到 S 时，硬件会完成：\nsstatus的SPP会被修改为 CPU 当前的特权级(U/S) sepc会被修改为 trap 处理完成后默认会执行的下一条指令的地址 scause/stval分别会被修改为这次 trap 的原因以及相关的附加信息 CPU 会跳转到 stvec 所设置的 trap 处理入口地址，并将当前特权级设置为 S,并从 trap 处理入口开始执行 stvec保存了中断处理的入口地址 它后两个字段: MODE 1~0, 2 bits BASE 63~2, 62 bits 当 MODE 为 0 时，stvec是 direct 模式，trap 的入口地址固定为 BASE\u0026lt;\u0026lt;2 当 CPU 完成 trap 处理准备返回时，需要通过sret来完成:\nCPU 会将当前的特权级按照sstatus的SPP字段设置为 U/S CPU 会跳转到sepc指向的指令并继续执行 用户栈和内核栈 当 trap 触发的一瞬间，CPU 就会切换到 S 特权级并跳转到stvec设置的位置，但是在正式进入 S 特权级的处理之前，我们必须保存原控制流的寄存器状态，这一般是通过内核栈来保存的。这是专门为操作系统准备的内核栈，而不是应用程序运行时的用户栈。\n使用两个栈主要是为了安全性:隔离数据，不让用户态的应用程序读取到内核态的操作系统的数据。\nTrap 管理 特权级切换的核心就是对 trap 的管理：\n应用程序通过ecall进入到内核状态时，操作系统需要保存被打断的应用程序的 trap 上下文 操作系统根据 CSR 寄存器(上述 S 模式下专有的寄存器)，完成系统调用服务的分发与处理 操作系统完成系统调用后，需要恢复被打断的应用程序的 trap 上下文，并通过sret让应用程序进行执行 #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } Trap 上下文的保存与恢复 在操作系统初始化时，我们通过修改stvec的值来指向 trap 处理入口点,即设置初始的stvec的值。\npub fn init() { extern \u0026#34;C\u0026#34; { fn __alltraps(); } unsafe { // 默认为 BASE 为 __alltraps，MODE 为 direct stvec::write(__alltraps as usize, TrapMode::Direct); } } trap 的处理流程如下：\n通过__alltraps将 trap 上下文保存在内核栈上，然后跳转到 trap_handler 函数完成 trap 分发及处理 当 trap_handler返回之后，使用__restore从保存在内核栈上的 trap 上下文恢复寄存器 最后通过sret指令回到应用程序执行 __alltraps: # csrrw rd csr rs =\u0026gt; rd = csr, csr = rs # sp = sscratch, sscratch = sp, 交换 sscratch 与 sp # sp 指向用户栈，sscratch 指向内核栈 # 交换后 sp 指向内核栈，sscratch 指向用户栈 csrrw sp, sscratch, sp # now sp-\u0026gt;kernel stack, sscratch-\u0026gt;user stack # allocate a TrapContext on kernel stack # 预分配 34 * 8 的栈帧 addi sp, sp, -34*8 # save general-purpose registers # 保存 x0 ~ x31 跳过 x0(zero),x2(sp),x4(tp) sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack # t0 = sstatus csrr t0, sstatus # t1 = spec csrr t1, sepc # 32*8 = t0 sd t0, 32*8(sp) # 33*8 = t1 sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack # 2*8 = sscratch csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: \u0026amp;mut TrapContext) # a0 = 内核栈 mv a0, sp call trap_handler 当trap_handler返回之后会从trap_handler的下一条指令开始执行，也就是__restore:\n__restore: # case1: start running app by __restore # case2: back to U after handling trap mv sp, a0 # now sp-\u0026gt;kernel stack(after allocated), sscratch-\u0026gt;user stack # restore sstatus/sepc # 恢复在 __alltraps 保存的 ld t0, 32*8(sp) # sstatus ld t1, 33*8(sp) # spec ld t2, 2*8(sp) # sscratch csrw sstatus, t0 csrw sepc, t1 # 设置为用户栈 csrw sscratch, t2 # 恢复 x0 ~ x31 寄存器 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack # 释放栈帧 addi sp, sp, 34*8 # now sp-\u0026gt;kernel stack, sscratch-\u0026gt;user stack csrrw sp, sscratch, sp # 返回到用户程序继续执行 sret TIP sscratch这个寄存器它：\n保存了内核栈的地址 作为一个中转站让sp（执行用户栈的地址）暂存在sscratch中 通过csrrw sp, sscratch, sp这一条指令就完成内核栈与用户栈的相互交换\nTrap 分发与处理 根据scause的cause进行分发处理 如果是UserEnvCall 则设置sepc为下一条指令 调用 syscall 如果出现错误则直接运行下一个应用程序 如果是不支持的 trap 则直接抛出异常 #[no_mangle] /// handle an interrupt, exception, or system call from user space pub fn trap_handler(cx: \u0026amp;mut TrapContext) -\u0026gt; \u0026amp;mut TrapContext { let scause = scause::read(); // get trap cause let stval = stval::read(); // get extra value match scause.cause() { Trap::Exception(Exception::UserEnvCall) =\u0026gt; { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) =\u0026gt; { println!(\u0026#34;[kernel] PageFault in application, kernel killed it.\u0026#34;); run_next_app(); } Trap::Exception(Exception::IllegalInstruction) =\u0026gt; { println!(\u0026#34;[kernel] IllegalInstruction in application, kernel killed it.\u0026#34;); run_next_app(); } _ =\u0026gt; { panic!( \u0026#34;Unsupported trap {:?}, stval = {:#x}!\u0026#34;, scause.cause(), stval ); } } cx } 执行应用程序 当操作系统初始化完成或某个应用形成运行结束或失败时，就调用run_next_app运行下一个应用程序。此时是 S 模式而要切换到 U 模式，所以切换流程:\n构造应用程序开执行所需的 trap 上下文 通过__restore函数，从 trap 上下文中恢复应用程序执行所需的寄存器 设置sepc的值为0x80400000(固定为这个值，后续会把每个应用程序加载到这个地址) 切换scratch和sp，将sp指向应用程序用户栈 执行sret切换 S =\u0026gt; U /// init app context pub fn app_init_context(entry: usize, sp: usize) -\u0026gt; Self { let mut sstatus = sstatus::read(); // CSR sstatus sstatus.set_spp(SPP::User); //previous privilege mode: user mode let mut cx = Self { x: [0; 32], sstatus, sepc: entry, // entry point of app }; cx.set_sp(sp); // app\u0026#39;s user stack pointer cx // return initial Trap Context of app } /// run next app pub fn run_next_app() -\u0026gt; ! { /// ... extern \u0026#34;C\u0026#34; { fn __restore(cx_addr: usize); } // 在内核栈上压入一个 trap 上下文,它在栈顶,所以是 __restore 的参数 // 即 a0 = 内核栈顶 // 所以会有 `mv sp a0` 这一句, // sepc 的值为固定的程序入口 // 根据`__restore`函数，如果是第一次调用，那么`sscratch`是什么时候设置为用户栈的？ // 根据`mv sp a0`那么则 sp = a0 = trapContext // 在`app_init_context`的实现中有`cx.set_sp(sp)`这一句即x[2] = sp = 用户栈 // 在`__restore`中有`ld t2, 2*8(sp)`与`csrw sscratch, t2`就完成了设置 unsafe { __restore(KERNEL_STACK.push_context(TrapContext::app_init_context( APP_BASE_ADDRESS, USER_STACK.get_sp(), )) as *const _ as usize); } panic!(\u0026#34;Unreachable in batch::run_current_app!\u0026#34;); } ","permalink":"https://fzdwx.github.io/document/2022-12-30-os-privilege/","summary":"特权级是为了隔离操作系统中用户程序与操作系统的，主要是防止用户程序的错误不会导致操作系统的一种机制。","title":"操作系统的特权级机制"},{"content":" 操作系统是最早的并发程序之一。\n开始，我们肯定要理解什么是并发和并行以及它们的区别。\n并行： 可以同时处理多个任务。 并发： 可以执行多个任务，但是同时只能执行一个任务，会在它们之间进行切换。 如果一个操作系统要支持并发，那么以下的哪些部分需要复制多份？ 全局变量 堆内存m 函数调用栈 答案显而易见的是 函数调用栈 并发编程为什么难？\n所有线程都共享一个堆内存 单个线程的状态机的执行结果是固定的，但是多线程不一样，因为它们涉及到一个线程切换的问题，这会导致每次程序运行的结果可能都是不一样的。 多线程状态机执行示意图 无法保证的三个特性 原子性: 一段代码执行时独占整个计算机系统 无法保证的例子： 两个线程对一个值进行 ++ N 次， 这个结果可能不是 2N 实现原子性： lock \u0026amp; unlock 实现临界去的绝对串行化 其他部分仍然可以并行执行 顺序性: 代码按编写的顺序执行，也就是实现源代码的按顺序翻译(为汇编)。 会导致的原因: 编译器的优化(编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。)，比如说 gcc 加-O1/2 实际例子： while(!done); // =\u0026gt; opt if (!done) while(1); 实现源代码的按顺序翻译： 在代码中插入“优化不能穿越的” barrier asm volatile (\u0026quot;\u0026quot; ::: \u0026ldquo;memory\u0026rdquo;); 含义是 可以读写任何内存 使用 volatile 变量 保持 c 语义和汇编语义一致 extern int volatile done; while(!done); 可见性： 对某个共享内存的修改，其他线程要立马可见。 一段代码: 它的结果可能为: 0,0 0,1 1,0 1,1 4种情况, 但是只要有方法(f1 / f2)被执行就不会出现0,0这种结果。但实际的情况是0,0这个结果出现的次数最多。 int x = 0, y= 0; void f1(){ x = 1;一个操 asm volatile(\u0026#34;\u0026#34;:::\u0026#34;memory\u0026#34;); printf(\u0026#34;%d \u0026#34;,y) } void f2(){ y = 1; asm volatile(\u0026#34;\u0026#34;:::\u0026#34;memory\u0026#34;); printf(\u0026#34;%d \u0026#34;,x) } 原因是：现代处理器也是一个动态编译器。单个处理器把汇编（用电路）编译成更小的操作符。 在任何时刻，处理器都维护了一个操作符的容器 每一周期尽可能多的补充操作符 每一周期执行尽可能多的操作符 乱序执行，按序提交 实现顺序一致性： 使用mfence指令或使用原子指令(lock),让它每次都到内存中去读取，而不读取缓存 自旋锁 spin lock 假如硬件能提供一条“瞬间完成” 的读 + 写的指令\n其他所有人暂停，load + store 如果有人同时请求，硬件选出一个胜利者 败者等胜利者完成后继续 X86提供的 lock 前缀 long sum = 0; void sum(){ for(;;){ asm volatile(\u0026#34;lock addq $1, %0\u0026#34;: \u0026#34;+m\u0026#34;(sum)); } } atomic exchange(load + store)\nint xchg(volatile int *addr, int newval) { int result; asm volatile (\u0026#34;lock xchg %0, %1\u0026#34; : \u0026#34;+m\u0026#34;(*addr), \u0026#34;=a\u0026#34;(result) : \u0026#34;1\u0026#34;(newval)); return result; } 实现自旋锁:\nint locked = 0; void lock() { while (xchg(\u0026amp;locked, 1)) ; } void unlock() { xchg(\u0026amp;locked, 0); } lock 指令的现代实现 在 L1 cache 层保持一致性\n所有 cpu 的L1缓存都用总线连起来 对某个内存 M 执行 lock，则其他所有缓存的 M 都无效（这个代价非常大） RISC-V 的原子操作 原子操作的目的：\na = load(x); if (a == xx){ store(x,y) } a = load(x); store(x,y) a = load(x); a++; store(x,a) 它们的本质都是 load -\u0026gt; exec(进行运算) -\u0026gt; store\nLoad reserved / Store Conditional LR: 在读取时会对这个内存加上一个标记，中断、其他处理器的写入都会导致标记消除\nlr.w rd (rs1) rd = M[rs1] reserve M[rs1] SC: 如果那片内存还存在标记则继续写入\nsc.w rd rs2 (rs1) if still reserved: M[rs1] = rs2 rd = 0 else: rd = nonzero 实现 cas int cas(int *addr, int cmp_val, int new_val){ int old_val = *addr; if (old_val == cmp_val){ *addr = new_val; return 0; }else{ return 1; } } cas: lr.w t0 (a0) bne t0 a1 fail sc.w t0 a2 (a0) bnez t0 cas li a0 0 jr ra fail: li a0 1 ja ra 线程同步 ","permalink":"https://fzdwx.github.io/document/2022-12-16-os-concurrent/","summary":"从操作系统的层面讲要支持并发需要哪些条件","title":"操作系统的并发编程"},{"content":"Resource \u0026nbsp;RISC-V Green Card \u0026nbsp;RISC-V Call convertion \u0026nbsp;P\u0026amp;H(RISC-V) 在汇编语言中没有变量这个概念，汇编语言通常操作的是寄存器。算术指令的操作数必须取自寄存器，内建于硬件的特殊位置(CPU内？)。\nTIP 寄存器（Register）是\u0026nbsp;中央处理器 内用来暂存指令、\u0026nbsp;数据 和\u0026nbsp;地址 的\u0026nbsp;电脑存储器 。寄存器的存贮容量有限，读写速度非常快。在\u0026nbsp;计算机体系结构 里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速\u0026nbsp;计算机程序 的执行。 RISC-V Card RISC-V 操作数 如果寄存器的大小是 64位 则称为双字，32位 则是单字。 x0 被硬连接到 0 add x3, x4, x0 =\u0026gt; x3 = x4 (x0 is hard-wired to value 0) 汇编指令 存储操作数 TIP 将数据从内存复制到寄存器的数据传输指令称为 载入指令(load)。在 RISC-V 中指令是 ld,表示取双字。 一个从数组中取值的C程序，写出汇编代码 g = h + A[8]; A 是一个 100 个双字组成的数组，g, h分别存储在 x20, x21 中，数组起始地址或基址位于 x22 中。\nld x9, 8(x22) // x9 = A[8] add x21, x20, x9; // x21 = x20 + x9 存放基址的寄存器(x22)被称为基址寄存器, 数据传输指令中的 8 称为偏移量。\n实际的RISC-V内存地址和内存中双字的内容。 双字地址是 8 的倍数，同理单字地址是 4 的倍数 大端与小端编址 计算机分为两种，一种使用最左边或“大端”字节的地址作为双字地址，另一种使用最右端或“小端”字节的地址作为双字地址。\nRISC-V 使用小端 。由于仅在以双字形式和 8 个单独字节访问相同数据时，字节顺序才有影响，因此大多情况不需要关系“大小端”。\n所以为了上面的代码获得正确的字节地址加到 x22 这个寄存器的偏移量为 64（8x8）。\n与载入指令相反的指令通常被成为存储指令(store),从寄存器复制数据到内存。指令是sd,表示存储双字。\nTIP 在一些体系结构中，字的起始地址必须是 4 的倍数，双字的起始地址必须是 8 的倍数。该要求成为对齐限制 RISC-V 和 Intel x86 没有对齐限制，但 MIPS 有这个限制。\n使用 load 和 store 编译生成指令 A[12] = h + A[8]; h 存放在 x21 中，A 的基址存放在 x22 中。\nld x9, 64(x22) // x9 = A[8] add x9, x21, x9 // x9 = h + A[8] sd x9, 96(x22) // A[12] = x9 将字符串复制程序编译为汇编 void strcpy(char x[],char y[]){ size_t i; i = 0; while((x[i] = y[i]) != \u0026#39;\\0\u0026#39;){ i += 1; } } x, y 的基址存放在 x10 和 x11 中， i 存放在 x19 中。\nstrcpy: addi sp, sp, -8 // 调整栈指针，以存放一个item(x19) sd x19, 0(sp) // x19 入栈 add x19, x0, x0 // x19 = 0 + 0 L1: add x5, x19, x11 // x5 = x19 + x11 =\u0026gt; address of y[i] in x5 lbu x6, 0(x5) // temp: x6 = y[i] add x7, x19, x10 // x5 = x19 + x11 =\u0026gt; address of x[i] in x7 sd x6, 0(x7) // x[i] = y[i] beq x6, x0, L2 // if x6 ==0 then go to L2 addi x19, x19, 1 // i = i + 1 jal x0, L1 // go to L1 L2: ld x19, 0(sp) // 恢复 x19 以及栈指针 addi sp, sp, 8 jalr x0, 0(x1) 一段循环代码编译为汇编 int A[20]; int sum = 0; for (int 3i = 0; i \u0026lt; 20; i++){ sum += A[i]; } RISC-V 汇编（32 bit)\nadd x9, x8, x0 # x9 = \u0026amp;A[0] add x10, x0, x0 # sum add x11, x0, x0 # i addi x13,x0, 20 # 20 Loop: bge x11, x13, Done # if x11 \u0026gt; x13 go to Down(end loop) lw x12, 0(x9) # x12 = A[i] add x10, x10, x12 # sum addi x9, x9, 4 # x9 = \u0026amp;A[i+1] addi x11, x11, 1 # i++ j loop Done: 逻辑操作 and andi and x5, x6, x9 =\u0026gt; x5 = x6 \u0026amp; x9 addi x5, x6, 3 =\u0026gt; x5 = x6 \u0026amp; 3 sll ssli , 左移(扩大) slli x11, x23, 2 =\u0026gt; x11 = x23 \u0026laquo; 2 0000 0010 =\u0026gt; 2 0000 1000 =\u0026gt; 8 srl srli , 右移（缩小) srli x23, x11, 2 = \u0026gt; x23 = x11 \u0026raquo; 2 0000 1000 =\u0026gt; 8 0000 0010 =\u0026gt; 2 sra srai, 算数右移 1111 1111 1111 1111 1111 1111 1110 0111 = -25 srai x10, x10, 4 1111 1111 1111 1111 1111 1111 1111 1110 = -2 Helpful RISC-V Assmebler Features a0 - a7 是参数寄存器(x10 - x17，用于函数调用。 zero 代表 x0 mv rd, rs = addi rd, rs, 0 li rd, 13 = addi rd, x0, 13 nop = addi x0, x0 la a1 Lable 将 Label 的 地址 加载到 a1 a0 - a7(x10 - x17): 8 个寄存器用于参数传递以及两个返回值(a0 - a1) ra（x1）: 一个返回 address 的寄存器，用于返回原点（调用的位置） s0 - s1(x8 - x9) and s2 - s11 (s18 - x27): 保存的寄存器 RISC-V 函数调用的转换 寄存器比内存快，所以使用它们 jal rd, Label 跳转和链接 jal x1, 100 jalr rd, rs, imm 跳转和链接寄存器 jalr x1, 100(x5) jal Lable =\u0026gt; jal ra, Lable 调用函数 jalr s1 当 s1 是方法指针时，这就是一个函数调用 一段函数调用转换为汇编 ... sum(a,b); ... int sum(int x, int y){ retrun x + y; } 1000 mv a0, s0 # x = a 1004 mv a1, s1 # y= b 1008 addi ra, zero, 1016 # 1016 is sum function 1012 j # jump to sum 1016 ... ... 2000 sum: add a0, a0, a1 2004 jr ra 1008 ~ 1012 可以使用 jal sum 来替代、\n调用函数的基本步骤 把需要的参数放到方法可以访问的地方（寄存器） 转移控制权给函数,使用(jal) 保持地址，并跳转到函数的地址 获取函数执行所需的(local)存储资源 执行预期的函数 将返回值放在调用代码可以访问的地方，并恢复我们使用到的寄存器，释放本地存储 将控制器返回给主处理器（ret), 使用存储在寄存器中的地址，返回到调用它的地方 方法调用示例 int leaf(int g, int h, int i, int j){ int f; f = (g + h) - (i + j); retrun f; } g,h,i,j in a0,a1,a2,a3 f in s0 temp is s1 leaf: # prologue start addi sp, sp, -8 # 腾出 8byte 来存放的2个整数 sw s1, 4(sp) # 保存 s1, s0 到 sp 中 sw s0, 0(sp) # prologue end add s0, a0, a1 # f = g + h add s1, a2, a3 # temp = i + j sub a0, s0, s1 # a0 = （g + h) - (i + j) # epilogue lw s0, 0(sp) # 恢复 s1, s0 lw s1, 4(sp) addi sp, sp 8 jr ra sp TIP sp 是栈指针，从内存空间 的最顶部开始向下增长，在 RISC-V 中使用 x2 这个寄存器。\npush 是减少 sp 的指针地址 pop 是增加 每个函数都有一组存放在栈上的数据，它们是栈帧（stack frame ），栈帧通常包含：\n返回地址 参数 使用的局部变量的空间 嵌套函数调用 int sumSquare(int x,int y){ return mult(x,x) + y; } 在 ra 中有一个 sumSquare 想要跳回的值，但是这个值会被调用 mult 覆盖。\ncaller: 调用函数的人 calle： 被调用的函数 当被调用者从执行中返回时，调用者需要知道哪些寄存器可能发生了变化，哪些寄存器被保证是不变的。 寄存器规定： 即哪些寄存器在程序调用(jal) 后将被取消缓存 ，哪些可以被改变。 即有一些寄存器是易失的(temp),一些是要保存的（调用者需要恢复它们原来的值）。 这优化了每次进入栈帧的寄存器的数量 分类: 跨函数调用保留: sp, gp, tp s0 - s11 (s0 is also fp) 不保留: 参数寄存器以及返回寄存器： a0 - a7, ra temp 寄存器: t0 - t6 上面代码的 RISC-V\nx in a1, y in a1\nsumSquare: addi sp, sp -8 sw ra, 4(sp) // save retrun address to sp sw a1, 0(sp) // save s1 to y mv a1, a0 // y = x =\u0026gt; mult(x,x) jal mult // call mult lw a1, 0(sp) // get y from sp add a0, a0, a1 // mult() + y lw ra, 4(sp) // get retrun address from sp addi sp, sp, 8 jr ra RISC-V 寄存器名称 RISC-V 方法调用套路 matmul: # 压栈，腾出空间保存我们要使用的几个 s 寄存器 addi sp sp -36 sw ra 0(sp) sw s0 4(sp) sw s1 8(sp) sw s2 12(sp) sw s3 16(sp) sw s4 20(sp) sw s5 24(sp) sw s6 28(sp) sw s7 32(sp) body: # xxx xxx end: # 恢复寄存器的值 lw ra 0(sp) lw s0 4(sp) lw s1 8(sp) lw s2 12(sp) lw s3 16(sp) lw s4 20(sp) lw s5 24(sp) lw s6 28(sp) lw s7 32(sp) addi sp sp 36 ret RISC-V 指令二进制的表示 R 格式布局 用于算术和逻辑运算的指令\nopcode，funct3, funct7 : 将告诉我们是否要执行加，减，左移，异或等操作。 R-format 的 opcode 固定为 0110011 一个 add 操作： add x18 x19 x10 =\u0026gt; x18 = x19 + x10 0000000 01010 10011 000 10010 0110011 rs2 = x19, rs1 = x10, rd = x18 I 格式布局 处理立即数，比如addi rd rs1, imm =\u0026gt; addi a0 a0 1\nimm 的范围是 -2084 ～ 2047 addi x15 x1 -50 RISC-V Loads load 指令也是 I 类型的。\nlw x14 8(x2) S 格式布局 ","permalink":"https://fzdwx.github.io/posts/2022-12-10-risc-v/","summary":"RISC-V 是一种指令集(汇编语言)，是一种 low-level 的编程语言，高级语言通过编译器编译到汇编语言","title":"RISC-V 简介"},{"content":"表示方法 $$(-1)^{S}\\times(1.xxx\u0026hellip;x_{2}\\times2^{{yyy\u0026hellip;y}_{2}})$$ 指数表示Y,尾数表示X 单精度的表示方法 双精度的表示方法 公式:\n$$(-1)^{S}\\times{F}\\times{2^{E}}$$ F 是尾数表示的值，E 是指数表示的值，S 就对应数的符号位, 1 表示负数。 移码表示法 TIP 最理想的表示法是将最小的负指数表示为 00\u0026hellip;002， 将最大的正指数表示为 11\u0026hellip;112。从移码表示的数减去原数就可以得到相应的偏移值，从而由无符号的移码可得到真实的值。 IEEE 754规定:\n单精度的偏移值为 127 指数为 -1 表示 -1 + 12710 = 12610 = 011111102 +1 = 1 + 12710 = 12810 = 100000002 最大指数为127 最小为-126 双精度的指数偏移值为 1023 1023 -1022 带偏移值的指数意味着一个由浮点数表示的值实际上是:\n$$(-1)^{S}\\times{(1 + 有效位数)}\\times{2^{指数 - 偏移值}}$$ 表示 - 0.7510 分数表示为：\n(-3/4)10 = (-3/22)10 二进制小数表示:\n(-11/22)10 = -0.112 -11 右移 2 位 用科学计数法表示:\n-0.112 x 20 用规格化的科学计数法表示:\n-1.12 x 2-1 由上面的公式的到：\n$$(-1)^{S}\\times{(1 + 有效位数)}\\times{2^{指数 - 偏移值}}$$ 有效位数: 0.12 1 = (- 1)S =\u0026gt; S = 12 指数 - 127 = -1 =\u0026gt; 指数 = 12610 单精度可以表示:\n双精度表示:\n表示二进制浮点数为十进制浮点数 S = 1 有效位数: 0.012 =\u0026gt; 1 x 2-2（右移两位） = 0.25 指数: 129 根据公式:\n$$(-1)^{1}\\times{(1 + 0.25)}\\times{2^{129 - 127}}$$\n= $$-1\\times1.25\\times2^2$$\n= $$-1.25\\times4$$\n= $$-5$$\n浮点加法与浮点乘法可以看 P\u0026amp;H 3.5.4~3.5.5 \u0026nbsp;https://github.com/fzdwx/fzdwx.github.io/releases/download/v1.0/p.h.pdf RISC-V 中的浮点指令 算术 加法: fadd.s fadd.d fadd.s f0, f1, f2 =\u0026gt; f0 = f1 + f2 减法：fsub fsub fsub.s f0, f1, f2 =\u0026gt; f0 = f1 - f2 乘法: fmul fmul.s f0, f1, f2 =\u0026gt; f0 = f1 * f2 除法: fdiv fdivs f0, f1, f2 =\u0026gt; f0 = f1 / f2 平方根: fsqrt fsqrt.s f0, f1 =\u0026gt; $$f0 = \\sqrt{f1}$$ 比较 相等: feq feq.s x5, f0, f1 =\u0026gt; x5 = 1 if f0 == f1, else 0 小于: flt flt.s x5, f0, f1 =\u0026gt; x5 = 1 if f0 \u0026lt; f1, else 0 小于或等于: fle fle.s x5, f0, f1 =\u0026gt; x5 = 1 if f0 \u0026lt;= f1, else 0 如果比较结果为 真，则将整点寄存器设置 1,否则为 0 所以可以使用整数分支指令 beq 和 bne 来比较结果并进行分支 取存指令: 双：fld fsd fld f0, 8(x5) =\u0026gt; f0 = Memory[x5 + 8] fsd f0, 8(x5) =\u0026gt; Memory[x5 +8] = f0 单:flw fsw 浮点数据传输指令的基址寄存器仍为整点寄存器 在 RISC-V中有独立的浮点寄存器: f0 ~ f31 上述指令都有单双精度版本，单精度以 .s 结尾，双精度以 .d 结尾\n一个示例: 从内存中取出两个单精度数，相加，然后将总和存入内存中\nflw f0, 0(x10) // 加载一个 32bit 的数到 f0 flw f1, 4(x10) // 加载一个 32bit 的数到 f1 fadd.s f2, f0, f1 // f2 = f0 + f1 fsw f2, 8(x10) // 保存来自 f2 的 32bit 的数 TIP 独立浮点寄存器的好处: 在不需要增加指令位的情况下，可以获得倍增的寄存器数目，同时因为有独立的整点和浮点寄存器，可以获得倍增的寄存器带宽，并且还能为浮点定制寄存器。\n例如一些寄存器中所有类型的操作数转换为单一的内部格式。\n将一段 C 代码转换成 RISC-V 的的汇编代码 float f2c(float qwe){ retrun ((5.0f / 9.0f) * (qwe - 32.0f)); } 假设参数 qwe 传入到寄存器 f10 中，且结果也存入 f10中:\nf2c: flw f0, const5(x3) // f0 = 5.0f flw f1, const9(x3) // f1 = 9.0f fdiv.s f0, f0, f1 // f0 = 5.0f / 9.0f flw f1, const32(x3) // f1 = 32.0f fsub.s f10, f10, f1 // f10 = qwe - 32.0f fmul.s f10, f0, f10 // f10 = ((5.0f / 9.0f) * (qwe - 32.0f)); jalr x0, 0(x1) // retrun 假设通过 x3 访问上面3个常量浮点数\n将二维矩阵的C代码转换为RISC-V的汇编代码 $$C=C+A\\times{B}$$ 假设A, B, C都是 32 x 32 的二维矩阵\nvoid mm(double c[][], double a[][], double b[][]){ size_t i,j,k; for(i=0;i\u0026lt;32;i=i+1){ for(j=0;j\u0026lt;32;j=j+1){ for(k=0;k\u0026lt;32;k=k+1){ c[i][j] = c[i][j] + a[i][k] * b[k][j]; } } } } 方法参数分别存放在 x10, x11, x12; i, j, k 分别存放在x5, x6, x7。\nmm:... li x28, 32 // x28 = 32 li x5, 0 // i = 0; L1:\tli x6, 0 // j = 0; L2:\tli x7, 0 // k = 0; slli x30, x5, 5 // x30 = i * 2 ^ 5(size of row of c) add x30, x30, x6 // x30 = i * size(row) + j slli x30, x30, 3 // x30 = byte offset of [i][j] 8个字节,左移3位 add x30, x10, x30 // x30 = byte address of c[i][j] fld f0, 0(x30) // f0 = 8 bytes of c[i][j] L3: slli x29, x7, 5 // x29 = k * 2 ^ 5 add x29, x29, x6 slli x29, x29, 3 add x29, x12, x29 fld f1, 0(x29) // f1 = 8 bytes of b[k][j] slli x29,x5 5 // x29 = i * 2 ^ 5 add x29, x29, x7 slli x29, x29, 3 add x29, x11, x29 fld f2, 0(x29) // f2 = a[i][k] fmul.d f1, f2, f1 // f1 = a[i][k] * b[k][j] fadd.d f0, f0 ,f1 // f0 = c[i][j] + a[i][k] * b[k][j] addi x7, x7, 1 // k = k + 1 bltu x7, x28, L3 // if (k \u0026lt; 32) go to L3 fsd f0, 0(x30) // c[i][j] = f0 addi x6, x6, 1 // j = j + 1 bltu x6, x28, L2 // if (j \u0026lt; 32) go to L2 addi x5, x5, 1 // i = i + 1 bltu x5, x28, 1 // if (i \u0026lt; 32) go to L1 一些C语言和Java的数据类型、数据传输指令： 二进制浮点数表示图 ","permalink":"https://fzdwx.github.io/document/2022-12-09-float-rep/","summary":"简单介绍浮点数的几种表示方式以及 RISC-V 中相关的浮点寄存器","title":"浮点数在计算机中的表示"},{"content":"在这个项目中是用的图片来作为案例的，首先通过介绍了一种图片的编码形式, ppm:\n第一行表示是什么格式的 ppm 文件 第二行表示宽和高 第三行表示颜色范围 后面的就是各个像素的RGB值 P3 2 2 255 29 83 36 45 64 57 188 229 201 123 162 184 他是这么介绍的:\n我们将探索一种隐藏消息的方法。虽然大多数图像的每个 RGB 通道都有 8 位数据，但人眼无法轻易看出后 4 位的差异。因此，我们可以将信息隐藏在图像的底部位中。我们通过修改每个像素 B 值的最低有效位, 如果最后一位是 0，则把整个像素转换为黑色(255,255,255),如果最后一位是 1,则转换为白色(0,0,0)。\n关键就是： 每个 RGB 通道都有 8 位数据，但人眼无法轻易看出后 4 位的差异，所以这就给了我们操作的空间。\n","permalink":"https://fzdwx.github.io/posts/2022-12-07-steganography/","summary":"最近在跟 cs61c，第一个 project 中介绍了隐写术，大意可以理解为一个文件的内容是\u003ccode\u003e123\u003c/code\u003e,在经过特定的编码转换后成了\u003ccode\u003e456\u003c/code\u003e。","title":"隐写术"},{"content":" 前段时间玩过几天的 obsidian，由于太费神了所以转向了 hugo ,然后直接用文本编辑器写 md ，体验还是不太好，然后我想起还有 obsidian 这个软件，所以就有了这个插件。\n当前主要功能：\n开一个 custome iframe 预览 hugo (via \u0026nbsp;https://github.com/Ellpeck/ObsidianCustomFrames ) 后台启动 hugo server 当前还有一点问题，子进程( hugo 进程)在程序推出时不会关闭。 遇到的问题:\n获取 obsidian 打开的目录不知道 api( cwd ),后提 issue 知道了获取方法。 仓库: \u0026nbsp;https://github.com/fzdwx/hugo-preview-obsidian 运行图例，左编辑区域，右预览区域 更新 支持自定义 exec command, 例如可以用来启动终端。 使用 ALT+F12 唤起。 由于我使用 git 进行同步，时常需要打开终端并且进入到具体的目录，所以需要一个快速启动终端在当前的目录下的命令： wezterm start --class float --cwd ${cwd}。 目前只提供了 cwd 这个变量，它会替换为当前笔记的路径。 自定义 command 配置示例 ","permalink":"https://fzdwx.github.io/posts/2022-12-04-hugo-preview-obsidian/","summary":"前段时间玩过几天的 obsidian，由于太费神了所以转向了 hugo ,然后直接用文本编辑器写 md ，体验还是不太好，然后我想起还有 obsidian 这个软件，所以就有了这个插件。","title":"在 Obsidian 中预览 hugo "},{"content":" \u0026nbsp;《深入解析CSS》 \u0026nbsp;《计算机网络：自顶向下》 \u0026nbsp;《CSAPP》 \u0026nbsp;《图解HThe.C.Programming.Language.pdfTTP》 \u0026nbsp;《高性能MySQL》 \u0026nbsp;《计算机组成与设计：硬件_软件接口》(P\u0026amp;H) \u0026nbsp;《C程序设计语言》(K\u0026amp;R) \u0026nbsp;《Rust Atomics and Locks-Low-Level Concurrency in Practice》 \u0026nbsp;https://www.aliyundrive.com/s/AECNXPqn8WA dBeJ \u0026nbsp;https://xmsoushu.com/#/ \u0026nbsp;https://zlib.zu1k.com/ ","permalink":"https://fzdwx.github.io/notes/16/","summary":" \u0026nbsp;《深入解析CSS》 \u0026nbsp;《计算机网络：自顶向下》 \u0026nbsp;《CSAPP》 \u0026nbsp;《图解HThe.C.Programming.Language.pdfTTP》 \u0026nbsp;《高性能MySQL》 \u0026nbsp;《计算机组成与设计：硬件_软件接口》(P\u0026amp;H) \u0026nbsp;《C程序设计语言》(K\u0026amp;R) \u0026nbsp;《Rust Atomics and Locks-Low-Level Concurrency in Practice》 \u0026nbsp;https://www.aliyundrive.com/s/AECNXPqn8WA dBeJ \u0026nbsp;https://xmsoushu.com/#/ \u0026nbsp;https://zlib.zu1k.com/ ","title":"📑  书单"},{"content":" bit 可以表示任何事物\n例如表示26个字符: 5 bits(2^5 = 32)\nBinary,Decimal,Hex Decimal 十进制简单的介绍以及组成 Binary (to Decimal) 二进制的介绍以及转换到十进制 Hexadecimal (to Decimal) 十六至进制的介绍以及转换到十进制 Convert 进制转换\nConvert from Decimal to Binary 13转换到二进制 Convert from Decimal to Hexadecimal 165转换到十六进制 Convert Binary \u0026lt;\u0026ndash;\u0026gt; Hexadecimal 一张非常有用的对照图 Binary -\u0026gt; Hex 向左填充完整的4位数: 0b11110 -\u0026gt; ob00011110\n然后根据上图进行转换最后得到 1E Hex -\u0026gt; Binary 转换0xA87 -\u0026gt; 0b101010000111\nNumber Representation Overflow TIP 比如 add(or -,*,/)的结果不能由已经固定的 bit 表示则称为 overflow. 例如0b1010(10) + 0b0111(7) = 0b10001(17),这个结果就超过了 4 位数\n5 bits的无符号的 overflow 示意图，如果11111在加1就回到了00000，同样如果00000减去1回到11111，这两种情况都是overflow Negative Number TIP 正数前导为0,负数前导为1. N = 5 2N-1非负数 2N-1负数 1个0 1个符号位，4个有效的数字位 补码公式 可以同位数乘以2的幂来表示正数和负数 d31x-(231)+d30x-(230)+..+d2 x 22 + d1 x 21 + d0 x 20 1101 -\u0026gt; 1x-2^3+1x2^2+0x2^1+1x2^0=-8+4+0+1=-3 可以先翻转 bit 然后加1 1101 0010 0011 -\u0026gt; 1101 0011 1101 ","permalink":"https://fzdwx.github.io/document/2022-11-22-number/","summary":"bit 可以表示任何事物\n例如表示26个字符: 5 bits(2^5 = 32)\nBinary,Decimal,Hex Decimal 十进制简单的介绍以及组成 Binary (to Decimal) 二进制的介绍以及转换到十进制 Hexadecimal (to Decimal) 十六至进制的介绍以及转换到十进制 Convert 进制转换\nConvert from Decimal to Binary 13转换到二进制 Convert from Decimal to Hexadecimal 165转换到十六进制 Convert Binary \u0026lt;\u0026ndash;\u0026gt; Hexadecimal 一张非常有用的对照图 Binary -\u0026gt; Hex 向左填充完整的4位数: 0b11110 -\u0026gt; ob00011110\n然后根据上图进行转换最后得到 1E Hex -\u0026gt; Binary 转换0xA87 -\u0026gt; 0b101010000111\nNumber Representation Overflow TIP 比如 add(or -,*,/)的结果不能由已经固定的 bit 表示则称为 overflow. 例如0b1010(10) + 0b0111(7) = 0b10001(17),这个结果就超过了 4 位数","title":"Number Representation"},{"content":"资源:\n\u0026nbsp;https://regexlearn.com/zh-cn/cheatsheet \u0026nbsp;https://regexlearn.com/zh-cn/playground 速查表 匹配任意字符: /./g bar ber bir bor bur 字符集: [abc] /b[aeiou]r/g =\u0026gt; bar bir ber bor bur 将可选的字符放入[]中 否定字符集: [^abc] /b[^eo]r/g =\u0026gt; bar ber bir bor bur 在[]中的^输入要排除的字符 字母范围: [a-z] abcdefghijklmnopqrstuvwxyz /[e-o]/g =\u0026gt;abcdefghijklmnopqrstuvwxyz 将起始字母和结束字母写进[]中,中间用连字符-分隔,区分大小写 数字也同理: /[3-6]/g =\u0026gt; 0123456789 重复 *表示一个字符可以不出现或可以出现多次 /be*r/g =\u0026gt; br ber beer +表示一个字符出现一次或多次 /be+r/g =\u0026gt; br ber beer ?表示一个字符是可选的 /colou?r/g =\u0026gt; color, colour {n}指定一个字符出现 n 次 /be{2}r/g =\u0026gt; ber beer beeer beeeer {n,}指定一个字符至少出现 n 次 /be{3,}r/g =\u0026gt; ber beer beeer beeeer {n,m}指定一个字符出现 n ~ m 次 /be{1,3}r/g =\u0026gt; ber beer beeer beeeer 分组 ()包裹需要分组的文本 /(haa)/g =\u0026gt; ha-ha,haa-haa \\n引用分组, 个人理解是重复你引用的那个分组的内容 /(ha)-\\1,(haa)-\\2/g =\u0026gt; ha-ha,haa-haa (?:)非捕获分组, 个人理解是分组了，但是就当没有分组一样不可被引用 /(?:ha)-ha,(haa)-\\1/g =\u0026gt; ha-ha,haa-haa |允许一个表达式有多个不同的分支 /(c|r)at|dog/g =\u0026gt; cat rat dog \\转义字符 /(\\*|\\.)/g =\u0026gt; (*) Asterisk. 锚点 ^匹配行首 匹配以数字开头: /^[0-9]/g =\u0026gt; 1. 3 eggs, beaten $匹配行尾 匹配以 html 结尾: /html$/g =\u0026gt; \u0026nbsp;https://domain.com/what-is-html.`html` 字符类 \\w匹配字母、数字和下划线 /\\w/g =\u0026gt; abcABC123 _.:!? \\W与\\w相反 /\\W/g =\u0026gt; abcABC123 _.:!? \\d匹配数字 /\\d/g =\u0026gt; abcABC123 .:!? \\D匹配除数字外的所有字符 /\\D/g =\u0026gt; abcABC123 .:!? \\s匹配空格 /\\s/g =\u0026gt; abcABC123 .:!? \\S匹配出空格以外的所有字符 /\\S/g =\u0026gt; abcABC123 .:!? 零宽断言 正向先行断言: (?=xxx),xxx表示要匹配的字符 匹配后面是 PM 的数字: /\\d+(?=PM)/g =\u0026gt; Date: 4 Aug 3PM 负向先行断言:(?!xxx) 匹配后面不是 PM 的数字: /\\d+(?!PM)/g =\u0026gt; Date: 4 Aug 3PM 正向后行断言: (?\u0026lt;=) 匹配前面字符是 $ 的数字: /(?\u0026lt;=\\$)\\d+/g =\u0026gt;Product Code: 1064 Price: $5 负向后行断言: (?\u0026lt;!) 匹配后面字符不是 $ 的数字: /(?\u0026lt;!\\$)\\d+/g =\u0026gt;Product Code: 1064 Price: $5 标志 /\\w+\\.com/gmi g =\u0026gt; 全局,表示匹配所有匹配项,否则只匹配第一个 m =\u0026gt; 多行,单独处理每一行 i =\u0026gt; 忽略大小写 贪婪匹配,正则表达式默认是贪婪匹配: /.*r/ 懒惰匹配,/.*?r/,将查找以 r 结尾且前面带有任意字符的第一个匹配项 ber beer beeer beeeer 示例 Release 10/9/2021 匹配4位阿拉伯数字: /[0-9]{4}/g =\u0026gt; Release 10/9/2021 至少2位阿拉伯数字: /[0-9]{2,}/g =\u0026gt; Release 10/9/2021 1-4位阿拉伯数字: /[0-9]{1,4}/g =\u0026gt; Release 10/9/2021 ","permalink":"https://fzdwx.github.io/notes/14/","summary":"资源:\n\u0026nbsp;https://regexlearn.com/zh-cn/cheatsheet \u0026nbsp;https://regexlearn.com/zh-cn/playground 速查表 匹配任意字符: /./g bar ber bir bor bur 字符集: [abc] /b[aeiou]r/g =\u0026gt; bar bir ber bor bur 将可选的字符放入[]中 否定字符集: [^abc] /b[^eo]r/g =\u0026gt; bar ber bir bor bur 在[]中的^输入要排除的字符 字母范围: [a-z] abcdefghijklmnopqrstuvwxyz /[e-o]/g =\u0026gt;abcdefghijklmnopqrstuvwxyz 将起始字母和结束字母写进[]中,中间用连字符-分隔,区分大小写 数字也同理: /[3-6]/g =\u0026gt; 0123456789 重复 *表示一个字符可以不出现或可以出现多次 /be*r/g =\u0026gt; br ber beer +表示一个字符出现一次或多次 /be+r/g =\u0026gt; br ber beer ?表示一个字符是可选的 /colou?r/g =\u0026gt; color, colour {n}指定一个字符出现 n 次 /be{2}r/g =\u0026gt; ber beer beeer beeeer {n,}指定一个字符至少出现 n 次 /be{3,}r/g =\u0026gt; ber beer beeer beeeer {n,m}指定一个字符出现 n ~ m 次 /be{1,3}r/g =\u0026gt; ber beer beeer beeeer 分组 ()包裹需要分组的文本 /(haa)/g =\u0026gt; ha-ha,haa-haa \\n引用分组, 个人理解是重复你引用的那个分组的内容 /(ha)-\\1,(haa)-\\2/g =\u0026gt; ha-ha,haa-haa (?","title":"正则速查"},{"content":"#!/usr/bin/env just --justfile\r# default\rdefault:\r@just --choose\r# start wezterm on $PWD\rterm:\rwezterm start --class float --cwd={{ invocation_directory() }} ","permalink":"https://fzdwx.github.io/notes/13/","summary":"#!/usr/bin/env just --justfile\r# default\rdefault:\r@just --choose\r# start wezterm on $PWD\rterm:\rwezterm start --class float --cwd={{ invocation_directory() }} ","title":"just file template"},{"content":" 一个 tui 的 markdown 编辑器，just markdown。考虑用 go 写，附带 preview。 可能要使用到的库 \u0026nbsp;https://github.com/charmbracelet/glamour \u0026nbsp;https://github.com/charmbracelet/bubbletea \u0026nbsp;https://github.com/charmbracelet/lipgloss 这两天写了一个 demo: \u0026nbsp;https://github.com/fzdwx/md , 可以一用。 ","permalink":"https://fzdwx.github.io/notes/12/","summary":" 一个 tui 的 markdown 编辑器，just markdown。考虑用 go 写，附带 preview。 可能要使用到的库 \u0026nbsp;https://github.com/charmbracelet/glamour \u0026nbsp;https://github.com/charmbracelet/bubbletea \u0026nbsp;https://github.com/charmbracelet/lipgloss 这两天写了一个 demo: \u0026nbsp;https://github.com/fzdwx/md , 可以一用。 ","title":"idea"},{"content":" 记录一些影视作品的观看记录\n最近在看 动漫 已看完 动漫 电影 电视剧 ","permalink":"https://fzdwx.github.io/notes/11/","summary":" 记录一些影视作品的观看记录\n最近在看 动漫 已看完 动漫 电影 电视剧 ","title":"影视剧"},{"content":"主页:\n\u0026nbsp;课程主页 \u0026nbsp;cs diy 主页 视频资源 \u0026nbsp;第6和7集 \u0026nbsp;缺了看这个 \u0026nbsp;有一些 \u0026nbsp;2021 版本 \u0026nbsp;中文翻译 个人记录 我做 lab 时积累的一些相关的 blog\nMap Reduce \u0026nbsp;https://fzdwx.github.io/posts/2022-09-27-mit6.824-lab1/ Raft KV \u0026nbsp;https://fzdwx.github.io/posts/2022-10-10-raftkv/ ","permalink":"https://fzdwx.github.io/notes/9/","summary":"主页:\n\u0026nbsp;课程主页 \u0026nbsp;cs diy 主页 视频资源 \u0026nbsp;第6和7集 \u0026nbsp;缺了看这个 \u0026nbsp;有一些 \u0026nbsp;2021 版本 \u0026nbsp;中文翻译 个人记录 我做 lab 时积累的一些相关的 blog\nMap Reduce \u0026nbsp;https://fzdwx.github.io/posts/2022-09-27-mit6.824-lab1/ Raft KV \u0026nbsp;https://fzdwx.github.io/posts/2022-10-10-raftkv/ ","title":"6.824"},{"content":"刚刚改\u0026nbsp;nvim 配置时，不知道怎么回事，出现了游离分支(英文名称大概是 detached head )。主要症状就是 git提交不了，由于我用的 lazygit ，它的提示不明显，我以为提交了。然后后面打开 idea 看到底是什么。发现提示是游离分支，这个时候我也没在意。 最致命的操作来了: 我直接 checkout main 分支，然后今天晚上修改的记录全没了。\n我的解决方案:\n查看git log，只能显示当前分支的修改 commit 记录。 无效 利用 idea 的 local history 功能，只能找到文件，文件里面的内容是空白的。 无效 搜索 detached head 的解决方案，只能搜到没切换分支前的解决方案，不适用与我的现象。 无效 最后搜索 git 查看所有 commit ，找到了git reflog，它能显示可引用的历史版本记录，最后找到我要的那个 commit 之后直接git rest --hard xxx完美解决。 说实话，有点慌也有点烦，如果找不回来我可能会弃坑 nvim 了。\n","permalink":"https://fzdwx.github.io/posts/2022-10-23-about-git-detached-head/","summary":"如何在切换了分支之后恢复游离分支提交的代码。","title":"关于 git 游离分支"},{"content":"教程 \u0026nbsp;mdn css 书籍 \u0026nbsp;css in depth CSS lib \u0026nbsp;hyperui-Tailwind CSS Components ","permalink":"https://fzdwx.github.io/notes/8/","summary":"教程 \u0026nbsp;mdn css 书籍 \u0026nbsp;css in depth CSS lib \u0026nbsp;hyperui-Tailwind CSS Components ","title":"前端资料"},{"content":"资料 \u0026nbsp;Rust官方文档翻译项目组 ，内含一系列相关文档 \u0026nbsp;Rust语言圣经 \u0026nbsp;Rust resource 项目 \u0026nbsp;pingcap推出的project ，以 Talent Plan 开源数据库开发课程为依托，帮助学习者掌握数据库开发的理论知识，进行实际数据库开发锻炼。(\u0026nbsp;github 地址 ) ","permalink":"https://fzdwx.github.io/notes/7/","summary":"资料 \u0026nbsp;Rust官方文档翻译项目组 ，内含一系列相关文档 \u0026nbsp;Rust语言圣经 \u0026nbsp;Rust resource 项目 \u0026nbsp;pingcap推出的project ，以 Talent Plan 开源数据库开发课程为依托，帮助学习者掌握数据库开发的理论知识，进行实际数据库开发锻炼。(\u0026nbsp;github 地址 ) ","title":"Rust 相关资源集合"},{"content":"Roadmap \u0026nbsp;https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md cs61c [finish] Great Ideas in Computer Architecture\n主要资料 课程主页: \u0026nbsp;https://inst.eecs.berkeley.edu/~cs61c/fa20/ 视频: \u0026nbsp;https://inst.eecs.berkeley.edu/~cs61c/fa20/#lectures discussion: \u0026nbsp;https://www.youtube.com/watch?v=4HC3VqyPU7o\u0026list=PLYKsAjQZdJD_aO22u9YREZWQUV8WOdAC8\u0026ab_channel=CarolineLiu jyy os 操作系统\n主要资料 视频地址: \u0026nbsp;https://www.bilibili.com/video/BV1Cm4y1d7Ur 课程主页: \u0026nbsp;http://jyywiki.cn/OS/2022/ 阅读材料: 操作系统导论 \u0026nbsp;书首页 \u0026nbsp;书PDF 代码 \u0026nbsp;xv6-risc-v todo:\nlibco \u0026nbsp;https://www.bilibili.com/video/BV17T4y1S7RS/?spm_id_from=333.788\u0026vd_source=98f230be6561d2fc7450e7ce05876f68 jyy ics 关于jyy的计算机系统基础课\n主要资料 pa地址: \u0026nbsp;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/ 课程视频地址: \u0026nbsp;https://www.bilibili.com/video/BV1qa4y1j7xk 课程主页: \u0026nbsp;http://jyywiki.cn/ICS/2021/ NEMU ISA相关的API: \u0026nbsp;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/nemu-isa-api.html 扩展资料 Linux C编程一站式学习: \u0026nbsp;https://docs.huihoo.com/c/linux-c-programming/ 计算机教育中缺失的一课: \u0026nbsp;https://missing-semester-cn.github.io/ 6.s081 \u0026nbsp;http://xv6.dgs.zone/ \u0026nbsp;https://rcore-os.github.io/rCore-Tutorial-Book-v3/ ","permalink":"https://fzdwx.github.io/notes/6/","summary":"Roadmap \u0026nbsp;https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md cs61c [finish] Great Ideas in Computer Architecture\n主要资料 课程主页: \u0026nbsp;https://inst.eecs.berkeley.edu/~cs61c/fa20/ 视频: \u0026nbsp;https://inst.eecs.berkeley.edu/~cs61c/fa20/#lectures discussion: \u0026nbsp;https://www.youtube.com/watch?v=4HC3VqyPU7o\u0026list=PLYKsAjQZdJD_aO22u9YREZWQUV8WOdAC8\u0026ab_channel=CarolineLiu jyy os 操作系统\n主要资料 视频地址: \u0026nbsp;https://www.bilibili.com/video/BV1Cm4y1d7Ur 课程主页: \u0026nbsp;http://jyywiki.cn/OS/2022/ 阅读材料: 操作系统导论 \u0026nbsp;书首页 \u0026nbsp;书PDF 代码 \u0026nbsp;xv6-risc-v todo:\nlibco \u0026nbsp;https://www.bilibili.com/video/BV17T4y1S7RS/?spm_id_from=333.788\u0026vd_source=98f230be6561d2fc7450e7ce05876f68 jyy ics 关于jyy的计算机系统基础课\n主要资料 pa地址: \u0026nbsp;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/ 课程视频地址: \u0026nbsp;https://www.bilibili.com/video/BV1qa4y1j7xk 课程主页: \u0026nbsp;http://jyywiki.cn/ICS/2021/ NEMU ISA相关的API: \u0026nbsp;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/nemu-isa-api.html 扩展资料 Linux C编程一站式学习: \u0026nbsp;https://docs.huihoo.com/c/linux-c-programming/ 计算机教育中缺失的一课: \u0026nbsp;https://missing-semester-cn.github.io/ 6.s081 \u0026nbsp;http://xv6.dgs.zone/ \u0026nbsp;https://rcore-os.github.io/rCore-Tutorial-Book-v3/ ","title":"恶补计算机基础"},{"content":"主要原理就是通过 github action 的来监听 issue 的相关事件，然后读取issue中的内容创建文件提交到 git 上，最后直接部署。这样就能随时编辑并展示了。\n具体可以看 \u0026nbsp;add event to myb log 这个仓库， 以及\u0026nbsp;使用方式 。\n接下来介绍如何开发一个 github action:\n1. 克隆官方提供的template 官方主要对 typescript 的支持比较好，提供了一系列的\u0026nbsp;工具包 ，没办法只能同ts来进行开发，\n\u0026nbsp;https://github.com/actions/typescript-action 2. 定义想要在运行时用户输入的参数 通过编辑action.yml这个文件来定义想要在运行时定义的参数，比如说GITHUB_TOKEN:\nname: \u0026#39;add event to my blog\u0026#39; description: \u0026#39;add event to my blog\u0026#39; author: \u0026#39;fzdwx\u0026#39; branding: icon: \u0026#39;archive\u0026#39; color: \u0026#39;white\u0026#39; inputs: # 在这个key下面添加自定义参数 token: required: true description: \u0026#39;the repo PAT or GITHUB_TOKEN\u0026#39; runs: using: \u0026#39;node16\u0026#39; main: \u0026#39;dist/index.js\u0026#39; 参数有三个属性:\nrequired: 是否必须 description: 描述 default: 默认值 3. 实现想要的功能 详细可以查看我的\u0026nbsp;主要代码 。我的里面主要做了:\n根据当前issue number\u0026nbsp;获取该issue的内容 。 根据预定义的模板，\u0026nbsp;创建文件内容 。 提交到\u0026nbsp;git 上。 4. 发布到marketplace 需要勾选 Publish this Action to the GitHub Marketplace，可能需要2fa认证，找一个 github 支持(我用的是 authy，防止后面忘记了)就ok了。\nFigure 1 成功 release 后就能在别的项目中使用了。\n","permalink":"https://fzdwx.github.io/posts/2022-10-15-about-github-action/","summary":"起因是因为想要有一种可以不用编辑文件而作用到网站上的方式，然后就了解到了 github action 的形式。","title":"写一个自己的github action"},{"content":"壁纸网站:\n\u0026nbsp;https://wallhaven.cc/ \u0026nbsp;https://wallpaperscraft.com/catalog/anime/1920x1080 \u0026nbsp;https://wall.alphacoders.com/ ","permalink":"https://fzdwx.github.io/notes/5/","summary":"壁纸网站:\n\u0026nbsp;https://wallhaven.cc/ \u0026nbsp;https://wallpaperscraft.com/catalog/anime/1920x1080 \u0026nbsp;https://wall.alphacoders.com/ ","title":"壁纸"},{"content":"起因 昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:\ncd $(fd --type d | fzf) 这个命令也确实能完成任务，但是问题有两个:\n如果直接退出的话会回到家目录，因为$(..)的执行结果为空 每次都要输入这么多会很麻烦 用alias 然后尝试用alias来试试，所以就往.zshrc里面添加:\nalias cdf=\u0026#34;cd $(fd --type d | fzf)\u0026#34; 结果是直接不能运行，因为它直接识别了$(..)这一段，然后直接运行了，但是后面就不会运行。\n用shell脚本 然后就写了这个文件:\n#!/bin/sh path=$(fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules | fzf) if [ -z \u0026#34;$path\u0026#34; ]; then exit fi cd \u0026#34;$path\u0026#34; || exit 结果也是不行，后面我在最下面加了一行echo \u0026quot;$PWD\u0026quot;，我看到是执行了的，但是程序退出了就失效了。\n解决 最后我搜索到可以使用source xxx或者. xxx来解决，最后是alias+shell脚本来完成这个操作的:\nalias cdf=\u0026#34;source /path/to/cdf\u0026#34; 同时它也解决我上面提到的两个问题。\nsource为什么能解决？ 之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。\n而source或者.就代表着在当前的shell环境中执行，所以就能成功。\n更新 2022/11/18 今天发现一种更容易解决的办法,就是在写一个 shell 方法:\nfunction cd() { cd \u0026#34;$(fzf)\u0026#34; } 把它加入到.zshrc(我用的是 zsh)中，然后在命令行中输入 cd 就好了。\n","permalink":"https://fzdwx.github.io/posts/2022-10-11-about-source/","summary":"起因 昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:\ncd $(fd --type d | fzf) 这个命令也确实能完成任务，但是问题有两个:\n如果直接退出的话会回到家目录，因为$(..)的执行结果为空 每次都要输入这么多会很麻烦 用alias 然后尝试用alias来试试，所以就往.zshrc里面添加:\nalias cdf=\u0026#34;cd $(fd --type d | fzf)\u0026#34; 结果是直接不能运行，因为它直接识别了$(..)这一段，然后直接运行了，但是后面就不会运行。\n用shell脚本 然后就写了这个文件:\n#!/bin/sh path=$(fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules | fzf) if [ -z \u0026#34;$path\u0026#34; ]; then exit fi cd \u0026#34;$path\u0026#34; || exit 结果也是不行，后面我在最下面加了一行echo \u0026quot;$PWD\u0026quot;，我看到是执行了的，但是程序退出了就失效了。\n解决 最后我搜索到可以使用source xxx或者. xxx来解决，最后是alias+shell脚本来完成这个操作的:\nalias cdf=\u0026#34;source /path/to/cdf\u0026#34; 同时它也解决我上面提到的两个问题。\nsource为什么能解决？ 之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。\n而source或者.就代表着在当前的shell环境中执行，所以就能成功。\n更新 2022/11/18 今天发现一种更容易解决的办法,就是在写一个 shell 方法:\nfunction cd() { cd \u0026#34;$(fzf)\u0026#34; } 把它加入到.","title":"在shell脚本中执行cd后改变main shell的路径"},{"content":"idea 目前有一个想法，是在命令行下管理脚本的工具。\n例如说我有一些常用的脚本:\ncd $(find . -name \u0026#34;*\u0026#34; -type d | fzf) 然后通过命令行添加\ncli load \u0026#34;cd $(find . -name \u0026#34;*\u0026#34; -type d | fzf)\u0026#34; -alias cdf 然后使用cdf进行运行\ncli cdf 后续 2022-10-18 22:47\n刚刚找到了一个跟我这个想法很契合的项目: \u0026nbsp;https://github.com/denisidoro/navi 。\n今天一晚上都在调研技术的可行性，但是都达不到我想要的效果。还是这个例子，cd $(find . -name \u0026quot;*\u0026quot; -type d | fzf)， 主要有两种思路:\n在运行程序的使用利用shell的tab键盘补全，直接替换成这段命令，然后运行。比如说程序叫qwe，在shell里面输入qwe cdf\u0026lt;TAB\u0026gt; ，然后就直接替换为上面的命令。我在go里面找到cobra这个包，它能动态补全命令，有点效果，但还不够，不能做到全部替换，遂搁置。 直接在程序里面运行这段命令，我试了之后还是不行，cd执行后没有生效，应该还是跟fork有关。 然后就到github里面找别人的实现，没想到找到了一个，但是试过之后还是不支持，但确实做的还不错。\n想要做成我想要的效果就是实现:\n在shell中补全能直接替换所有，而不是一段。 在程序中不用fork运行。 还需要在看看。\n","permalink":"https://fzdwx.github.io/posts/2022-10-10-code-alias/","summary":"idea 目前有一个想法，是在命令行下管理脚本的工具。\n例如说我有一些常用的脚本:\ncd $(find . -name \u0026#34;*\u0026#34; -type d | fzf) 然后通过命令行添加\ncli load \u0026#34;cd $(find . -name \u0026#34;*\u0026#34; -type d | fzf)\u0026#34; -alias cdf 然后使用cdf进行运行\ncli cdf 后续 2022-10-18 22:47\n刚刚找到了一个跟我这个想法很契合的项目: \u0026nbsp;https://github.com/denisidoro/navi 。\n今天一晚上都在调研技术的可行性，但是都达不到我想要的效果。还是这个例子，cd $(find . -name \u0026quot;*\u0026quot; -type d | fzf)， 主要有两种思路:\n在运行程序的使用利用shell的tab键盘补全，直接替换成这段命令，然后运行。比如说程序叫qwe，在shell里面输入qwe cdf\u0026lt;TAB\u0026gt; ，然后就直接替换为上面的命令。我在go里面找到cobra这个包，它能动态补全命令，有点效果，但还不够，不能做到全部替换，遂搁置。 直接在程序里面运行这段命令，我试了之后还是不行，cd执行后没有生效，应该还是跟fork有关。 然后就到github里面找别人的实现，没想到找到了一个，但是试过之后还是不支持，但确实做的还不错。\n想要做成我想要的效果就是实现:\n在shell中补全能直接替换所有，而不是一段。 在程序中不用fork运行。 还需要在看看。","title":"Code:alias"},{"content":"Lab2文档翻译 由于我的英文不是很好，所以使用翻译软件进行翻译，然后人工进行校对进行理解。\noriginal地址: \u0026nbsp;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html Introduction 这是一系列实验中的第一个，我们将构建一个 fault-tolerant key/value storage system 。 在本实验中我们将实现 Raft (一种复制的状态机协议)。在下一个实验中，我们将在 Raft 上构建一个 key/value service 。 然后，您将在有多个副本的状态机上进行 shard(分片？根据 key 进行 hash 来决定路由到哪个副本上) 来提高性能。\n复制(replication)通过在多个复制服务器上存储其状态(即数据)的完整副本来实现 fault tolerance 。 即使有一些服务器出现 failure (崩溃或网络断开和抖动) replication 也允许它们继续运行。 挑战在于 failures 可能导致副本存在不同的数据。\nRaft 将客户端的请求组织成一个序列，被称为 log ，并且确保所有 replica servers 看到相同的 log 。 每个 replica 按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本(就是运行来自客户端的命令)。 由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。 如果一个服务器发生了 failure 但是后来又 recovery (恢复) 了，Raft 会负责将它的 log 更新到最新状态。只要至少大多数的服务器还活着，并且能够继续通信， 那么 Raft 将持续运行。如果没有到达这个数量，那么 Raft 将会停止运行，直到达到这个数量才会重新开始运行。\n在本 lab 中，你将把 Raft 实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。 一组 Raft 实例通过 RPC 来维护 replicated logs。你的 Raft 实例将支持一连串不确定编号的 command， 也可以叫 log entries。 这些 entity 通过 index(索引)来进行编号。具有给定索引的 log entry 将被 commit， 此时，您的 Raft 应该将这条 log 发送到 larger service 上执行。\n你应该遵循\u0026nbsp;extended Raft paper 中设计， 特别是\u0026nbsp;图2 .你将实现论文中的大部分内容，包括保存持久化状态和节点故障自动重启后读取状态。 你将不会实现集群成员的变化(Section 6)。\n你可能会发现这个\u0026nbsp;指南 很有用， 还有这个关于concurrency的\u0026nbsp;锁 和\u0026nbsp;结构 的建议， 如果需要更广泛的视角，可以看看 Paxos,Chubby,Paxos Made Live,Spanner,Zookeeper,Harp,Viewstamped Replication 和\u0026nbsp;Bolosky et al 。\n请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。 你可以参考\u0026nbsp;指导页 和这篇关于有效打印声明的\u0026nbsp;博文 。\n我们还提供了\u0026nbsp;Raft 交互图 ， 可以帮助阐明Raft代码如何与上层(使用者?)交互。\nThe code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。 你的实现必须支持以下接口，测试者和(最终)你的 key/value service 将使用该接口。你可以在raft.go的注释中找到更多细节。\nTIP Raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf.Start(command interface{}) (index, term, isleader) // ask a Raft for its current term, and whether it thinks it is leader rf.GetState() (term, isLeader) // each time a new entry is committed to the log, each Raft peer // should send an ApplyMsg to the service (or tester). type ApplyMsg Make Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg)\n用于创建 Raft server。\n所有的 raft server 的端口都在peers[]存放(包括当前的服务)，当前服务的端口可以通过peers[me]来获取。 所有的服务的perrs[]数组都具有相同的顺序。 presister是一个用来存放persistent state的地方，并且在初始的时候会保存最具的状态，如果有。 applyCh是 service 或 tester 发送消息给 raft 的通道。Make() 必须快速返回，所以它应该为一些长时间运行的任务启动goruntines。 Start 使用 Raft 的服务（例如 kv 服务器）希望就下一个要附加到 Raft 日志的命令开始协议。如果此服务器不是领导者，则返回 false。否则启动协议并立即返回。无法保证此命令将永远提交到 Raft 日志，因为领导者可能会失败或失去选举。即使 Raft 实例被杀死，这个函数也应该优雅地返回。第一个返回值是该命令在提交时将出现的索引。第二个返回值是当前术语。如果此服务器认为它是领导者，则第三个返回值为 true。\nStart(command interface{}) (int, int, bool)\n使用 Raft 的服务(e.g k/v server)希望就下一个要追加到 Raft 日志的命令开始协议。 如果当前 Raft server 不是 leader 则返回false。否则启动协议并立即返回，无需等待日志追加完成。 所以无法保证此命令将一定会被提交到 Raft 日志中，因为 leader 可能会失败或者在输掉选举。 即使 Raft 实例被 kill 这个函数也应该 return gracefully(优雅返回)。\n第一个返回值是该命令在 commit 时将被设置的 index。第二个返回值是当前的 term(任期)。如果此服务器认为自己是 leader 则第三个返回值是true。\n每个新提交的Raft log entity都应该发送一个AppliMsg到Make()的applyCh中。\n2A - Leader Election 实现 Raft leader election 以及 heartbeats(AppendEntries RPCs中不附带 log entries)。\n2A的目标是: 选出一个 leader，如果没有 failure，它仍然是 leader， 如果 old leader 失败或者与 old leader 之间的数据包发生丢失则由 new leader 接管。\nTIP 这个失败是 leader 出现故障的意思？就是说只要它没出现运行故障或者网络问题就永远是leader？ 要点:\n通过运行go test -run 2A来进行测试你的实现。 按照论文的\u0026nbsp;图2 ，主要关心发送和接收RequestVote RPCs ，与the Rules for Servers that relate to elections 以及the State related to leader election。 添加\u0026nbsp;图2 中与 leader election 相关的状态到Raft这个结构体中，且还需要定义一个结构来保存每个日志的信息。 实现RequestVote()，这样 raft 服务们就能互相投票了。添加RequestVOteArgs和RequestVoteReply者两个结构体。修改Make() ，创建一个 goroutine，用于检查心跳消息，如果有一段时间没有收到 peer 的消息时将发送RequestVote RPCs来定期发起领导者选举。这样，如果有 leader 了，peer 将知道谁是 leader，或者自己成为 leader。 实现心跳，需要定义一个AppendEntries RPC结构(尽管你可能还不需要所有参数)， 并且让 leader 定期发送它。编写一个AppendEntries RPC的 handle method，用于重置选举超时， 这样当有一个人已经当选时，其他服务器不会又成为 leader。 确保不同 peer 的选举超时不在同一时间发生，否则所有peer将只为自己投票，这样就没有人会成为leader了。 在测试时，leader 每秒发送的RPC请求不能超过 10 次。 在测试时，要求 Raft 在 old leader 失败后5秒内选举 new leader(如果大多数节点仍然能继续通讯)。 但是请记住，如果出现split vote(如果数据包丢失或者候选人选择了相同的随机退避时间就有可能发生)，leader 选举可能需要多轮。 所以必须设置足够短的选举超时(也就是心跳间隔)，即使会选举多轮，也有可能在5秒内完成。 论文的\u0026nbsp;Leader election 这一节中提到的选举超时范围是150到300毫秒。 只有当 leader 发送心跳的频率大大高于150毫秒一次时，上面提到的范围才有意义。由于在测试时限制每秒10次心跳， 所以必须使用比论文中更大的选举超时时间，但是不能太大，因为可能会无法在5秒内完成选举。 如果您的代码无法通过测试，请再次阅读论文中的\u0026nbsp;图2 ，leader 选举的全部逻辑分布在图中多个部分。 不要忘记实现GetState()。 在测试时，如果要关闭一个raft实例，会调用rf.kill()。我们可以调用rf.killed来检查是否被调用了kill()。您可能希望在所有的循环中都这样 做，以避免死亡的Raft实例打印混乱的信息。 go RPC只发送名称以大写字母开头的结构体字段。子结构体也必须拥有大写的字段名。 2B - log 实现 leader 以及 follower 的代码来添加新的日志。\n要点:\n你的首要目标就是通过TestBasicAgree2B。从实现Start()开始，根据\u0026nbsp;图2 ，编写代码， 通过AppendEntries发送和接收新的日志。发送最近提交的日志到对方的applyCh中 需要实现election restriction 在早期的 Lab 2B 测试中未能达成协议的一种方法是: 即时 leader 还存活也要重复进行选举。 在 election timer 中找 bug，或者在赢得选举后不立即发送心跳的问题。 你的代码中可能有重复检查某些事件的循环。不要让这些循环连续的的执行而没有暂停，这将使你的实现慢到无法通过测试。 使用 Go 的\u0026nbsp;condition variables 或者加入`time.sleep(10 * Millisecond)在每个循环中。 读懂config.go以及test_test.go以便了解在测试什么内容。 代码实现思路 大概记录一下代码的实现思路以及遇到的问题。\n2A 根据图2中的 state 这一节添加对应的属性 添加RaftRole属性，代表当前的角色: leader，candidate，follower 实现ticker这个函数: 可以使用两个time.timer来作为触发器 判断是否很久没有收到心跳，来发起选举 判断是否需要发送心跳，来维持自己的权威 这个时候要注意这条规则: 如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则 currentTerm 赋值为 T， 并切换状态为 follower。 实现发起选举的流程 根据图2中的Rules for Servers的candaidte流程一步一步实现 并行发起RequestVote RPC，如果票数大于 1/2 则转换为 leader(可能需要广播心跳)。 实现RequestVote 根据图2中的RequestVote RPC一步一步实现就好 实现AppendEntries 只需要简单的实现转换为 follower 以及刷新选举超时时间即可。 所有节点收到响应后刷新选举超时时间(具体情况具体判断) 成为 leader 后开始刷新心跳超时时间(来刷新 follower 的选举超时时间) 遇到的问题:\n1.第一个测试会有warning: Term changed even though there were no failures出现\n就是在有一个 leader 的时候其他 follower 还是发起了选举。猜测原因是election timeout和AppendEntries的时间点很邻近，这个只能调试 两种超时时间，我的选举超时时间是 200~350ms，心跳固定在 125ms。\n然后我在转换角色的时候加了一个if new role == old role then return的判断，这里导致election timeout没有刷新。\n2.在响应或请求时要第一时间处理第4条。\nRaft论文翻译 选取一些重要的片段进行翻译\noriginal地址: \u0026nbsp;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf Abstract Raft 是一种为了管理复制日志的共识算法。它提供了和 Paxos 算法相同的功能和性能，但它的算法结构和 Paxos 不同， Raft 更容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将共识算法分成了几个关键的模块，例如领导人选举，日志复制和安全性。 同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。Raft 还包括一个机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。\nIntroduction Raft 算法和已经存在的共识算法在某些地方很相似(主要是 Oki 以及 Liskov\u0026rsquo;s Viewstamped Replication)，但是它有以下新特性:\n强领导者: Raft 使用一种比其他共识算法更强的领导形式。例如，日志只从 leader 发送给其他服务器。 这简化了对复制日志的管理并使得 Raft 更容易理解。 领导选举: Raft 使用随机的计时器来选取 leader。这种方式仅仅是在所有共识算法都需要改进的心跳机制上有些许改进，然而这使得 Raft 在解决冲突时更简单和快速。 成员调整: Raft 使用了新的联合共识(join consensus)算法来处理集群成员变换的问， 在处于调整过程中的两种不同的配置的大多数集群会有重叠(overlap)，这就允许集群在成员变更的时候，持续正常运行。 Replicated State Machine Replicated State Machine(复制状态机)在分布式系统中被用于解决各种容错问题。例如 GFS、HDFS、RAMCloud 等单 leader 的大型集群系统， 通常使用独立的复制状态机来管理领导选举和存储配置信息来保证在 leader 崩溃的情况下也要存活下来，复制状态机的例子包括 Chubby 以及 Zookeeper。\nFigure 1: 复制状态机架构。共识算法管理来自客户端的包含状态机命令的复制日志，状态机按照相同的顺序来处理它们，所以它们产生相同的输出。 共识算法是在复制状态机的背景下提出的，在这种方法中，在一组服务器上的状态机对同一个的状态会计算出相同的副本，并且在一些服务器宕机的情况下也可以继续运行。\n如图一所示，复制状态机是通过复制日志实现的。每个服务器保存者一个包含一系列命令的日志，其状态机按照顺序来执行它们。 每个日志包含相同顺序的相同命令，所以每个状态机都执行相同的命令序列。因为状态机是确定的，所以每个状态机会计算出相同的状态和相同顺序的输出。\n共识算法的任务是 保证复制日志的一致性 。服务器上的共识模块接收来自客户端的命令并把它们添加到日志中， 并与其他服务器上的共识模块进行通讯以确保它们的每一条日志最终都相同(相同的请求有相同的顺序)，即使有一些服务发生故障。 一旦命令被正确的复制，每一个服务的状态机会按照日志的顺序去处理它们，然后将结果返回给客户端。\n因此，这些服务似乎成为了一个单一的，高度可靠的状态机。\n在实际的共识算法通常有以下属性:\n确保非拜占庭(non-Byzantine)条件下的安全性(永远不返回错误的结果)，包括网络延迟，分区以及网络数据包丢失、冗余、乱序。 只要大多数的服务都在运行并能相互通信且和客户端通信，它们就能发挥出全部的功能(可用性)。因此，一个5台服务的集群能容忍2台服务出现故障。 假定服务应为停机而出现故障，它们可能稍后会从stable storage中恢复状态并从新加入集群。 不依赖与时序来保证日志的一致性: 错误的时钟和极端的信息延迟延迟在最坏的情况下会导致可用性问题。 在一般情况下，一个命令的完成在于集群中的大多数对单轮远程调用作出响应，少数比较慢的服务不会影响系统的整体性能。 The Raft consensus algorithm Raft就是用于管理上一解描述的复制日志的算法。\u0026nbsp;图2 是对该算法的精简型式的总结，\u0026nbsp;图3 列出来该算法的关键属性，接下来对这些部分进行逐一讨论。\nRaft 通过选出一位 leader 然后给予它完全管理日志复制的责任来实现共识。leader 接收来自客户端的日志，然后复制给其他服务，并且通知在何时 它们可以安全的消费(作用到状态机上)这些日志。leader 简化了日志复制的管理。例如: leader 可以自主确定新日志存放在哪个位置而不用询问其他服务， 并且数据都从 leader 流向其他服务器。leader 可能会发生故障，或者和其他服务器失去连接，这个时候需要重新选举 leader。\n基于 leader 的方法，Raft 将一致性问题为了三个子过程来解决:\nleader 选举: 当 leader 失败(宕机)时需要选举新 leader 日志复制: leader 接收来自客户端的日志，并复制给集群中的其他机器，强制其他服务器与自己的一致 安全: Raft 的安全就在于\u0026nbsp;图3 中的安全属性: 如果任何服务器消费了一个日志，那么其他任何服务器就不 能在相同的日志索引消费不同的日志 Figure 2 Figure 2: Raft共识算法的精简摘要(不包括成员更改以及日志压缩)。左上角的服务器行为被描述为一组独立且重复触发的规则。 state:\n在所有服务器上持久化(在响应 RPC 请求之前，已经更新到了稳定的存储设备) currentTerm: 服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增） votedFor: 当前任期内收到选票的 candidate Id，如果没有投给任何候选人则为空 log[]: 日志条目,每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期(初始索引为1) 所有服务器上的易失性状态 commitIndex: 已知的提交的日志中的最大索引(初始0，单调递增) lastApplied: 状态机已经执行的日志中的最大索引(初始0，单调递增) 在 leader 上不稳定存在(在每次重新选举后初始化) nextIndex[]: 对于每一个服务器，发送到该服务器的下一个日志条目的索引(初始为leader的最后一条日志索引+1) matchIndex[]: 对于每一个服务器，已知的已经复制到该服务器的最高日志条目的索引(初始0，单调递增) AppendEntries RPC\n由leader发起调用来复制日志，同时也用于心跳检测\nArguments: term: leader 的任期 leaderId: 用于 follower 找到 leader(有时 client 把请求发送给了 follower) prevLogIndex: 紧邻新日志条目之前的那个日志条目的索引 prevLogTerm: 紧邻新日志条目之前的那个日志条目的任期 entries[]: 需要被保存的日志(为空时是心跳检测，可能一次会发送多条来提升效率) leaderCommit: leader 已提交的最高的日志条目的索引 Results: term: currentTerm，用于 leader 更新自己的term success: 如果follower的pervLogIndex以及prevLogTerm能够匹配上则为true Receiver implementation: if term \u0026lt; currentTerm then return false(如果 leader 的任期小于接收者的当前任期，接收者可以是 follower 以及 candidate) if log[prevLogIndex].term != prevLogTerm then return false(在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目则继续执行下面的步骤否则返回假) if log[oldIndex].term != log[newIndex].term then remove log[oldIndex,lastIndex]( 如果一个已经存在的日志与新的日志(请求中的日志条目)冲突(索引相同，任期不同)，则删除该索引处以及之后的所有日志) 添加在日志列表中不存在的新日志 if leaderCommit \u0026gt; commitIndex then commitIndex=min(leaderCommit,log[].last.commitIndex)( 如果 leader 的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引，则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 leader 的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值) RequestVote RPC\n候选人调用，收集选票\nArguments: term: candidate 的任期号 candidateId: 发起请求的 candidate 的 id lastLogIndex: candidate 的最后一条日志的索引 lastLogTerm: candidate 最后一条日志对应的任期号 Results: term: 当前任期号，用于candidate更新自己的term voteGranted: true表示候选人获得了选票 Receiver implementation: if term \u0026lt; currentTerm then return false(如果term \u0026lt; currentTerm返回 false) if (votedFor==null||votedFor==candidateId)\u0026amp;\u0026amp;(lastLogIndex,lastLogTerm)==log[].last then return true (如果 votedFor 为空或者与 candidateId 相同，并且候选人的日志和自己的日志一样新，则给该候选人投票) Rules for Servers\nAll Servers: if commitIndex \u0026gt; lastApplied then incr lastApplied and exec log[lastApplied]（如果commitIndex \u0026gt; lastApplied，lastApplied自增，将log[lastApplied]应用到状态机） if appendEntries.logs exist (log.term \u0026gt; currentTerm) then currentTerm = log.term and set status = follower(如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则 currentTerm 赋值为 T，并切换状态为 follower) Followers: 不会发出任何请求，只会对来自 candidates 以及 leader 的请求做出响应 选举超时后，如果未收到当前 leader(term 相同)的AppendEntries RPC或投票给了 candidate，则转换为 candidate Candidates: 转换成candidate之后开始选举 incr currentTerm 投票给自己 reset election timer 发送RequestVote RPC给其他所有服务器 如果收到了多数的选票则成为 leader 如果收到 new leader 的AppendEntries RPC则成为 follower 如果选举超时则开始新一轮的选举 Leaders: 一旦成为 leader 则向其他服务器发送空的AppendEntries RPC，在空闲时重复发送以防止选举超时 如果收到来自 client 的命令: 添加到本地日志，在执行并作用到状态机后作出响应给 client 对于 follower if last log index \u0026gt;= nextIndex(最后日志条目的索引值大于等于 nextIndex): 则通过AppendEntries RPC将nextIndex之后的所有日志都发送发送出去 如果成功: 将该 follower 的nextIndex以及matchIndex更新 如果因为日志不一致导致失败: nextIndex递减并重新发送 如果存在一个数N，满足N \u0026gt; commitIndex，大多数的matchIndex[i] \u0026gt;= N 以及log[N].term == currentTerm: set commitIndex = N Figure 3 Figure 3: Raft保证这些属性在在任何时候都上正确的。 Election Safety: 在给定 term 内只能选出一个 leader Leader Append-Only: leader 永远不覆盖或删除日志，只会添加 Log Matching: 如果两个日志在包含相同的 index 以及 term，那么就认定它们完全相同 Leader Completeness: 如果一条日志在给定的 term 内提交，那么它一定会出现在 term 更大的 leader 的日志中 State Machine Safety: 如果一个服务器已经将给定索引位置的日志条目应用到状态机之中，则其他所有服务器不会在相同索引处出现不同的日志 Raft basics 一个 Raft 集群可以包含多个服务器；5 是一个典型的数量，它允许系统容忍2次故障(有两台服务宕机)。 在给定的时间中每个服务都处在以下三种状态之一: leader, follower, candidate。 正常情况下，恰好只有一个 leader，所有其他服务器都是 follower。\nfollower 是被动的: 它们不会自己发出请求，而只是响应来自 leader 和 candidate 的请求。 leader 处理所有 client 的请求(如果 client 联系到 follower，则 follower 重定向到 leader)。 candidate 用于选举出一个新的 leader(可以看\u0026nbsp;图4 )。 Figure 4 Figure 4: Server states。follow 只响应其他服务的请求，如果 follow 接收不到任何消息，就会变成 candidate 并发起选举。获得整个集群 中大多数人投票的 candidate 成为候选人。leader 通常运行到它们失败为止。 如图5所示: Raft将时间分为任意长度的 terms。terms 的编号是连续的整数。每一个 term 开始于 election，一个或多个 candidate 尝试成为 leader。如果一个 candidate 赢得了选举，那么它将在剩下的 term 内担任 leader。\n在某些特殊情况下选举的结果是 split vote。在这种情况下，term 将会结束并且没有 leader。一个新的 term(伴随新一轮的选举)将很快开始。 Raft保证在给定的 term 内最多只有一个 leader。\nFigure 5 Figure 5: 将时间划分为 terms，每个 term 都以选举开始。选举成功后，一个 leader 管理集群直到 term 结束。 有时候选举会失败，那么这个 term 就会没有 leader 而结束。 term 之间的切换可以在不同的时间不同的服务器上观察到 不同的服务器可能会在不同的时间观察到 term 之间的转换，在某些情况下，一个服务器可能不会观察到选举甚至整个 term 的全程。 term 在 Raft 中充当了逻辑时钟，term 使得可以服务器检测过时的信息: 如过时的 leader。\n每个服务器都存储一个当前的 term 编号，该编号随时间单调地增加。每当服务器进行通信时，就会交换当前 term； 如果一个服务器的当前 term 比另一个服务器的小，那么它就会将其当前 term 更新为较大的值。\n如果一个 candidate 或 leader 发现它的 term 已经过时，它将立即恢复到 follower 的状态。\n如果一个服务器收到的请求是一个过时的 term 编号，它将拒绝该请求。\nRaft 服务器使用 RPC 进行通信，而基本的共识算法只需要两种类型的RPC。RequestVote RPCs由 candidate 在选举期间发起； AppendEntries RPCs由 leader 发起，用于复制日志条目并提供一种心跳机制。在下面的章节还增加了第三个RPC，用于在服务器之间传输快照。 如果服务器没有及时收到响应，它们会重试 RPC，并且为了获得最佳性能，它们会并行地发出 RPC。\nLeader election Raft 使用心跳机制来触发 leader 选举。当服务器启动时，初始状态都是 follower 。只要服务器收到来自 leader 或 candidate 的有效RPC， 它就一直处于 follower 状态。 leader 定期向所有 follower 发送心跳（AppendEntries RPCs，不携带日志条目），以保持他们的权威。 如果 follower 在一段时间内没有收到任何通信(election timeout)，那么它就认为没有可用的 leader，并开始选举以选择一个新的 leader。\n要开始一场选举，follower 要增加它的当前 term 并过转换到 candidate 状态。 然后，它为自己投票，并行的向集群中的每个其他服务器发出RequestVote RPCs。 candidate 将一直处于这种状态，直到发生以下三种情况之一:\n它赢得了选举 另一个服务器确立了自己的领导地位 一段时间之后没有任何人获胜。 接下来就对这些结果进行讨论:\n它赢得了选举\n如果一个 candidate 在同一任期( term )内获得了整个集群中大多数服务器的投票，那么它就赢得了选举。 每台服务器在给定的 term 内最多为一名 candidate 投票，以先来后到为原则。\n少数服从多数的原则保证了最多只有一名 candidate能够在某一 term 内赢得选举 (\u0026nbsp;图3 中的选举 Safety 属性)。 一旦一个 candidate 在选举中获胜，它就成为 leader。然后，它向所有其他服务器发送心跳信息(不携带日志的AppendEntries RPC)， 以建立其权威并防止新的选举发生。\n另一个服务器确立了自己的领导地位\n在等待投票的过程中，candidate 可能会收到另一个服务器的AppendEntries RPC，声称自己是领导者。 如果这个 leader 的term(会携带在 RPC 中)不小于 candidate 当前的 term， 那么 candidate 就会承认 leader 是合法的并返回到 follower 状态。 如果 RPC 中的 term 比 candidate 当前的 term 小，那么候选者会拒绝 RPC，并继续处于 candidate 状态。\n一段时间之后没有任何人获胜\n第三个可能的结果是 candidate 既没有赢得选举，也没有输掉选举: 如果许多 follower 同时成为 candidate，那么票数可能被分割， 因此没有 candidate 能获得足够的投票。 当这种情况发生时，每个 candidate 都会超时，然后通过增加其 term 和发起新一轮的RequestVote RPC来开始新的选举。 然而，如果没有额外的措施，split vote可能会无限期地重复。\nRaft 使用随机的选举超时时间，以确保 split vote 很少发生，并能迅速解决。 为了从一开始就防止 split vote，选举超时时间是从一个固定的时间间隔(例如150-300ms)中随机选择的。 这样每个服务器的选举超时时间就不同了，所以在大多数情况下，只有一个服务器会超时。\n如果一个服务赢得了选举，就在其他服务超时之前发送心跳，split vote就是使用这样的机制来处理。 每个 candidate 在选举开始时重新启动其随机选举超时(重新计时？)，并等待超时过后再开始下一次选举； 这减少了在新的选举中再次出现 split vote 的可能性。\n选举是一个用于说明可理解性是如何指导我们在设计方案做权衡的例子。 最初我们计划使用一个排名系统: 每个 candidate 被分配一个唯一的排名，用来在竞争的 candidate 之间进行选择。 如果一个候选人发现了另一个排名更高的候选人，它就会回到 follower 的状态，这样排名更高的候选人就能更容易地赢得下一次选举。 我们发现这种方法在可用性方面产生了一些微妙的问题(如果一个排名较高的服务发生故障了，一个排名较低的服务器可能需超时并再次成为 candidate ，但如果它过早地这样做，它可能会重置选举 leader 的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的角落案例。 最终我们得出结论，随机重试的方法更明显，更容易理解。\nLog replication 一旦一个领导者被选出，它就开始为 client 的请求提供服务。每个 client 的请求都包含一个要由复制的状态机执行的 command。 leader 将该 command 作为一个新的条目附加到它的日志中，然后并行发起AppendEntries RPC给其他每个服务器以复制该条日志。 当条目被安全的复制后(下面会介绍)，leader 将这条日志应用于其状态机，并将执行结果返回给 client。 如果 follower 崩溃或运行缓慢，又或者网络数据包丢失，leader 会无限期地重试AppendEntries RPC(甚至在它回应了客户端之后)， 直到所有 follower 最终存储所有日志条目。\nFigure 6: 日志由有序序号标记的条目组成。每个条目都包含创建它的 term(每个框中的数字)和一个状态机需要执行的命令。 如果一个条目可以安全地应用于状态机，那么该条目就被认为是 committed 的 日志的组织方式如\u0026nbsp;图6 所示。每个日志条目都存储了一个状态机命令， 以及 leader 收到该条目时的 term 编号。日志条目中的 term 编号被用来检测日志之间的不一致， 并确保\u0026nbsp;图3 中的一些属性。每个日志条目也有一个整数的索引来标识它在日志中的位置。\nleader 决定何时将日志条目应用于状态机是安全的，这样的条目被称为 committed 。 Raft 保证所提交的条目是持久化的并且最终会被所有可用的状态机执行。 一旦创建该条目的 leader 将其复制到大多数服务器上，该日志条目就会被提交(例如，图6中的条目7)。 这也会提交 leader 日志中所有之前的条目，包括之前领导者创建的条目。 leader 会跟踪它所知道的已提交的最大索引，并且它在未来的AppendEntries RPC(包括心跳)中包括该索引，以便其他服务器最终发现。 一旦 follower 得知一个日志条目被提交，它就会将该条目应用于其本地状态机(按日志顺序)。\n我们设计的 Raft 日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。 Raft 维护了以下特性，它们共同构成了\u0026nbsp;图3 中的Log Matching特性:\n如果不同的两个日志具有相同的 index 以及 term\n那么就认为它们存储的是同一个 command 那么就认为它们之前的所有日志也是相同的 第一个属性来自于这样一个事实，即一个 leader 在一个 term 内只能在一个 index 上创建一个日志条目，并且日志条目永远不会改变它们在日志中的位置。 第二个属性由AppendEntries RPC执行的简单一致性检查来保证。 当发送AppendEntries RPC时，leader 会包含其日志中紧接新条目之前的条目的 index 和 term 。 如果 follower 在其日志中没有找到具有相同 index 和 term 的条目，那么它将拒绝新条目。 一致性检查就像一个归纳步骤: 日志的初始状态是肯定满足Log Matching属性的， 并且每当日志被扩展时，一致性检查都会保留Log Matching属性。 因此，每当AppendEntries成功返回时，leader 知道 follower 的日志与自己的日志在新条目之前是相同的\n在正常运行期间，leader 和 follower 的日志保持一致，所以AppendEntries一致性检查不会失败。 然而，leader 崩溃会使日志不一致(old leader 可能没有完全复制其日志中的所有条目)。 这些不一致会在一系列 leader 和 follower 的崩溃中加剧。图7说明了 follower 的日志可能与new leader 的日志不同的方式。\nfollower 可能会丢失 leader 的条目 follower 可能会有 leader 没有的额外条目 或者两者都有 日志中缺失和多余的条目可能跨越多个 term 。\nFigure 7: 当一个 leader 成功当选时，follower 可能是(a-f)中的任何一种情况。 每个盒子代表一个日志条目；盒子里的数字是其 term。一个 follower 可能缺少条目(a-b)，可能有额外的未承诺的条目(c-d)，或者两者都有(e-f)。 例如f的发生条件: 如果该服务器是第2期的 leader ，在其日志中中已经增加了几个条目，然后在提交条目之前就崩溃了；它很快重新启动，成为第3期的 leader， 并在其日志中增加了几个条目；在第2期或第3期的条目被提交之前，该服务器又崩溃了，并持续了几个任期。 在 Raft 中，leader 通过强迫 follower 的日志重复自己的日志来处理不一致的情况。这意味着 follower 日志中的冲突条目将被 leader 日志中的条目覆盖。在下一节将表明，如果再加上一个限制，这就是安全的。\n为了使 follower 的日志与自己的日志保持一致，leader 必须找到两个日志一致的最新日志条目，删除该点之后 follower 日志中的所有条目， 并将该点之后的所有 leader 条目发送给 follower。所有这些操作都是为了响应AppendEntries RPC执行的一致性检查而发生的。 leader 为每个 follower 维护一个 nextIndex ，这是 leader 将发送给该 follower 的下一个日志条目的 index 。 当 leader 当选时，它会初始化所有 nextIndex 的值为自己最后一条日志的 index + 1(图 7 中的 11)。 如果 follower 的日志与 leader 的日志不一致，则AppendEntries一致性检查将在下一个AppendEntries RPC中失败。 follower 拒绝后，leader 会减少 nextIndex 的值并重试AppendEntries RPC。 最终nextIndex将达到 leader 和 follower 日志匹配的点。 发生这种情况时，AppendEntries将成功，这将删除 follower 日志中的任何冲突条目，并从 leader 日志中添加条目(如果有)。 一旦AppendEntries成功，follower 的 log 就会和 leader 的一致，并且在接下来的任期内保持这种状态。\n如果需要，可以优化协议以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝AppendEntries请求时， follower 可以包含冲突条目的 term 以它在 term 中存储的第一个索引。 有了这些信息，leader 可以减少 nextIndex 以绕过该 term 中的所有冲突条目； 每个有日志冲突的 term 都只需要一个AppendEntries RPC，而不是每个日志条目一个 RPC。 在实践中，我们怀疑这种优化是否必要，因为失败很少发生，而且不太可能有很多不一致的条目。\n通过这种机制，leader 在上台时无需采取任何特殊措施来恢复日志一致性。它刚刚开始正常运行， 并且日志会自动收敛以响应AppendEntries一致性检查的失败。 leader 永远不会覆盖或删除自己日志中的条目(\u0026nbsp;图3 中的Leader Append-Only)。\n理想的 Raft:\n只要大多数服务器启动，Raft 就可以接受、复制和应用新的日志条目 可以通过单轮 RPC 将新条目复制到集群的大部分； 并且单个慢速 follower 不会影响性能。 Safety 在前面的章节里面介绍了 Raft 怎样选举领导以及复制日志。 然而，这些机制还远不够来保证每个状态机以相同的顺序来执行相同的 command。 例如，一个 follower 可能是不可用状态(unavailable)而 leader 提交了若干个日志，然后它可能会被选为 leader 然后覆盖这些日志； 结果就是不同的状态机可能执行了不同的 command sequence。\n在这一节通过添加对哪些服务器可以被选举为 leader的限制来完善 Raft。 这个限制确保 leader 在任意给定 term 内，包含了之前任职期间的所有被提交的日志(\u0026nbsp;图3 中的Leader Completeness Property) 增加这个选举限制，让我们使提交时的规则更加准确。 最后，我们会展示一个简要的证明为Leader Completeness Property并且说明是怎样引导出正确行为的复制状态机。\nElection restriction 在任何基于 leader 的共识算法中，leader 必须将已提交的日志存储。在一些共识算法中，比如Viewstamped Replication， 一个节点能当选 leader，即使它一开始没有包含所有已提交的日志。 这些算法都有额外的机制来识别丢失的日志并发送给 new leader，要么在选举的过程中或者在选举之后不久。 不幸的是，这种方法会导致相当大的额外的机制和复杂性。\nRaft 使用了一种更加简单的方法，它可以保证在选举的时候新的 leader 拥有所有之前任期中已经提交的日志条目， 而不需要传送这些日志条目给 leader 。这意味着日志条目的传送是单向的，只从 leader 传给 follower， 并且 leader 从不会覆盖自身本地日志中已经存在的条目。\nRaft 使用投票的过程来阻止 candidate 赢得选举，除非它的日志包含所有已经提交的条目。cand- idate 为了被选举必须联系集群中的大部分节点，这意味着每个被提交的日志在这些服务上至少存在一个节点上。 如果 candidate 的日志至少与大多数日志中的任何其他日志一样最新(“最新”的定义在下面)，那么它一定保存了所有已提交的日志。\nRequestVote RPC实现的限制: RPC 会包含关于 candidate 的日志信息，如果 voter 自己的日志比 candidate 的日志更新， 那么 vote 会拒绝投票。\nRaft 通过比较最后一个日志的 index 以及 term来决定两个日志中的那个是最新的。 如果最后一条日志的 term 不同，则更大的那份就是更新的。 如果日志有相同的 term，那么哪个日志长(日志数组的长度？还是 index 的大小？)，哪个就是最新的。\nCommitting entries from previous terms 如\u0026nbsp;Log replication 介绍的那样， 只要日志被存储到大多数节点中，leader 就知道这条日志是可以在当前 term 内被提交的。 如果 leader 在提交日志之前崩溃了，未来的 leader 将会尝试完成这条日志的复制。 然而，leader 不能立即推断出在前一个 term 的日志在保存到大多数服务器上时就一定被提交了。 图8说明了一种情况: 一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导者覆盖掉。\nFigure 8: 如图的时间序列展示了为什么领导者无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d1) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (d2) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。 为了消除图8中的问题，Raft 永远不使用通过计算副本数量的方式去提交前一个 term 的日志。 只有 leader 当前 term 内的日志条目才会通过计算副本数量的方式来提交； 一旦当前 term 的日志以这种方式提交，那么由于Log Matching则之前的所有日志条目也被间接提交。 在某些情况下，leader能安全的知道一个老的日志是否已经被提交(例如，该日志是否存储到服务器上)， 但是 Raft 为了简化问题使用了一种更加保守的方法。\n当 leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号，这在提交规则上产生了额外的复杂性。 在其他的共识算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。 Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。 另外，和其他的算法相比，Raft 中的 new leader 只需要发送更少日志条目( 其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号)。 但是，这在实践中可能并不十分重要，因为领导者更换很少会发生。\nFollower and candidate crashes 如果 follower 或者 candidate 崩溃了，那么后续发给他们的 RPC 都会失败。 Raft 的处理方式就是无限重试，如果后续它们恢复了，这些请求就会成功。 如果一个节点在接收了一个 RPC 请求后，但是还没有响应的时候崩溃了，那么它在恢复的时候会再次收到同样的请求。 Raft 的 RPC 都是幂等的，所以重试不会造成任何问题。 如果一个 follower 收到AppendEntires RPC中包含已经存在的日志，那么它会直接忽略这个新的请求。\nTiming and availability Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。 但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。 例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\nbroadcastTime ≪ electionTimeout ≪ MTBF(平均故障时间) broadcastTime: 从一个服务器并行的发送 RPC 给集群中的其他服务器并接收响应的平均时间 electionTimeout: 选举超时时间 MTBF: 对一台服务器而言，两次故障之间的平均时间 broadcastTime 必须比 electionTimeout 小一个数量级才能够发送稳定的心跳消息来阻止 follower 进入选举状态。 通过随机生成的 electionTimeout，这个不等式使得 split vote 的情况变为不可能。 electionTimeout 应该比 MTBF 小上几个数量级，这样系统才能稳定的运行。 当 leader 崩溃后，整个系统会在一个 electionTimeout 内不可用，我们希望这种情况在整个系统的运行中很少出现。\nbroadcastTime 和 MTBF 是由系统决定的，但是 electionTimeout 是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去， 所以 broadcastTime 大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。 因此，electionTimeout 可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的 MTBF 都在几个月甚至更长，很容易满足时间的需求。\nCluster membership changes \u0026nbsp;https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn Links 项目地址: \u0026nbsp;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html Raft 官网: \u0026nbsp;https://raft.github.io/ GFS 相关资料: \u0026nbsp;https://fzdwx.github.io/posts/2022-10-07-gfs/#links Raft paper: \u0026nbsp;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf Raft paper 中文翻译: \u0026nbsp;https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md Diagram of Raft interactions： \u0026nbsp;https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf Students guid to Raft: \u0026nbsp;https://thesquareplanet.com/blog/students-guide-to-raft/ Raft locking: \u0026nbsp;https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt Raft structure: \u0026nbsp;https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt Paxos Replicated State Machines as the Basis of a High-Performance Data Store \u0026nbsp;https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf TiKV 对于 Raft 优化 \u0026nbsp;https://cn.pingcap.com/blog/optimizing-raft-in-tikv \u0026nbsp;https://www.cnblogs.com/niejunlei/p/9719557.html \u0026nbsp;https://blog.csdn.net/viskaz/article/details/124232474 \u0026nbsp;https://www.cnblogs.com/brianleelxt/p/13251540.html ","permalink":"https://fzdwx.github.io/posts/2022-10-10-raftkv/","summary":"Lab2文档翻译 由于我的英文不是很好，所以使用翻译软件进行翻译，然后人工进行校对进行理解。\noriginal地址: \u0026nbsp;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html Introduction 这是一系列实验中的第一个，我们将构建一个 fault-tolerant key/value storage system 。 在本实验中我们将实现 Raft (一种复制的状态机协议)。在下一个实验中，我们将在 Raft 上构建一个 key/value service 。 然后，您将在有多个副本的状态机上进行 shard(分片？根据 key 进行 hash 来决定路由到哪个副本上) 来提高性能。\n复制(replication)通过在多个复制服务器上存储其状态(即数据)的完整副本来实现 fault tolerance 。 即使有一些服务器出现 failure (崩溃或网络断开和抖动) replication 也允许它们继续运行。 挑战在于 failures 可能导致副本存在不同的数据。\nRaft 将客户端的请求组织成一个序列，被称为 log ，并且确保所有 replica servers 看到相同的 log 。 每个 replica 按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本(就是运行来自客户端的命令)。 由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。 如果一个服务器发生了 failure 但是后来又 recovery (恢复) 了，Raft 会负责将它的 log 更新到最新状态。只要至少大多数的服务器还活着，并且能够继续通信， 那么 Raft 将持续运行。如果没有到达这个数量，那么 Raft 将会停止运行，直到达到这个数量才会重新开始运行。\n在本 lab 中，你将把 Raft 实现为一个带有相关方法的 GO 的对象类型，目的是为了能在更大的模块中使用。 一组 Raft 实例通过 RPC 来维护 replicated logs。你的 Raft 实例将支持一连串不确定编号的 command， 也可以叫 log entries。 这些 entity 通过 index(索引)来进行编号。具有给定索引的 log entry 将被 commit， 此时，您的 Raft 应该将这条 log 发送到 larger service 上执行。","title":"Raft Kv"},{"content":"最近在学习 jyy 的\u0026nbsp;计算机系统基础习题课 ， 在做\u0026nbsp;pa1 的时候提 到一个运行红白机游戏的\u0026nbsp;项目 遇到的坑:\n1.SIGSTKSZ 参数找不到\nSIGSTKSZ参数找不到 将SIGSTKSZ修改为一个固定的参数\n//uint8_t sigstack[SIGSTKSZ]; uint8_t sigstack[8192]; 2.serial 不正确\nserial不正确 修改nemu/src/device/serial.c#init_serial，每个人的不同，我的是 9。\n","permalink":"https://fzdwx.github.io/posts/2022-10-09-mario-nes/","summary":"最近在学习 jyy 的\u0026nbsp;计算机系统基础习题课 ， 在做\u0026nbsp;pa1 的时候提 到一个运行红白机游戏的\u0026nbsp;项目 遇到的坑:\n1.SIGSTKSZ 参数找不到\nSIGSTKSZ参数找不到 将SIGSTKSZ修改为一个固定的参数\n//uint8_t sigstack[SIGSTKSZ]; uint8_t sigstack[8192]; 2.serial 不正确\nserial不正确 修改nemu/src/device/serial.c#init_serial，每个人的不同，我的是 9。","title":"在Abstract Machine上玩超级马里奥"},{"content":" C编译概述 可以用gcc -save-temps xx.c保存编译的中间文件\n宏定义与展开 宏展开: 通过 复制/粘贴 改变代码的形态\n一个include的例子 a.c:\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf( #include \u0026lt;qwe\u0026gt; ); } qwe:\n\u0026#34;hello world\\n\u0026#34; 通过运行gcc a.c \u0026amp;\u0026amp; a.out得到\n❯ gcc a.c \u0026amp;\u0026amp; a.out hello world 一个define的例子 a.c:\n#define A \u0026#34;aaaaaaaaaaaa\u0026#34; #define TEN(A) A A A A A A A A A #define B TEN(A) #define C TEN(B) int main(int argc, char const *argv[]) { puts(C); return 0; } 可以通过gcc a.c -E来查看预编译的结\n❯ gcc a.c -E # 0 \u0026#34;a.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;a.c\u0026#34; int main(int argc, char const *argv[]) { puts(\u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34;); return 0; } 修改true定义的例子 它只在特定的行数时才会为true。\na.c:\n#define true (__LINE__ % 2 != 0) #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } } 定义一个宏的参数为函数 #define NAMES(x) \\ x(Tom) x(Jerry) x(Tyke) x(Spike) int main(int argc, char const *argv[]) { #define PRINT(x) puts(\u0026#34;Hello,\u0026#34; #x \u0026#34;!\u0026#34;); NAMES(PRINT) } 可以看到，展开后是调用了4遍。\n❯ gcc -E a.c # 0 \u0026#34;a.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;a.c\u0026#34; int main(int argc, char const *argv[]) { puts(\u0026#34;Hello,\u0026#34; \u0026#34;Tom\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Jerry\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Tyke\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Spike\u0026#34; \u0026#34;!\u0026#34;); } C程序执行的两个视角 静态: C代码连续的一段总能找到对应一段连续的机器指令 动态: C代码执行的状态总能对应到机器的状态\n源代码视角: 函数，变量，指针 机器指令视角: 寄存器，内存，地址 共同的地方: 内存\n代码，变量(源代码) = 地址 + 长度(机器指令) 内存 = 代码 + 数据 + 堆栈 所以理解C程序执行最重要的就时内存模型。\n","permalink":"https://fzdwx.github.io/document/2022-10-09-c-compile/","summary":"C编译概述 可以用gcc -save-temps xx.c保存编译的中间文件\n宏定义与展开 宏展开: 通过 复制/粘贴 改变代码的形态\n一个include的例子 a.c:\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf( #include \u0026lt;qwe\u0026gt; ); } qwe:\n\u0026#34;hello world\\n\u0026#34; 通过运行gcc a.c \u0026amp;\u0026amp; a.out得到\n❯ gcc a.c \u0026amp;\u0026amp; a.out hello world 一个define的例子 a.c:\n#define A \u0026#34;aaaaaaaaaaaa\u0026#34; #define TEN(A) A A A A A A A A A #define B TEN(A) #define C TEN(B) int main(int argc, char const *argv[]) { puts(C); return 0; } 可以通过gcc a.c -E来查看预编译的结","title":"C Compile"},{"content":" 为了性能(Performance), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(Sharding)。 而成败上千的机器总会发生错误，所以有了容错(Fault Tolerance)。 实现容错最简单的方式就是复制(Replication)，其中一个发生故障了就切换另一个。 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(Inconsistency)。 如果为了实现一致性(Consistency)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(Low Perf) ，但这与我们开始的希望不符合。 TIP So，强一致性代表着低性能。 设计目标 由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：检查，容错以及快速从故障恢复。 主要支持大文件(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。 工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取 。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。 GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对大的流式读取，同时夜支持任意位置的小规模写入操作。 GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即原子操作。通常会有多个客户端会并行的对同一个文件进行append。 高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据 ，而很少有人对单个读写操作有严格的响应时间要求。 架构 单个master，多个chunk server(保存具体的文件)，多个client。 每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。 每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。 master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。 master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等 每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。 GFS Master中的metadata filename -\u0026gt; chunk ids(chunk handles) NV chunk handle与chunk数据的对应关系 chunk保存在哪个服务器上(chunk server list) chunk的version no NV chunk的primary chunk server，因为写操作在在其上进行 primary chunk server的lease expiration 这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。 每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)\nGFS Read Steps 首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。 master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。 然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。 client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近) ，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。 chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。 q1: 如果读取的数据跨越了一个chunk怎么办？ 例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界， 所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。\n多个副本之间变更顺序的一致性 针对一个chunk\nmaster授权给某个持有这个chunk的server一个租约期限(60s)，称为primary。 primary对所有的更改操作进行排序(serial order)，然后其他的secondary根据这个顺序进行变更。 只要这个chunk正在变更，那么primary就可以向master申请延长租约。 GFS Write Steps client向master发送请求获取chunk server list(primary,secondaries)， 如果没有primary，master就会选择一个secondary成为primary。 client获取到chunk server list后会缓存下来，只有当primary 没有响应或租约过期后才会再次请求。 client将数据推送到所有replicas，客户端不保证推送的顺序，每个chunk server会将数据保存在内部的lur cache中，直到数据被使用或过期。 当所有replicas都收到了数据，client将会发送一个写请求到primary，它标识了之前推送到每个副本的数据。 primary将这些写入组织成一定的顺序应用到自己本地。 primary然后将这个应用顺序转发给各个secondary。 secondaries应用这个顺序完成修改并答复primary。 primary答复client，如果出现了任意错误也会答复给client。在出现错误的情况下，write request也可能在primary以及secondary中成功 (如果primary直接就失败了，那么它将不会转发serial order给secondaries)，client将认为这次请求是失败的，它会通过重试来处理( 3-7尝试几次重新写入) GFS Atomic Record Appends 对同一片区域个并发写入是不可序列化的 这片区域可能最终包含多个客户端的数据片段。 一个原子的append操作。recored append至少会在给定的offset(GFS自己选择的，因为这里可能会失败，可能有一些chunk server上有这个数据) 上追加到文件上一次，并将该offset返回给client。它类似O_APPEND保证原子性。 recored append遵守\u0026nbsp; GFS Write Steps 流程，但是有一些特别的地方:\nclient推送所有数据后，primary会检查append到该chunk后是否超过了单个chunk的大小。 如果超过了，则在当前chunk填充到最大offset时(secondary也要保存)，回复client，指出该操作应该在下一个chunk上重试( record的大小需要控制在单个chunk最大值的四分之一，以保证碎片在可接收的水平)。 如果没有超过最大大小，则按照正常的情况进行保存。 过期副本检测 如果chunk server发生故障而宕机或者丢失了某些更新请求，那么它就有可能过期了。对于每个chunk，master都维护了一个version no来标识最新和过期的副本。\n当master为一个chunk的primary server授权或续期时就会增加version no并通知所有replicas进行更新。\n在数据一致的情况下，master和所有replicas的version no是一致的(在client发送写请求之前可以保证)。\n当chunk server重启或上报version no时，master会检查它时否包含过期的副本，如果发现master发现version no大于它的记录，master会采用更高的version no进行更新。\nmaster通过周期性的垃圾回收来删除过期的副本，在删除前，它会确认在它所有client的chunk信息请求的应答中没有包含这个过期的副本。\nclient在从master获取chunk server列表时会附带获取version no，所以它可以进行比对，选择最新的副本进行操作。\n总结 这并不是一个合格的多副本，多活，高可用，故障自修复的分布式系统。\nLinks \u0026nbsp;gfs paper 原文 \u0026nbsp;gfs paper 中文翻译 \u0026nbsp;gfs 视频 \u0026nbsp;gfs 视频翻译 \u0026nbsp;Bad Replication Design ","permalink":"https://fzdwx.github.io/posts/2022-10-07-gfs/","summary":"为了性能(Performance), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(Sharding)。 而成败上千的机器总会发生错误，所以有了容错(Fault Tolerance)。 实现容错最简单的方式就是复制(Replication)，其中一个发生故障了就切换另一个。 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(Inconsistency)。 如果为了实现一致性(Consistency)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(Low Perf) ，但这与我们开始的希望不符合。 TIP So，强一致性代表着低性能。 设计目标 由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：检查，容错以及快速从故障恢复。 主要支持大文件(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。 工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取 。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。 GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对大的流式读取，同时夜支持任意位置的小规模写入操作。 GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即原子操作。通常会有多个客户端会并行的对同一个文件进行append。 高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据 ，而很少有人对单个读写操作有严格的响应时间要求。 架构 单个master，多个chunk server(保存具体的文件)，多个client。 每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。 每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。 master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。 master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等 每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。 GFS Master中的metadata filename -\u0026gt; chunk ids(chunk handles) NV chunk handle与chunk数据的对应关系 chunk保存在哪个服务器上(chunk server list) chunk的version no NV chunk的primary chunk server，因为写操作在在其上进行 primary chunk server的lease expiration 这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。 每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)\nGFS Read Steps 首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。 master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。 然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。 client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近) ，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。 chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。 q1: 如果读取的数据跨越了一个chunk怎么办？ 例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界， 所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。","title":"GFS"},{"content":"查看当前backlight由什么控制:\n一般都是intel。\nls /sys/class/backlight 查看当前的亮度:\ncat /sys/class/backlight/intel_backlight/max_brightness 修改亮度:\necho 5000 | sudo tee /sys/class/backlight/intel_backlight/brightness ","permalink":"https://fzdwx.github.io/posts/2022-10-04-backlight/","summary":"由于使用DWM，它不能像KDE那样之间有图形化的亮度调节功能，所以记录一下。","title":"调节linux屏幕的亮度"},{"content":"1. 资料以及书 \u0026nbsp;zlib \u0026nbsp;《FFmpeg原理》 \u0026nbsp;数据库/存储学习路径推荐 \u0026nbsp;MySQL 45讲 2. 正则表达式 \u0026nbsp;learn regex101 3.Blockchain \u0026nbsp;中本聪论文 4.速查表 \u0026nbsp;GDB Card \u0026nbsp;LLDB 5. 终端下好用的程序 ranger \u0026nbsp;https://github.com/ranger/ranger 配置推荐 \u0026nbsp;https://zhuanlan.zhihu.com/p/105731111 \u0026nbsp;https://zhuanlan.zhihu.com/p/441083543 fzf(模糊搜索) \u0026nbsp;https://github.com/junegunn/fzf 压测工具 \u0026nbsp;https://github.com/link1st/go-stress-testing vhs(根据预定义的命令，调用bash，然后将输出结果记录为gif等) \u0026nbsp;https://github.com/charmbracelet/vhs ","permalink":"https://fzdwx.github.io/notes/1/","summary":"1. 资料以及书 \u0026nbsp;zlib \u0026nbsp;《FFmpeg原理》 \u0026nbsp;数据库/存储学习路径推荐 \u0026nbsp;MySQL 45讲 2. 正则表达式 \u0026nbsp;learn regex101 3.Blockchain \u0026nbsp;中本聪论文 4.速查表 \u0026nbsp;GDB Card \u0026nbsp;LLDB 5. 终端下好用的程序 ranger \u0026nbsp;https://github.com/ranger/ranger 配置推荐 \u0026nbsp;https://zhuanlan.zhihu.com/p/105731111 \u0026nbsp;https://zhuanlan.zhihu.com/p/441083543 fzf(模糊搜索) \u0026nbsp;https://github.com/junegunn/fzf 压测工具 \u0026nbsp;https://github.com/link1st/go-stress-testing vhs(根据预定义的命令，调用bash，然后将输出结果记录为gif等) \u0026nbsp;https://github.com/charmbracelet/vhs ","title":"收藏夹"},{"content":"安装: git clone https://git.suckless.org/dwm cd dwm sudo make clean install 启动 如果已经有了sddm，可以使用sudo systemctl disable sddm.service 来进行关闭，如果到时候不想用了可以用sudo systemctl enable sddm.service来开启sddm。\n# 准备配置文件 cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc # 添加 exec dwm # 注释 #twm \u0026amp; #xclock -geometry 50x50-1+1 \u0026amp; #xterm -geometry 80x50+494+51 \u0026amp; #xterm -geometry 80x20+494-0 \u0026amp; #exec xterm -geometry 80x66+0+0 -name login 然后重启并调用startx即可。\n遇到的问题 直接断网 使用NetworkManager进行连接，可能要用到dhcpcd。\nnmcli device wifi list nmcli device wifi connect {{wifi name}} password {{pwd}} 可能会连接失败，你可以试试nmcli connection show 来查看是否存在以前的连接信息，可以用nmcli connection delete {{wifi name}}来删除对应的信息\n输入法失效 添加配置文件\nvim ~/.pam_environment INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=@im=fcitx5 添加启动命令\nvim ~/.xinitrc1 # 在exec dwm之前添加 exec fcitx5 \u0026amp; 扩展屏幕无效 # 可以先查看有哪些屏幕 xrandr # # 将下面的命令加入 ~/.xinitrc1 中，在exec dwm之前添加 # 我有两个，是上下关系，所以用below 其他有 left 以及 right xrandr --output eDP-1-1 --auto --below HDMI-0 常用快捷键 可以参考我配置： \u0026nbsp;https://github.com/fzdwx/dwm MOD -\u0026gt; WIN\n快捷键 desc MOD+SHIFT+ENTER 新开终端 在本tag内切换聚焦窗口 快捷键 desc ALT + tab 切换聚焦窗口 MOD + up 切换聚焦窗口 MOD + down 切换聚焦窗口 跨tag操作 快捷键 desc MOD + left / right 切换tag MOD + SHIGT + left / tight 将当前窗口移动到其他tag MOD + a 第一次是显示所有tag，第二次是跳转到聚焦的窗口所在的窗口 窗口操作 快捷键 desc MOD + q 退出窗口 MOD + h 隐藏窗口 MOD + SHIFT + h 显示窗口（像一个栈一样。） MOD + ENTER 将当前窗口设置为主窗口 MOD + f 将当前窗口全屏 MOD + CTRL + 方向键 移动窗口 MOD + ALT + 方向键 调整窗口大小 MOD + o 只显示当前窗口/显示所有窗口 MOD + t 开启/关闭 聚焦目标的浮动模式 MOD + SHIFT + t 开启/关闭 全部目标的浮动模式 | MOD + SHIFT + f | 开启/关闭 状态栏 |\n切换屏幕 快捷键 desc MOD + x 将鼠标移动到其他屏幕 MOD + SHIFT + X 将当前窗口移动到其他屏幕 更新 click status bar 最近跟进了大佬的配置\u0026nbsp;yaocccc , 可点击的 status bar.\n主要原理就是根据预定义的格式解析出signal ,然后调用预定义的脚本文件(\u0026nbsp;commit )\n也很容易扩展，可以参考我的\u0026nbsp;fm , update是构造要返回的内容, click就是点击时调用的方法,wezterm start --class float ranger我这一段就是启动 wezterm 并调用 ranger.\nimg.png Links \u0026nbsp;ArchWiki Dwm \u0026nbsp;Dwm patches \u0026nbsp;Dwm patches中文翻译 \u0026nbsp;picom美化 ","permalink":"https://fzdwx.github.io/posts/2022-09-29-dwm/","summary":"安装: git clone https://git.suckless.org/dwm cd dwm sudo make clean install 启动 如果已经有了sddm，可以使用sudo systemctl disable sddm.service 来进行关闭，如果到时候不想用了可以用sudo systemctl enable sddm.service来开启sddm。\n# 准备配置文件 cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc # 添加 exec dwm # 注释 #twm \u0026amp; #xclock -geometry 50x50-1+1 \u0026amp; #xterm -geometry 80x50+494+51 \u0026amp; #xterm -geometry 80x20+494-0 \u0026amp; #exec xterm -geometry 80x66+0+0 -name login 然后重启并调用startx即可。\n遇到的问题 直接断网 使用NetworkManager进行连接，可能要用到dhcpcd。\nnmcli device wifi list nmcli device wifi connect {{wifi name}} password {{pwd}} 可能会连接失败，你可以试试nmcli connection show 来查看是否存在以前的连接信息，可以用nmcli connection delete {{wifi name}}来删除对应的信息","title":"Dwm初体验"},{"content":" 由于最近切换到了linux，不可避免的经常需要使用vi等编辑器，所以这次好好折腾一下。\n我的配置地址: \u0026nbsp;https://github.com/fzdwx/nvim ,现在直接使用 \u0026nbsp;LazyVim .\n过期\n我的配置 pakcer 我选用的插件管理器是packer，我也不知道选什么好，就按最新的来吧。\n--- setup packer local fn = vim.fn local install_path = fn.stdpath(\u0026#39;data\u0026#39;) .. \u0026#39;/site/pack/packer/start/packer.nvim\u0026#39; if fn.empty(fn.glob(install_path)) \u0026gt; 0 then packer_bootstrap = fn.system({ \u0026#39;git\u0026#39;, \u0026#39;clone\u0026#39;, \u0026#39;--depth\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;https://github.com/wbthomason/packer.nvim\u0026#39;, install_path }) vim.cmd(\u0026#34;packadd packer.nvim\u0026#34;) end --- add plugins require(\u0026#39;packer\u0026#39;).startup(function(use) -- 自托管 use \u0026#39;wbthomason/packer.nvim\u0026#39; -- 其他插件 -- 如果是第一次则同步 if packer_bootstrap then require(\u0026#39;packer\u0026#39;).sync() end end) \u0026nbsp;alpha 是一个dashboard，也可以说是一个欢迎界面。\nrequire(\u0026#39;packer\u0026#39;).startup(function(use) -- ... --- 添加下面两行进行安装 use \u0026#34;goolord/alpha-nvim\u0026#34;; use \u0026#34;kyazdani42/nvim-web-devicons\u0026#34;; -- ... end) 配置代码太长了就不放了，可以点击这里\u0026nbsp; 这里 参考。\n\u0026nbsp;telescope 主要作用是文件的查找与预览。\nrequire(\u0026#39;packer\u0026#39;).startup(function(use) -- ... --- 添加下面代码进行安装 use { \u0026#39;nvim-telescope/telescope.nvim\u0026#39;, tag = \u0026#39;0.1.0\u0026#39;, \u0026#34;ahmedkhalf/project.nvim\u0026#34;, \u0026#39;nvim-lua/plenary.nvim\u0026#39;, } -- ... end) \u0026nbsp;配置 \u0026nbsp;key map 一些教程 \u0026nbsp;Rust and nvim ","permalink":"https://fzdwx.github.io/posts/2022-09-28-neovim-use-notes/","summary":"由于最近切换到了 linux，不可避免的经常需要使用 vi 等编辑器，所以这次好好折腾一下。","title":"Neovim使用记录  "},{"content":" HTTP 1.1之前的实现就不讨论了，因为它们已经过时太久了，我上网的时候就已经接触不到了，所以主要说说HTTP/1.1、HTTP/2。\nHTTP/1.1 HTTP/1.1协议报文简介 CRLF: \\r\\n\nMETHOD: HTTP请求，GET、POST、PUT、DELETE\u0026hellip;\nURI: 统一资源标识符，例如/，/index.html\u0026hellip;\nHTTPVersion: HTTP协议的版本号，例如HTTP/1.1，HTTP/2\nHEADERS: 请求头，例如Host:localhost，Accept: */*。\nBODY: 请求体，例如说一个JSON数据{\u0026quot;name\u0026quot;:\u0026quot;fzdwx\u0026quot;}\nHTTPStatus: HTTP响应状态，常见的有200，404等\nHTTPStatusDesc: HTTP响应状态描述，200对应的OK。\n请求 METHOD\u0026lt;SPACE\u0026gt;URI\u0026lt;SPACE\u0026gt;HTTPVersion HEADERS \u0026lt;CRLF\u0026gt; BODY 示例:\nGET /hello HTTP/1.1 Host: 192.168.1.107:8889 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.82 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 响应 HTTPVersion HTTPStatus HTTPStatusDesc HEADERS \u0026lt;CRLF\u0026gt; BODY 示例:\n如果响应中使用了transfer-encoding: chunked这个来替代Content-Length ，就表示这是一个不固定大小的响应，结尾通常用0\\r\\n来分割。\nHTTP/1.1 200 OK transfer-encoding: chunked content-type: application/json; charset=utf-8 0/r/n HTTP/1.1主要新特性 默认是长连接(Connection: Keep-alive)，支持一个TCP连接处理多个请求。 缓存策略，在请求头中使用Cache-Control，Expires，Last-Modified，ETag等来控制。 允许响应分块，就是上面提到的transfer-encoding: chunked，允许服务端可以多次返回响应体。 但是还是存在一定的问题，例如说如果有一个TCP连接阻塞了，还是会开启新的TCP连接进行处理请求。\nH2 HTTP2中的主要概念:\nConnection: 一个TCP连接包含一个或多个Stream,所有的通讯都在一个TCP连接上完成。 Stream: 一个可以双向通讯的数据流，包含一条或多条Message，每个数据流都一个唯一标识符以及可选的优先级信息。 Message: 对应HTTP/1.1中的请求或响应，包含一条或多条Frame。 Frame: 最小传输单位，它以二进制进行编码。 \u0026nbsp;HTTP通讯简图 在HTTP/1.1中是有Start Line + header + body 组成的，而在H2中是由一个HEADER Frame以及多个DATA Frame组成的。\nHTTP/1.1与H2报文组成的区别 Frame 通常有一些公共的字段，例如Length，Type，Flags以及Stream Id；也各个类型所独有的字段。\n分类如下:\n\u0026nbsp;DATA : 用于传输http消息体。 \u0026nbsp;HEADERS : 用于传输首部字段。 \u0026nbsp;PRIORITY : 用于指定或重新指定引用资源的优先级。 \u0026nbsp;RST_STREAM : 用于通知流的非正常终止。 \u0026nbsp;SETTINGS : 用于约定客户端和服务端的配置数据。例如设置初识的双向流量控制窗口大小。 \u0026nbsp;PUSH_PROMISE : 服务端推送许可。 \u0026nbsp;PING : 用于计算往返时间，执行“ 活性” 检活。 \u0026nbsp;GOAWAY : 用于通知对端停止在当前连接中创建流。 \u0026nbsp;WINDOW_UPDATE : 用于调整个别流或个别连接的流量。 \u0026nbsp;CONTINUATION : 专门用于传递较大 HTTP 头部时的持续帧。 为什么H2必须要走HTTPS？ 这其实在H2标准中没有规定，主要是为了更方便的进行HTTP协议的 升级/协商，确认一个Web服务器是否支持H2通常有两种方式:\n在请求头中设置Upgrade: HTTP/2.0以及Connection: Upgrade,HTTP2-Settings等，类似升级到Websocket。 使用TLS中的ALPN(Application Layer Protocol Negotiation，应用层协议协商)中的ALPN Next Protocol 字段，在Client Hello与Server Hello这个阶段就可以确定下来。 而现在的浏览器基本都是实现的方式二，即与HTTPS绑定在一起。但是如果我们不用浏览器进行访问，当然也可以不用HTTPS。\n详细可\u0026nbsp;参考 。\n为什么H2能实现并行响应请求? 在HTTP/1.1中，请求与响应是一一对应的，在同一个连接里，客户端依次发送两个请求，一段时间以后收到来自服务器的一个响应，这个响应一定是对应于第一个发出去的请求的。 因为没有一个标志来表示哪个响应对应哪个请求。\n而在H2中基于Stream和Frame的设计: 每个Frame都带有Stream Id来标识是否为同一个Stream里面的数据，每个Stream 互不影响，这样就能做到在一个TCP里面连接里面传输多对请求/响应。\nH2的新特性 H2的对HTTP/1.1优化的核心就是 使用尽可能少的连接数。\n多路复用: 只用一个TCP连接就能处理多对 请求/响应 ，不用在开启另外的TCP连接，就是通过Stream与Frame来实现的。 二进制分帧: 使用Frame为最小单位进行通讯，并采用二进制编码。 \u0026nbsp;头部压缩 : 使用HPACK算法进行优化. 维护一份相同的\u0026nbsp;静态字典 ，包含常见的请求头的KV组合 一份动态字典，可以动态的扩容(每个连接单独维护) 支持哈夫曼编码(\u0026nbsp;静态哈夫曼码表 ) 在HTTP/1中消息体可以用gzip进行压缩，但是请求头通常没有任何压缩，有时候请求头的数据可能比请求体的数据还多。\n请求优先级: 一般在HEADERS帧与PRIORITY帧中携带，通常依赖于服务端的支持程度。 工具 生成测试签名 go run $GOROOT/src/crypto/tls/generate_cert.go --host localhost 使用curl调试HTTPS curl https://zcygov.cn -vv Links \u0026nbsp;Hypertext Transfer Protocol Version 2 (HTTP/2) \u0026nbsp;HPACK: Header Compression for HTTP/2 \u0026nbsp;HTTP/2资料汇总 \u0026nbsp;HTTP/2中帧的定义 \u0026nbsp;HTTP/2新的机遇与挑战 \u0026nbsp;探索http1.0到http3.0的发展史，详解http2.0 \u0026nbsp;HTTP/2相比1.0有哪些重大改进 ","permalink":"https://fzdwx.github.io/posts/2022-09-28-http-protocol/","summary":"简介HTTP/1.1与H2。","title":"HTTP协议"},{"content":"看的时候很懵，写的时候更懵，我以为是要写几个MapReduce的程序，在把官方的A few rules以及Hints( 翻译可以看\u0026nbsp;这里 ) 仔细的阅读了几遍后才发现是要写一个 MapReduce 的调度框架。。。\n解题思路可以分为 3 步。\nworker与master先通过rpc进行通信，即worker发送请求，master能够正确的应答且worker 能够收到。这一部分其实示例代码已经给到了，可以模仿着写一个从master获取需要执行的任务名称的rpc request。 上面一步完成后就可以进行真正的Map task请求以及执行了: Map task何时生成？ 每个worker只向master请求一次就好了吗？ Map task执行 超时/失败 需要有重试机制吗？ 如何保证Map task消费时的线程安全？ 当所有的Map task执行完毕后就需要执行Reduce task了，如果你写完了第 2 步，那么Reduce task其实就是水到渠成了。 生成Reduce task，这里的每个Reduce task需要加载的文件按什么分成一组？ 剩下的与Map task处理方法相同。 我就是卡在了Reduce task创建时文件分组这个地方了，我直接把同一个Map task生成的文件当成一组了\u0026hellip;但是显然不是这样。\n","permalink":"https://fzdwx.github.io/document/2022-09-27-mit6.824-lab1/","summary":"about mit6.824 lab1(Map reduce framework)","title":"MapReduce 框架实现思路"},{"content":" 今天发现了一个 linux 下的 application launcher \u0026nbsp;rofi ，它可以快速切换窗口和启动程序， 我用它和wmctrl进行配合使用。\n我的使用过程:\n1.Archlinux install\nyay -S rofi 2.添加自定义快捷键绑定 hotkey 为alt+space触发rofi -show。\n3.pressalt+space，然后使用shift+leftorright进行切换 mode 。\n更改主题以及显示 icon:\n1.生成配置文件\nmkdir -p ~/.config/rofi rofi -dump-config \u0026gt; ~/.config/rofi/config.rasi 2.显示icon\nsed -i \u0026#39;8c show-icons: true;\u0026#39; ~/.config/rofi/config.rasi 3.更换主题\n参考 \u0026nbsp;https://github.com/lr-tech/rofi-themes-collection#installing-themes 我的wmctrl的配置示例:\n使用xprop WM_CLASS获取前缀。\nalias chrome=\u0026#34;wmctrl -x -a google-chrome || google-chrome-stable \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias note=\u0026#34;wmctrl -x -a obsidian || /usr/bin/obsidian \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias codew=\u0026#34;wmctrl -x -a code || /opt/code/code \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias idea=\u0026#34;wmctrl -x -a jetbrains-idea || /opt/idea/bin/idea.sh \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias discord=\u0026#34;wmctrl -x -a discord || /opt/discord/Discord \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; ","permalink":"https://fzdwx.github.io/posts/2022-09-18-about-rofi/","summary":"今天发现了一个 linux 下的 application launcher \u0026nbsp;rofi ，它可以快速切换窗口和启动程序， 我用它和wmctrl进行配合使用。\n我的使用过程:\n1.Archlinux install\nyay -S rofi 2.添加自定义快捷键绑定 hotkey 为alt+space触发rofi -show。\n3.pressalt+space，然后使用shift+leftorright进行切换 mode 。\n更改主题以及显示 icon:\n1.生成配置文件\nmkdir -p ~/.config/rofi rofi -dump-config \u0026gt; ~/.config/rofi/config.rasi 2.显示icon\nsed -i \u0026#39;8c show-icons: true;\u0026#39; ~/.config/rofi/config.rasi 3.更换主题\n参考 \u0026nbsp;https://github.com/lr-tech/rofi-themes-collection#installing-themes 我的wmctrl的配置示例:\n使用xprop WM_CLASS获取前缀。\nalias chrome=\u0026#34;wmctrl -x -a google-chrome || google-chrome-stable \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias note=\u0026#34;wmctrl -x -a obsidian || /usr/bin/obsidian \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias codew=\u0026#34;wmctrl -x -a code || /opt/code/code \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias idea=\u0026#34;wmctrl -x -a jetbrains-idea || /opt/idea/bin/idea.","title":"一个linux中的应用程序 launcher: Rofi"},{"content":"","permalink":"https://fzdwx.github.io/flomo/","summary":"","title":""}]