[{"content":"起因 昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:\ncd $(fd --type d | fzf) 这个命令也确实能完成任务，但是问题有两个:\n如果直接退出的话会回到家目录，因为$(..)的执行结果为空 每次都要输入这么多会很麻烦 用alias 然后尝试用alias来试试，所以就往.zshrc里面添加:\nalias cdf=\u0026#34;cd $(fd --type d | fzf)\u0026#34; 结果是直接不能运行，因为它直接识别了$(..)这一段，然后直接运行了，但是后面就不会运行。\n用shell脚本 然后就写了这个文件:\n#!/bin/sh path=$(fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules | fzf) if [ -z \u0026#34;$path\u0026#34; ]; then exit fi cd \u0026#34;$path\u0026#34; || exit 结果也是不行，后面我在最下面加了一行echo \u0026quot;$PWD\u0026quot;，我看到是执行了的，但是程序退出了就失效了。\n解决 最后我搜索到可以使用source xxx或者. xxx来解决，最后是alias+shell脚本来完成这个操作的:\nalias cdf=\u0026#34;source /path/to/cdf\u0026#34; 同时它也解决我上面提到的两个问题。\nsource为什么能解决？ 之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。\n而source或者.就代表着在当前的shell环境中执行，所以就能成功。\n","permalink":"https://fzdwx.github.io/posts/2022-10-11-about-source/","summary":"起因 昨天晚上想用fzf与cd联动，就是fzf的结果传递给cd来执行于是有了这么一条命令:\ncd $(fd --type d | fzf) 这个命令也确实能完成任务，但是问题有两个:\n如果直接退出的话会回到家目录，因为$(..)的执行结果为空 每次都要输入这么多会很麻烦 用alias 然后尝试用alias来试试，所以就往.zshrc里面添加:\nalias cdf=\u0026#34;cd $(fd --type d | fzf)\u0026#34; 结果是直接不能运行，因为它直接识别了$(..)这一段，然后直接运行了，但是后面就不会运行。\n用shell脚本 然后就写了这个文件:\n#!/bin/sh path=$(fd --type d --strip-cwd-prefix --hidden --follow --exclude .git --exclude node_modules | fzf) if [ -z \u0026#34;$path\u0026#34; ]; then exit fi cd \u0026#34;$path\u0026#34; || exit 结果也是不行，后面我在最下面加了一行echo \u0026quot;$PWD\u0026quot;，我看到是执行了的，但是程序退出了就失效了。\n解决 最后我搜索到可以使用source xxx或者. xxx来解决，最后是alias+shell脚本来完成这个操作的:\nalias cdf=\u0026#34;source /path/to/cdf\u0026#34; 同时它也解决我上面提到的两个问题。\nsource为什么能解决？ 之所以直接用shell脚本直接运行会不行，是因为它不是在当前shell环境中运行的，而是一个子shell，所以结果就不能改变当前的文件目录了。\n而source或者.就代表着在当前的shell环境中执行，所以就能成功。","title":"在shell脚本中执行cd后改变main shell的路径"},{"content":"目前有一个想法，是在命令行下管理脚本的工具。\n例如说我有一些常用的脚本:\ncd $(find . -name \u0026#34;*\u0026#34; -type d | fzf) 然后通过命令行添加\ncli load \u0026#34;cd $(find . -name \u0026#34;*\u0026#34; -type d | fzf)\u0026#34; -alias cdf 然后使用cdf进行运行\ncli cdf ","permalink":"https://fzdwx.github.io/posts/2022-10-10-code-alias/","summary":"目前有一个想法，是在命令行下管理脚本的工具。\n例如说我有一些常用的脚本:\ncd $(find . -name \u0026#34;*\u0026#34; -type d | fzf) 然后通过命令行添加\ncli load \u0026#34;cd $(find . -name \u0026#34;*\u0026#34; -type d | fzf)\u0026#34; -alias cdf 然后使用cdf进行运行\ncli cdf ","title":"Code:alias"},{"content":"Lab2文档翻译 Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。 在本实验中我们将实现Raft(一种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。 然后，您将在多个复制的状态机上进行shard来提高性能。\n复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。 即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。 挑战在于failures可能导致副本存在不同的数据。\nRaft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。 每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。 由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。 如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信， 那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。\n在本lab中，你将把Raft实现为一个带有相关方法的GO的对象类型，目的是为了能在更大的模块中使用。 一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command， 也可以叫log entries。 这些entries通过索引来进行编号。具有给定索引的log entry将被提交，此时， 您的Raft应该将这个条log发送到更大的服务上执行。\n你应该遵循 extended Raft paper 中设计， 特别是图 2.你将实现论文宏的大 部分内容，包括保存持久化状态和节点故障自动重启后读取状态。 你将不会实现集群成员的变化(Section 6)。\n你可能会发现这个 指南 很有用， 还有这个关于concurrency的锁 和结构 的建议， 如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication和 Bolosky et al 。\n请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。 你可以参考 指导页 和这篇关于有效打印声明的 博文 。\n我们还提供了 Raft 交互图 ， 可以帮助阐明Raft代码如何与上层(使用者?)交互。\nThe code 通过向raft/raft.go添加代码来实现Raft。在该文件中，你会发现骨架代码，以及如何发送和接收 RPC 的例子。 你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用该接口。你可以在raft.go的注释中找到更多细节。\nTIP raft 实例只能通过 rpc 进行通信且必须使用labrpc这个包(例如不能使用文件以及共享变量)。 // create a new Raft server instance: rf := Make(peers, me, persister, applyCh) // start agreement on a new log entry: rf.Start(command interface{}) (index, term, isleader) // ask a Raft for its current term, and whether it thinks it is leader rf.GetState() (term, isLeader) // each time a new entry is committed to the log, each Raft peer // should send an ApplyMsg to the service (or tester). type ApplyMsg Make(peers []*labrpc.ClientEnd, me int,persister *Persister, applyCh chan ApplyMsg) 用于创建 raft server。\n所有的 raft server 的端口都在peers[]存放(包括当前的服务)，当前服务的端口可以通过peers[me]来获取。 所有的服务的perrs[]数组都具有相同的顺序。 presister是一个用来存放persistent state的地方，并且在初始的时候会保存最具的状态，如果有。 applyCh是 service 或 tester 发送消息给 raft 的通道。Make() 必须快速返回，所以它应该为一些长时间运行的任务启动goruntines。 Start(command interface{}) (int, int, bool) 使用Raft的服务(e.g a k/v server)希望就下一个要追加到raft日志的命令达成一致(就是追加到 raft 日志的下一条命令是相同的？)。如果当前raft server不是leader则返回false。 否则启动协议并立即返回，无需等待日志追加完成。 所以无法保证次命令将一定会被提交到raft日志中，因为leader可能会失败或者在选举中失败。 即使raft实例被kill这个函数也应该return gracefully。\n第一个返回值是该命令出现的索引，如果它曾经被提交的话。第二个返回值是当前的术语(???)。如果这个服务器认为它是领导者，第三个返回值是真。\n每个新提交的raft log entity都应该发送一个AppliMsg到Make()的applyCh中。\n2A 实现Raft leader election以及heartbeats(AppendEntriesRPCs没有log entries。空的的意思?)。\n2A的目标是: 选出一个leader，如果没有失败，它仍然是leader，如果old leader失败或者与old leader之间的数据包发生丢失则由new leader接管。\nTIP 这个失败是 leader 出现故障的意思？就是说只要它没出现运行故障或者网络问题就永远是leader？ 要点:\n通过运行go test -run 2A来进行测试你的实现。 按照论文的图 2，主要关系发送和接收RequestVote RPCs，与the Rules for Servers that relate to elections 以及the State related to leader election。 添加图 2 中与 leader election 相关的状态到Raft这个结构体中，且还需要定义一个结构来保存每个日志的信息。 实现RequestVote()，这样 raft 服务们就能互相投票了。添加RequestVOteArgs和RequestVoteReply者两个结构体。修改Make() ，创建一个 goroutine，用于检查心跳消息，如果有一段时间没有收到 peer 的消息时将发送RequestVoteRPCs 来定期发起领导者选举。这样，如果有 leader 了，peer 将知道谁是 leader，或者自己成为 leader。 实现心跳，需要定义一个AppendEntriesRPC 结构(尽管你可能还不需要所有参数)， 并且让leader定期发送它。编写一个AppendEntriesRPC 的 handle method，用于重置选举超时， 这样当有一个人已经当选时，其他服务器不会又成为leader。 确保不同peer的选举超时不在同一时间发生，否则所有peer将只为自己投票，这样就没有人会成为leader了。 在测试时，leader每秒发送的RPC请求不能超过 10 次。 在测试时，要求raft在old leader失败后5秒内选举new leader(如果大多数节点仍然能继续通讯)。但是请记住，如果出现split vote( 如果数据包丢失或者候选人选择了相同的随机退避时间就有可能发生)，leader选举可能需要多轮。所以必须设置足够短的选举超时( 也就是心跳间隔)，即使会选举多轮，也有可能在5秒内完成。 论文的第5.2节提到的选举超时范围是150到300毫秒。只有当leader发送心跳的频率大大高于150毫秒一次时，上面论文提到的范围才有意义。 由于在测试时限制每秒10次心跳，所以必须使用比论文中更大的选举超时时间，但是不能太大，因为可能会无法在5秒内完成选举。 如果您的代码无法通过测试，请再次阅读论文中的图2，leader选举的全部逻辑分布在图中多个部分。 不要忘记实现GetState()。 在测试时，如果要关闭一个raft实例，会调用rf.kill()。我们可以调用rf.killed来检查是否被调用了kill()。您可能希望在所有的循环中都这样 做，以避免死亡的Raft实例打印混乱的信息。 GO RPC只发送名称以大写字母开头的结构体字段。子结构体也必须拥有大写的字段名。 Raft论文翻译 选取一些重要的片段进行翻译\nIntroduction raft算法和已经存在的共识算法在某些地方很相似(主要是Oki以及Liskov\u0026rsquo;s的Viewstamped Replication)，但是它有以下新特性:\nraft is similar in many ways to existing consensus al-gorithms (most notably, Oki and Liskov’s Viewstamped Replication), but it has several novel features:\n强领导者: Raft使用一种比其他共识算法更强的领导形式。例如，日志只从leader发送给其他服务器。这简化了对复制日志的管理，使的Raft更容易理解。 领导选举: Raft使用随机定时器来选取leader。这种方式仅仅是在所有共识算法都需要改进的心跳机制上有些许改进，然而这使得Raft在解决冲突时更简单和快速。 成员调整: 集群中更改server时，Raft使用了新的联合共识(join consensus)算法， 两种不同的配置的majorities在变更期间重叠(overlap)， 允许集群在配置变更的时候，持续正常运行。 Strong leader: Raft uses a stronger form of leadership than other consensus algorithms. For example,log entries only flow from the leader to other servers. This simplifies the management of the replicated log and makes Raft easier to understand. Leader election: Raft uses randomized timers to elect leaders. This adds only a small amount of mechanism to the heartbeats already required for any consensus algorithm, while resolving conflicts simply and rapidly. Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach where the majorities of two different configurations overlap during transitions. This allows the cluster to continue operating normally during configuration changes. Replicated State Machine 复制状态机(Replicated State Machine)在分布式系统中被用于解决各种容错问题。例如GFS,HDFS,RAMCloud等单leader的大型集群系统，通常使用独立 的复制状态机来管理领导选举和存储配置信息来保证在leader崩溃会存活下来，复制状态机的例子包括Chubby以及Zookeeper。\nFigure 1: 复制状态机架构。共识算法管理来自客户端的包含状态机命令的复制日志，状态机按照相同的顺序来处理它们，所以它们产生相同的输出。 共识算法通常出现在复制状态机的上下文中，在这种方法中，在一组server上的状态机对同一个的状态会计算出相同的副本，即使一些server宕机也可以继续运行。\nReplicated state machines are used to solve a variety of fault tolerance problems in distributed systems. For example, large-scale systems that have a single cluster leader, such as GFS, HDFS, and RAMCloud, typically use a separate replicated state machine to manage leader election and store configuration information that must survive leader crashes. Examples of replicated state machines include Chubby and ZooKeeper. Consensus algorithms typically arise in the context of replicated state machines.In this approach, state machines on a collection of servers compute identical copies of the same state and can continue operating even if some of the servers are down.\n复制状态机通过复制日志实现，如图一所示。每个服务保存包含一系列命令的日志，其状态机按照顺序来执行它们。 每个日志包含相同顺序的相同命令，所以每个状态机处理相同的命令序列。因为状态机是确定的， 所以每个状态机会计算出相同的状态和相同顺序的输出。\nReplicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order. Each log contains the same commands in the same order, so each state machine processes the same sequence of commands. Since the state machines are deterministic, each computes the same state and the same sequence of outputs.\n共识算法的任务是保证复制日志的一致性。服务器上的共识模块接收来自客户端的命令并把它们添加到日志中， 并与其他服务器上的共识模块进行通讯以确保它们的每一条日志最终都相同(相同的请求有相同的顺序)， 即使有一些服务失败了。一旦命令被正确的复制， 每一个服务的状态机会按照日志的顺序去处理它们，然后将结果返回给客户端。\n因此，这些服务似乎成为了一个单一的，高度可靠的状态机。\nKeeping the replicated log consistent is the job of the consensus algorithm. The consensus module on a server receives commands from clients and adds them to its log. It communicates with the consensus modules on other servers to ensure that every log eventually contains the same requests in the same order, even if some servers fail. Once commands are properly replicated, each server’s state machine processes them in log order, and the outputs are returned to clients. As a result, the servers appear to form a single, highly reliable state machine.\n在实际的共识算法通常有以下属性:\n确保非拜占庭(non-Byzantine)条件下的安全性(永远不返回错误的结果)，包括网络延迟，分区以及网络数据包丢失、冗余、乱序。 只要大多数的服务都在运行并能相互通信且和客户端通信，它们就能发挥出全部的功能(可用性)。因此，一个5台服务的集群能容忍2台服务出现故障。 假定服务应为停机而出现故障，它们可能稍后会从stable storage`中恢复状态并从新加入集群。 不依赖与timing来保证日志的一致性: 错误的时钟和极端的信息延迟延迟在最坏的情况下会导致可用性问题。 在一般情况下，一个命令的完成在于集群中的大多数对单轮远程调用作出响应，少数低水平的服务不会影响系统的整体性能。 Consensus algorithms for practical systems typically have the following properties:\nThey ensure safety (never returning an incorrect result) under all non-Byzantine conditions, including network delays, partitions, and packet loss, duplication, and reordering. They are fully functional (available) as long as any majority of the servers are operational and can communicate with each other and with clients. Thus, a typical cluster of five servers can tolerate the failure of any two servers. Servers are assumed to fail by stopping; they may later recover from state on stable storage and rejoin the cluster. They do not depend on timing to ensure the consistency of the logs: faulty clocks and extreme message delays can, at worst, cause availability problems. In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of remote procedure calls; a minority of low servers need not impact overall system performance. The Raft consensus algorithm Raft就是用于管理上一解描述的复制日志的算法。图2是对该算法的精简型式的总结，图3列出来该算法的关键属性，接下来对这些部分进行逐一讨论。\nRaft is an algorithm for managing a replicated log of he form described in Section 2. Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm; the elements of these figures are discussed piecewise over the rest of this section.\n// todo\nRaft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines. Having a leader simplifies the management of the replicated log. For example, the leader can decide where to place new entries in the log without consulting other servers, and data flows in a simple fashion from the leader to other servers. A leader can fail or become disconnected from the other servers, in which casea new leader is elected.\nFigure 2: Raft共识算法的精简摘要(不包括成员更改以及日志压缩)。左上角的服务器行为被描述为一组独立且重复触发的规则。 Figure 3: Raft保证这些属性在在任何时候都上正确的。 Raft is an algorithm for managing a replicated log of the form described in Section 2. Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm; the elements of these figures are discussed piecewise over the rest of this section\nLinks 项目地址: https://pdos.csail.mit.edu/6.824/labs/lab-raft.html GFS 相关资料: https://fzdwx.github.io/posts/2022-10-07-gfs/#links Raft paper: https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf Diagram of Raft interactions： https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf Students guid to Raft: https://thesquareplanet.com/blog/students-guide-to-raft/ Raft locking: https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt Raft structure: https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt Paxos Replicated State Machines as the Basis of a High-Performance Data Store https://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf https://www.cnblogs.com/niejunlei/p/9719557.html https://blog.csdn.net/viskaz/article/details/124232474 https://www.cnblogs.com/brianleelxt/p/13251540.html ","permalink":"https://fzdwx.github.io/posts/2022-10-10-raftkv/","summary":"Lab2文档翻译 Introduction 这是一系列实验中的第一个，我们将构建一个fault-tolerant key/value storage system。 在本实验中我们将实现Raft(一种复制的状态机协议)。在下一个实验中，我们将在Raft上构建一个key/value service。 然后，您将在多个复制的状态机上进行shard来提高性能。\n复制的服务通过在多个复制服务器上存储其状态(即数据)的完整副本来实现fault tolerance。 即使有一些服务器出现故障(崩溃或网络断开和抖动)replication也允许它们继续运行。 挑战在于failures可能导致副本存在不同的数据。\nRaft将客户端的请求组织成一个序列，被成为log，并且确保所有replica servers看到相同的log。 每个副本按照日志的顺序来执行客户端的请求，将它们应用于其本地的服务状态副本。 由于所有存活的副本读取的日志内容都是相同的，所以都以相同的顺序来执行请求，因此它们都有相同的服务状态。 如果一个服务器失败了但是后来又恢复来，Raft会复制把它的日志更新。只要至少大多数的服务器还或者，并且能够继续通信， 那么Raft将继续运行。如果没有到达这个数量，那么Raft将会停止运行，直到到达这个数量才会重新开始。\n在本lab中，你将把Raft实现为一个带有相关方法的GO的对象类型，目的是为了能在更大的模块中使用。 一组Raft实例通过RPC来维护replicated logs。你的Raft实例将支持一连串不确定编号(数量?)的command， 也可以叫log entries。 这些entries通过索引来进行编号。具有给定索引的log entry将被提交，此时， 您的Raft应该将这个条log发送到更大的服务上执行。\n你应该遵循 extended Raft paper 中设计， 特别是图 2.你将实现论文宏的大 部分内容，包括保存持久化状态和节点故障自动重启后读取状态。 你将不会实现集群成员的变化(Section 6)。\n你可能会发现这个 指南 很有用， 还有这个关于concurrency的锁 和结构 的建议， 如果需要更广泛的视角，可以看看Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication和 Bolosky et al 。\n请记住，本 lab 中最具挑战性的部分可能不是实现你的解决方案，而是调试它。为了帮助应对这一挑战，你可能需要把事件花在如何使你的实现更容易调试。 你可以参考 指导页 和这篇关于有效打印声明的 博文 。\n我们还提供了 Raft 交互图 ， 可以帮助阐明Raft代码如何与上层(使用者?)交互。","title":"Raft Kv"},{"content":"最近在学习 jyy 的 计算机系统基础习题课 ， 在做 pa1 的时候提 到一个运行红白机游戏的 项目 运行起来的效果 遇到的坑:\n1.SIGSTKSZ 参数找不到\nSIGSTKSZ参数找不到 将SIGSTKSZ修改为一个固定的参数\n//uint8_t sigstack[SIGSTKSZ]; uint8_t sigstack[8192]; 2.serial 不正确\nserial不正确 修改nemu/src/device/serial.c#init_serial，每个人的不同，我的是 9。\n","permalink":"https://fzdwx.github.io/posts/2022-10-09-mario-nes/","summary":"最近在学习 jyy 的 计算机系统基础习题课 ， 在做 pa1 的时候提 到一个运行红白机游戏的 项目 运行起来的效果 遇到的坑:\n1.SIGSTKSZ 参数找不到\nSIGSTKSZ参数找不到 将SIGSTKSZ修改为一个固定的参数\n//uint8_t sigstack[SIGSTKSZ]; uint8_t sigstack[8192]; 2.serial 不正确\nserial不正确 修改nemu/src/device/serial.c#init_serial，每个人的不同，我的是 9。","title":"在Abstract Machine上玩超级马里奥"},{"content":"宏定义与展开 宏展开: 通过 复制/粘贴 改变代码的形态\n一个include的例子 a.c:\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf( #include \u0026lt;qwe\u0026gt; ); } qwe:\n\u0026#34;hello world\\n\u0026#34; 通过运行gcc a.c \u0026amp;\u0026amp; a.out得到\n❯ gcc a.c \u0026amp;\u0026amp; a.out hello world 一个define的例子 a.c:\n#define A \u0026#34;aaaaaaaaaaaa\u0026#34; #define TEN(A) A A A A A A A A A #define B TEN(A) #define C TEN(B) int main(int argc, char const *argv[]) { puts(C); return 0; } 可以通过gcc a.c -E来查看预编译的结\n❯ gcc a.c -E # 0 \u0026#34;a.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;a.c\u0026#34; int main(int argc, char const *argv[]) { puts(\u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34; \u0026#34;aaaaaaaaaaaa\u0026#34;); return 0; } 修改true定义的例子 它只在特定的行数时才会为true。\na.c:\n#define true (__LINE__ % 2 != 0) #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } if(true){printf(\u0026#34;yes %d\\n\u0026#34;, __LINE__); } } 定义一个宏的参数为函数 #define NAMES(x) \\ x(Tom) x(Jerry) x(Tyke) x(Spike) int main(int argc, char const *argv[]) { #define PRINT(x) puts(\u0026#34;Hello,\u0026#34; #x \u0026#34;!\u0026#34;); NAMES(PRINT) } 可以看到，展开后是调用了4遍。\n❯ gcc -E a.c # 0 \u0026#34;a.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;a.c\u0026#34; int main(int argc, char const *argv[]) { puts(\u0026#34;Hello,\u0026#34; \u0026#34;Tom\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Jerry\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Tyke\u0026#34; \u0026#34;!\u0026#34;); puts(\u0026#34;Hello,\u0026#34; \u0026#34;Spike\u0026#34; \u0026#34;!\u0026#34;); } C程序执行的两个视角 静态: C代码连续的一段总能找到对应一段连续的机器指令 动态: C代码执行的状态总能对应到机器的状态\n源代码视角: 函数，变量，指针 机器指令视角: 寄存器，内存，地址 共同的地方: 内存\n代码，变量(源代码) = 地址 + 长度(机器指令) 内存 = 代码 + 数据 + 堆栈 所以理解C程序执行最重要的就时内存模型。\n","permalink":"https://fzdwx.github.io/posts/2022-10-09-c-compile/","summary":"宏定义与展开 宏展开: 通过 复制/粘贴 改变代码的形态\n一个include的例子 a.c:\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf( #include \u0026lt;qwe\u0026gt; ); } qwe:\n\u0026#34;hello world\\n\u0026#34; 通过运行gcc a.c \u0026amp;\u0026amp; a.out得到\n❯ gcc a.c \u0026amp;\u0026amp; a.out hello world 一个define的例子 a.c:\n#define A \u0026#34;aaaaaaaaaaaa\u0026#34; #define TEN(A) A A A A A A A A A #define B TEN(A) #define C TEN(B) int main(int argc, char const *argv[]) { puts(C); return 0; } 可以通过gcc a.c -E来查看预编译的结\n❯ gcc a.c -E # 0 \u0026#34;a.","title":"C Compile"},{"content":" 为了性能(Performance), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(Sharding)。 而成败上千的机器总会发生错误，所以有了容错(Fault Tolerance)。 实现容错最简单的方式就是复制(Replication)，其中一个发生故障了就切换另一个。 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(Inconsistency)。 如果为了实现一致性(Consistency)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(Low Perf) ，但这与我们开始的希望不符合。 TIP So，强一致性代表着低性能。 设计目标 由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：检查，容错以及快速从故障恢复。 主要支持大文件(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。 工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取 。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。 GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对大的流式读取，同时夜支持任意位置的小规模写入操作。 GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即原子操作。通常会有多个客户端会并行的对同一个文件进行append。 高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据 ，而很少有人对单个读写操作有严格的响应时间要求。 架构 单个master，多个chunk server(保存具体的文件)，多个client。 每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。 每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。 master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。 master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等 每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。 GFS Master中的metadata filename -\u0026gt; chunk ids(chunk handles) NV chunk handle与chunk数据的对应关系 chunk保存在哪个服务器上(chunk server list) chunk的version no NV chunk的primary chunk server，因为写操作在在其上进行 primary chunk server的lease expiration 这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。 每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)\nGFS Read Steps 首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。 master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。 然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。 client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近) ，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。 chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。 q1: 如果读取的数据跨越了一个chunk怎么办？ 例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界， 所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。\n多个副本之间变更顺序的一致性 针对一个chunk\nmaster授权给某个持有这个chunk的server一个租约期限(60s)，称为primary。 primary对所有的更改操作进行排序(serial order)，然后其他的secondary根据这个顺序进行变更。 只要这个chunk正在变更，那么primary就可以向master申请延长租约。 GFS Write Steps client向master发送请求获取chunk server list(primary,secondaries)， 如果没有primary，master就会选择一个secondary成为primary。 client获取到chunk server list后会缓存下来，只有当primary 没有响应或租约过期后才会再次请求。 client将数据推送到所有replicas，客户端不保证推送的顺序，每个chunk server会将数据保存在内部的lur cache中，直到数据被使用或过期。 当所有replicas都收到了数据，client将会发送一个写请求到primary，它标识了之前推送到每个副本的数据。 primary将这些写入组织成一定的顺序应用到自己本地。 primary然后将这个应用顺序转发给各个secondary。 secondaries应用这个顺序完成修改并答复primary。 primary答复client，如果出现了任意错误也会答复给client。在出现错误的情况下，write request也可能在primary以及secondary中成功 (如果primary直接就失败了，那么它将不会转发serial order给secondaries)，client将认为这次请求是失败的，它会通过重试来处理( 3-7尝试几次重新写入) GFS Atomic Record Appends 对同一片区域个并发写入是不可序列化的 这片区域可能最终包含多个客户端的数据片段。 一个原子的append操作。recored append至少会在给定的offset(GFS自己选择的，因为这里可能会失败，可能有一些chunk server上有这个数据) 上追加到文件上一次，并将该offset返回给client。它类似O_APPEND保证原子性。 recored append遵守 GFS Write Steps 流程，但是有一些特别的地方:\nclient推送所有数据后，primary会检查append到该chunk后是否超过了单个chunk的大小。 如果超过了，则在当前chunk填充到最大offset时(secondary也要保存)，回复client，指出该操作应该在下一个chunk上重试( record的大小需要控制在单个chunk最大值的四分之一，以保证碎片在可接收的水平)。 如果没有超过最大大小，则按照正常的情况进行保存。 过期副本检测 如果chunk server发生故障而宕机或者丢失了某些更新请求，那么它就有可能过期了。对于每个chunk，master都维护了一个version no来标识最新和过期的副本。\n当master为一个chunk的primary server授权或续期时就会增加version no并通知所有replicas进行更新。\n在数据一致的情况下，master和所有replicas的version no是一致的(在client发送写请求之前可以保证)。\n当chunk server重启或上报version no时，master会检查它时否包含过期的副本，如果发现master发现version no大于它的记录，master会采用更高的version no进行更新。\nmaster通过周期性的垃圾回收来删除过期的副本，在删除前，它会确认在它所有client的chunk信息请求的应答中没有包含这个过期的副本。\nclient在从master获取chunk server列表时会附带获取version no，所以它可以进行比对，选择最新的副本进行操作。\n总结 这并不是一个合格的多副本，多活，高可用，故障自修复的分布式系统。\nLinks gfs paper 原文 gfs paper 中文翻译 gfs 视频 gfs 视频翻译 Bad Replication Design ","permalink":"https://fzdwx.github.io/posts/2022-10-07-gfs/","summary":"为了性能(Performance), 所以将数据分割放到大量的服务器上，从而实现并行的读取数据，这就是分片(Sharding)。 而成败上千的机器总会发生错误，所以有了容错(Fault Tolerance)。 实现容错最简单的方式就是复制(Replication)，其中一个发生故障了就切换另一个。 使用了复制，如果你不够小心，那么它们之间就可能会不一致。数据就有可能出现问题，所以就有了不一致的问题(Inconsistency)。 如果为了实现一致性(Consistency)，那么就需要多进行额外的交互来保证一致性，所以代价就是低性能(Low Perf) ，但这与我们开始的希望不符合。 TIP So，强一致性代表着低性能。 设计目标 由于GFS是建立在大量的计算机上的，而这些计算机会不可避免的发生故障。所以必须要进行：检查，容错以及快速从故障恢复。 主要支持大文件(例如说好几个G的文件)，同时也支持小文件但不做针对性的优化。 工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取 。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。 GFS中的文件通常上一旦完成写入就很少会再次修改，所以主要针对大的流式读取，同时夜支持任意位置的小规模写入操作。 GFS对多个客户端并行添加同一个文件必须要有非常有效且明确语义的支持，即原子操作。通常会有多个客户端会并行的对同一个文件进行append。 高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据 ，而很少有人对单个读写操作有严格的响应时间要求。 架构 单个master，多个chunk server(保存具体的文件)，多个client。 每个文件被拆分为一定大小(64mb)的块(chunk)，且每个chunk有一个唯一的64位的标志(chunk handle)。 每个chunk都会在不同的chunk server上保存备份(默认是3个)，用户可以指定不同的复制级别。 master管理元数据(metadata)，例如文件到chunk的映射关系，chunk的位置信息等。 master管理chunk的分片，孤点chunk的垃圾回收机制，chunk server之间的镜像管理等 每个chunk server与master之间有心跳机制，并在检测的过程中年发出指令并收集状态。 GFS Master中的metadata filename -\u0026gt; chunk ids(chunk handles) NV chunk handle与chunk数据的对应关系 chunk保存在哪个服务器上(chunk server list) chunk的version no NV chunk的primary chunk server，因为写操作在在其上进行 primary chunk server的lease expiration 这两个data table都在master的内存中存放，为了容错(例如说重启后数据不丢失数据)，它会在磁盘上存储log，读取的使用从内存里面读取，写的时候会写入内存以及磁盘。 每当有数据变更时，就会在磁盘上的日志进行追加，并且定期(日志增长超过某一个大小)创建checkpoint(类似快照，不用从头开始读取)\nGFS Read Steps 首先读请求就表明client有filename以及想要读取的位置(offset)，然后发送给master。 master收到请求后就从filenames中获取对应的chunk handles。而每个chunk的大小上固定的，所以就得到的具体开始的chunk handle。 然后根据chunk handle找到对应存放数据的chunk server的列表返回给client。 client可以选择一个server来进行读取(论文中说会选择一个最近的服务器，应为google里面ip是连续的，可以根据ip判断远近) ，应为客户端每次只读取1mb或者64kb的数据，所以它会缓存chunk与chunk server的关系，这样就不用每次都请求。 chunk server收到请求后，根据chunk handle(推测chunk是安装chunk handle进行命名的)找到对应的chunk以及offset对应的数据给客户端。 q1: 如果读取的数据跨越了一个chunk怎么办？ 例如说client想要读取的数据超过了64mb，或者仅仅上是2个byte却跨越了chunk，client会在发送请求时注意到这次请求跨越了边界， 所以会将一个请求拆分为2个请求发送到master，所以这里可能上向master发送两次读请求，之后在向不同的chunk server读取数据。","title":"GFS"},{"content":"查看当前backlight由什么控制:\n一般都是intel。\nls /sys/class/backlight 查看当前的亮度:\ncat /sys/class/backlight/intel_backlight/max_brightness 修改亮度:\necho 5000 | sudo tee /sys/class/backlight/intel_backlight/brightness ","permalink":"https://fzdwx.github.io/posts/2022-10-04-backlight/","summary":"由于使用DWM，它不能像KDE那样之间有图形化的亮度调节功能，所以记录一下。","title":"调节linux屏幕的亮度"},{"content":" ranger 配置推荐 https://zhuanlan.zhihu.com/p/105731111 https://zhuanlan.zhihu.com/p/441083543 fzf https://github.com/junegunn/fzf ranger https://github.com/ranger/ranger End\n","permalink":"https://fzdwx.github.io/notes/1/","summary":"ranger 配置推荐 https://zhuanlan.zhihu.com/p/105731111 https://zhuanlan.zhihu.com/p/441083543 fzf https://github.com/junegunn/fzf ranger https://github.com/ranger/ranger End","title":"终端下好用的程序"},{"content":"安装: git clone https://git.suckless.org/dwm cd dwm sudo make clean install 启动 如果已经有了sddm，可以使用sudo systemctl disable sddm.service 来进行关闭，如果到时候不想用了可以用sudo systemctl enable sddm.service来开启sddm。\n# 准备配置文件 cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc # 添加 exec dwm # 注释 #twm \u0026amp; #xclock -geometry 50x50-1+1 \u0026amp; #xterm -geometry 80x50+494+51 \u0026amp; #xterm -geometry 80x20+494-0 \u0026amp; #exec xterm -geometry 80x66+0+0 -name login 然后重启并调用startx即可。\n遇到的问题 直接断网 使用NetworkManager进行连接，可能要用到dhcpcd。\nnmcli device wifi list nmcli device wifi connect {{wifi name}} password {{pwd}} 可能会连接失败，你可以试试nmcli connection show 来查看是否存在以前的连接信息，可以用nmcli connection delete {{wifi name}}来删除对应的信息\n输入法失效 添加配置文件\nvim ~/.pam_environment INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=@im=fcitx5 添加启动命令\nvim ~/.xinitrc1 # 在exec dwm之前添加 exec fcitx5 \u0026amp; 扩展屏幕无效 # 可以先查看有哪些屏幕 xrandr # # 将下面的命令加入 ~/.xinitrc1 中，在exec dwm之前添加 # 我有两个，是上下关系，所以用below 其他有 left 以及 right xrandr --output eDP-1-1 --auto --below HDMI-0 常用快捷键 可以参考我配置： https://github.com/fzdwx/dwm MOD -\u0026gt; WIN\n快捷键 desc MOD+SHIFT+ENTER 新开终端 在本tag内切换聚焦窗口 快捷键 desc ALT + tab 切换聚焦窗口 MOD + up 切换聚焦窗口 MOD + down 切换聚焦窗口 跨tag操作 快捷键 desc MOD + left / right 切换tag MOD + SHIGT + left / tight 将当前窗口移动到其他tag MOD + a 第一次是显示所有tag，第二次是跳转到聚焦的窗口所在的窗口 窗口操作 快捷键 desc MOD + q 退出窗口 MOD + h 隐藏窗口 MOD + SHIFT + h 显示窗口（像一个栈一样。） MOD + ENTER 将当前窗口设置为主窗口 MOD + f 将当前窗口全屏 MOD + CTRL + 方向键 移动窗口 MOD + ALT + 方向键 调整窗口大小 MOD + o 只显示当前窗口/显示所有窗口 MOD + t 开启/关闭 聚焦目标的浮动模式 MOD + SHIFT + t 开启/关闭 全部目标的浮动模式 | MOD + SHIFT + f | 开启/关闭 状态栏 |\n切换屏幕 快捷键 desc MOD + x 将鼠标移动到其他屏幕 MOD + SHIFT + X 将当前窗口移动到其他屏幕 Links ArchWiki Dwm Dwm patches Dwm patches中文翻译 picom美化 ","permalink":"https://fzdwx.github.io/posts/2022-09-29-dwm/","summary":"安装: git clone https://git.suckless.org/dwm cd dwm sudo make clean install 启动 如果已经有了sddm，可以使用sudo systemctl disable sddm.service 来进行关闭，如果到时候不想用了可以用sudo systemctl enable sddm.service来开启sddm。\n# 准备配置文件 cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc # 添加 exec dwm # 注释 #twm \u0026amp; #xclock -geometry 50x50-1+1 \u0026amp; #xterm -geometry 80x50+494+51 \u0026amp; #xterm -geometry 80x20+494-0 \u0026amp; #exec xterm -geometry 80x66+0+0 -name login 然后重启并调用startx即可。\n遇到的问题 直接断网 使用NetworkManager进行连接，可能要用到dhcpcd。\nnmcli device wifi list nmcli device wifi connect {{wifi name}} password {{pwd}} 可能会连接失败，你可以试试nmcli connection show 来查看是否存在以前的连接信息，可以用nmcli connection delete {{wifi name}}来删除对应的信息","title":"Dwm初体验"},{"content":" 由于最近切换到了linux，不可避免的经常需要使用vi等编辑器，所以这次好好折腾一下。\n我的配置地址: https://github.com/fzdwx/nvim 。\n我的配置 pakcer 我选用的插件管理器是packer，我也不知道选什么好，就按最新的来吧。\n--- setup packer local fn = vim.fn local install_path = fn.stdpath(\u0026#39;data\u0026#39;) .. \u0026#39;/site/pack/packer/start/packer.nvim\u0026#39; if fn.empty(fn.glob(install_path)) \u0026gt; 0 then packer_bootstrap = fn.system({ \u0026#39;git\u0026#39;, \u0026#39;clone\u0026#39;, \u0026#39;--depth\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;https://github.com/wbthomason/packer.nvim\u0026#39;, install_path }) vim.cmd(\u0026#34;packadd packer.nvim\u0026#34;) end --- add plugins require(\u0026#39;packer\u0026#39;).startup(function(use) -- 自托管 use \u0026#39;wbthomason/packer.nvim\u0026#39; -- 其他插件 -- 如果是第一次则同步 if packer_bootstrap then require(\u0026#39;packer\u0026#39;).sync() end end) alpha 是一个dashboard，也可以说是一个欢迎界面。\nrequire(\u0026#39;packer\u0026#39;).startup(function(use) -- ... --- 添加下面两行进行安装 use \u0026#34;goolord/alpha-nvim\u0026#34;; use \u0026#34;kyazdani42/nvim-web-devicons\u0026#34;; -- ... end) 配置代码太长了就不放了，可以点击这里 这里 参考。\ntelescope 主要作用是文件的查找与预览。\nrequire(\u0026#39;packer\u0026#39;).startup(function(use) -- ... --- 添加下面代码进行安装 use { \u0026#39;nvim-telescope/telescope.nvim\u0026#39;, tag = \u0026#39;0.1.0\u0026#39;, \u0026#34;ahmedkhalf/project.nvim\u0026#34;, \u0026#39;nvim-lua/plenary.nvim\u0026#39;, } -- ... end) 配置 key map 一些教程 Rust and nvim ","permalink":"https://fzdwx.github.io/posts/2022-09-28-neovim-use-notes/","summary":"由于最近切换到了linux，不可避免的经常需要使用vi等编辑器，所以这次好好折腾一下。","title":"Neovim使用记录  "},{"content":" HTTP 1.1之前的实现就不讨论了，因为它们已经过时太久了，我上网的时候就已经接触不到了，所以主要说说HTTP/1.1、HTTP/2。\nHTTP/1.1 HTTP/1.1协议报文简介 CRLF: \\r\\n\nMETHOD: HTTP请求，GET、POST、PUT、DELETE\u0026hellip;\nURI: 统一资源标识符，例如/，/index.html\u0026hellip;\nHTTPVersion: HTTP协议的版本号，例如HTTP/1.1，HTTP/2\nHEADERS: 请求头，例如Host:localhost，Accept: */*。\nBODY: 请求体，例如说一个JSON数据{\u0026quot;name\u0026quot;:\u0026quot;fzdwx\u0026quot;}\nHTTPStatus: HTTP响应状态，常见的有200，404等\nHTTPStatusDesc: HTTP响应状态描述，200对应的OK。\n请求 METHOD\u0026lt;SPACE\u0026gt;URI\u0026lt;SPACE\u0026gt;HTTPVersion HEADERS \u0026lt;CRLF\u0026gt; BODY 示例:\nGET /hello HTTP/1.1 Host: 192.168.1.107:8889 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.82 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 响应 HTTPVersion HTTPStatus HTTPStatusDesc HEADERS \u0026lt;CRLF\u0026gt; BODY 示例:\n如果响应中使用了transfer-encoding: chunked这个来替代Content-Length ，就表示这是一个不固定大小的响应，结尾通常用0\\r\\n来分割。\nHTTP/1.1 200 OK transfer-encoding: chunked content-type: application/json; charset=utf-8 0/r/n HTTP/1.1主要新特性 默认是长连接(Connection: Keep-alive)，支持一个TCP连接处理多个请求。 缓存策略，在请求头中使用Cache-Control，Expires，Last-Modified，ETag等来控制。 允许响应分块，就是上面提到的transfer-encoding: chunked，允许服务端可以多次返回响应体。 但是还是存在一定的问题，例如说如果有一个TCP连接阻塞了，还是会开启新的TCP连接进行处理请求。\nH2 HTTP2中的主要概念:\nConnection: 一个TCP连接包含一个或多个Stream,所有的通讯都在一个TCP连接上完成。 Stream: 一个可以双向通讯的数据流，包含一条或多条Message，每个数据流都一个唯一标识符以及可选的优先级信息。 Message: 对应HTTP/1.1中的请求或响应，包含一条或多条Frame。 Frame: 最小传输单位，它以二进制进行编码。 HTTP通讯简图 在HTTP/1.1中是有Start Line + header + body 组成的，而在H2中是由一个HEADER Frame以及多个DATA Frame组成的。\nHTTP/1.1与H2报文组成的区别 Frame 通常有一些公共的字段，例如Length，Type，Flags以及Stream Id；也各个类型所独有的字段。\n分类如下:\nDATA : 用于传输http消息体。 HEADERS : 用于传输首部字段。 PRIORITY : 用于指定或重新指定引用资源的优先级。 RST_STREAM : 用于通知流的非正常终止。 SETTINGS : 用于约定客户端和服务端的配置数据。例如设置初识的双向流量控制窗口大小。 PUSH_PROMISE : 服务端推送许可。 PING : 用于计算往返时间，执行“ 活性” 检活。 GOAWAY : 用于通知对端停止在当前连接中创建流。 WINDOW_UPDATE : 用于调整个别流或个别连接的流量。 CONTINUATION : 专门用于传递较大 HTTP 头部时的持续帧。 为什么H2必须要走HTTPS？ 这其实在H2标准中没有规定，主要是为了更方便的进行HTTP协议的 升级/协商，确认一个Web服务器是否支持H2通常有两种方式:\n在请求头中设置Upgrade: HTTP/2.0以及Connection: Upgrade,HTTP2-Settings等，类似升级到Websocket。 使用TLS中的ALPN(Application Layer Protocol Negotiation，应用层协议协商)中的ALPN Next Protocol 字段，在Client Hello与Server Hello这个阶段就可以确定下来。 而现在的浏览器基本都是实现的方式二，即与HTTPS绑定在一起。但是如果我们不用浏览器进行访问，当然也可以不用HTTPS。\n详细可参考 。\n为什么H2能实现并行响应请求? 在HTTP/1.1中，请求与响应是一一对应的，在同一个连接里，客户端依次发送两个请求，一段时间以后收到来自服务器的一个响应，这个响应一定是对应于第一个发出去的请求的。 因为没有一个标志来表示哪个响应对应哪个请求。\n而在H2中基于Stream和Frame的设计: 每个Frame都带有Stream Id来标识是否为同一个Stream里面的数据，每个Stream 互不影响，这样就能做到在一个TCP里面连接里面传输多对请求/响应。\nH2的新特性 H2的对HTTP/1.1优化的核心就是 使用尽可能少的连接数。\n多路复用: 只用一个TCP连接就能处理多对 请求/响应 ，不用在开启另外的TCP连接，就是通过Stream与Frame来实现的。 二进制分帧: 使用Frame为最小单位进行通讯，并采用二进制编码。 头部压缩 : 使用HPACK算法进行优化. 维护一份相同的静态字典 ，包含常见的请求头的KV组合 一份动态字典，可以动态的扩容(每个连接单独维护) 支持哈夫曼编码(静态哈夫曼码表 ) 在HTTP/1中消息体可以用gzip进行压缩，但是请求头通常没有任何压缩，有时候请求头的数据可能比请求体的数据还多。\n请求优先级: 一般在HEADERS帧与PRIORITY帧中携带，通常依赖于服务端的支持程度。 工具 生成测试签名 go run $GOROOT/src/crypto/tls/generate_cert.go --host localhost 使用curl调试HTTPS curl https://zcygov.cn -vv Links Hypertext Transfer Protocol Version 2 (HTTP/2) HPACK: Header Compression for HTTP/2 HTTP/2资料汇总 HTTP/2中帧的定义 HTTP/2新的机遇与挑战 探索http1.0到http3.0的发展史，详解http2.0 HTTP/2相比1.0有哪些重大改进 ","permalink":"https://fzdwx.github.io/posts/2022-09-28-http-protocol/","summary":"简介HTTP/1.1与H2。","title":"HTTP协议"},{"content":"看的时候很懵，写的时候更懵，我以为是要写几个MapReduce的程序，在把官方的A few rules以及Hints( 翻译可以看这里 ) 仔细的阅读了几遍后才发现是要写一个 MapReduce 的调度框架。。。\n解题思路可以分为 3 步。\nworker与master先通过rpc进行通信，即worker发送请求，master能够正确的应答且worker 能够收到。这一部分其实示例代码已经给到了，可以模仿着写一个从master获取需要执行的任务名称的rpc request。 上面一步完成后就可以进行真正的Map task请求以及执行了: Map task何时生成？ 每个worker只向master请求一次就好了吗？ Map task执行 超时/失败 需要有重试机制吗？ 如何保证Map task消费时的线程安全？ 当所有的Map task执行完毕后就需要执行Reduce task了，如果你写完了第 2 步，那么Reduce task其实就是水到渠成了。 生成Reduce task，这里的每个Reduce task需要加载的文件按什么分成一组？ 剩下的与Map task处理方法相同。 我就是卡在了Reduce task创建时文件分组这个地方了，我直接把同一个Map task生成的文件当成一组了\u0026hellip;但是显然不是这样。\n","permalink":"https://fzdwx.github.io/posts/2022-09-27-mit6.824-lab1/","summary":"about mit6.824 lab1(Map reduce framework)","title":"MapReduce 框架实现思路"},{"content":" 今天发现了一个 linux 下的 application launcher rofi ，它可以快速切换窗口和启动程序， 我用它和wmctrl进行配合使用。\n我的使用过程:\n1.Archlinux install\nyay -S rofi 2.添加自定义快捷键绑定 hotkey 为alt+space触发rofi -show。\n3.pressalt+space，然后使用shift+leftorright进行切换 mode 。\n更改主题以及显示 icon:\n1.生成配置文件\nmkdir -p ~/.config/rofi rofi -dump-config \u0026gt; ~/.config/rofi/config.rasi 2.显示icon\nsed -i \u0026#39;8c show-icons: true;\u0026#39; ~/.config/rofi/config.rasi 3.更换主题\n参考 https://github.com/lr-tech/rofi-themes-collection#installing-themes 我的wmctrl的配置示例:\n使用xprop WM_CLASS获取前缀。\nalias chrome=\u0026#34;wmctrl -x -a google-chrome || google-chrome-stable \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias note=\u0026#34;wmctrl -x -a obsidian || /usr/bin/obsidian \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias codew=\u0026#34;wmctrl -x -a code || /opt/code/code \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias idea=\u0026#34;wmctrl -x -a jetbrains-idea || /opt/idea/bin/idea.sh \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; alias discord=\u0026#34;wmctrl -x -a discord || /opt/discord/Discord \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; ","permalink":"https://fzdwx.github.io/posts/2022-09-18-about-rofi/","summary":"一个 linux 下的 application launcher, 让你只用键盘就可以进行应用的启动与切换。","title":"About rofi"},{"content":"","permalink":"https://fzdwx.github.io/flomo/","summary":"","title":""}]